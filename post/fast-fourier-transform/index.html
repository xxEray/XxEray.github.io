<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/avatar/32x32.svg"><link rel="icon" type="image/png" sizes="16x16" href="/images/avatar/16x16.svg"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="LavaqR3reMZmRPWz7fE1RgWE4SdWo2zZcJCFNM9LXd4"><meta name="baidu-site-verification" content="code-nON36aVCZ5"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Microsoft+Yahei:300,300italic,400,400italic,700,700italic%7CConsolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"xxeray.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"waline","storage":true,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="换一条看起来更长的路走，有时会带来意想不到的惊喜！"><meta property="og:type" content="article"><meta property="og:title" content="快速傅里叶变换（FFT）及快速数论变换（NTT）详解"><meta property="og:url" content="https://xxeray.github.io/post/fast-fourier-transform/"><meta property="og:site_name" content="Eray&#39;s Blog"><meta property="og:description" content="换一条看起来更长的路走，有时会带来意想不到的惊喜！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xxeray.github.io/post/fast-fourier-transform/%E5%8D%95%E4%BD%8D%E6%A0%B9.png"><meta property="article:published_time" content="2022-03-20T05:29:47.000Z"><meta property="article:modified_time" content="2024-06-20T02:37:32.162Z"><meta property="article:author" content="Eray"><meta property="article:tag" content="数论"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xxeray.github.io/post/fast-fourier-transform/%E5%8D%95%E4%BD%8D%E6%A0%B9.png"><link rel="canonical" href="https://xxeray.github.io/post/fast-fourier-transform/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xxeray.github.io/post/fast-fourier-transform/","path":"post/fast-fourier-transform/","title":"快速傅里叶变换（FFT）及快速数论变换（NTT）详解"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>快速傅里叶变换（FFT）及快速数论变换（NTT）详解 | Eray's Blog</title><link rel="dns-prefetch" href="https://waline-1-g2268155.deta.app/"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Eray's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Eray's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">不管怎么样，明天又是新的一天。</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-user-friends fa-fw"></i>友链</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comment fa-fw"></i>留言板</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BD%8D%E6%A0%B9"><span class="nav-text">单位根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-text">多项式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fft"><span class="nav-text">FFT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="nav-text">几个概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95"><span class="nav-text">非递归写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%86-fftifft"><span class="nav-text">逆 FFT（IFFT）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ntt"><span class="nav-text">NTT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-nttmtt"><span class="nav-text">任意模数 NTT（MTT）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-text">代码</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Eray" src="/images/avatar/640x640.svg"><p class="site-author-name" itemprop="name">Eray</p><div class="site-description" itemprop="description">主要记录 OI 中的算法、题解、经验交流。</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/xxEray" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xxEray" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:xxeray@qq.com" title="邮箱 → mailto:xxeray@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>邮箱</a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://unpkg.com/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://xxeray.github.io/post/fast-fourier-transform/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar/640x640.svg"><meta itemprop="name" content="Eray"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Eray's Blog"><meta itemprop="description" content="主要记录 OI 中的算法、题解、经验交流。"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="快速傅里叶变换（FFT）及快速数论变换（NTT）详解 | Eray's Blog"><meta itemprop="description" content="换一条看起来更长的路走，有时会带来意想不到的惊喜！"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">快速傅里叶变换（FFT）及快速数论变换（NTT）详解</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-20 13:29:47" itemprop="dateCreated datePublished" datetime="2022-03-20T13:29:47+08:00">2022-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/knowledge-point/" itemprop="url" rel="index"><span itemprop="name">知识点</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/post/fast-fourier-transform/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/post/fast-fourier-transform/" itemprop="commentCount"></span></a></span></div><div class="post-description">换一条看起来更长的路走，有时会带来意想不到的惊喜！</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="前置知识">前置知识</h2><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/complex/">复数</a><br>单位根（下面讲）<br>多项式（下面讲）</p><h3 id="单位根">单位根</h3><p>前置知识：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/complex/">复数</a></p><p>在复平面上，所有与原点距离为 <span class="math inline">\(1\)</span> 的点组成单位圆。<br>由于两个复数相乘的法则（辐角相加，模长相乘），在单位圆上的两个复数相乘还是在单位圆上（模长都是 <span class="math inline">\(1\)</span>），且辐角为这两个复数相加。<br>所以对于 <span class="math inline">\(x^n=1\)</span> 这个方程来说，它的解在单位圆上，且辐角为 <span class="math inline">\(\frac{360}{n}\)</span> 的倍数，显然这样的复数有 <span class="math inline">\(n\)</span> 个，我们把这样的 <span class="math inline">\(n\)</span> 个复数叫做 <strong><span class="math inline">\(n\)</span> 次单位根</strong>，并将其中辐角最小的（<span class="math inline">\(1\)</span> 除外）记作 <span class="math inline">\(\omega_n\)</span>。<br>所有 <span class="math inline">\(\omega_n^i\)</span> 都是 <span class="math inline">\(n\)</span> 次单位根。</p><img data-src="/post/fast-fourier-transform/%E5%8D%95%E4%BD%8D%E6%A0%B9.png" title="单位根"><p>上图就是 <strong><span class="math inline">\(11\)</span> 次单位根</strong> 在复平面上的表示。</p><p>单位根有三个引理：（<del>证明显然</del>）</p><ol type="1"><li>消去引理：<span class="math inline">\(\omega_{kn}^{km} = \omega_n^m\)</span></li><li>折半引理：<span class="math inline">\(\left(\omega_{n}^{k+\frac{n}{2}}\right)^2=\omega_{n}^{2k}=\omega_{\frac{n}{2}}^k\)</span></li><li>求和引理：<span class="math inline">\(\sum_{i=0}^{n-1} \left(\omega_n^k\right)^i = 0\)</span></li></ol><p>在 FFT 中，我们只需要用前两个。</p><h3 id="多项式">多项式</h3><p>这里我们讨论的多项式是只有一个变量 <span class="math inline">\(x\)</span> 的多项式，即 <span class="math inline">\(F(x) = \sum_{i=0}^n a_i x^i\)</span>。</p><p>多项式有两种表示方法：（设多项式有 <span class="math inline">\(n + 1\)</span> 项）</p><ol type="1"><li>系数表示，即将多项式表示成：<span class="math inline">\([a_0, a_2, \cdots, a_n]\)</span>，其中 <span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(x^i\)</span> 项的系数</li><li>点值表示，即将多项式表示成：<span class="math inline">\([(v_0, F(v_0)), (v_1, F(v_1)), \cdots, (v_n, F(v_n))]\)</span>，即将 <span class="math inline">\(n + 1\)</span> 个不同的值 <span class="math inline">\(v_i\)</span> 带入多项式得到 <span class="math inline">\(F(v_i)\)</span>，然后用这 <span class="math inline">\(n + 1\)</span> 个二元组唯一确定一个多项式。（不考虑那种无用点值之类的东西）</li></ol><p>容易发现，对于两个多项式 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(G(x)\)</span>，设 <span class="math inline">\(H(x) = F(x) \times G(x)\)</span>，如果有 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(G\)</span> 的点值表示，那么 <span class="math inline">\(H\)</span> 的点值表示也可以很快算出来：<span class="math inline">\(H(v_i) = F(v_i) \times G(v_i)\)</span>。</p><p>所以，FFT 要做的事就是将系数表示转换成点值表示（及其逆过程，这个后面再说）。</p><h2 id="fft">FFT</h2><h3 id="几个概念">几个概念</h3><ol type="1"><li>离散傅里叶变换（Discrete Fourier Transform，DFT），即 <strong>将系数表示转换成点值表示</strong>，其中 <span class="math inline">\(v_i = \omega_n^i\)</span>。</li><li>快速傅里叶变换（即 <strong>快速（离散）傅里叶变换</strong>，Fast (Discrete) Fourier Transform，FFT），即快速做 DFT。</li></ol><h3 id="思路">思路</h3><div class="note warning"><p>从这里开始，我们将 <span class="math inline">\(n\)</span> 定为多项式的项数，而不是多项式的次数。</p></div><p>FFT 可以（且必须）直接计算 <span class="math inline">\(2^k\)</span> 个点值，所以我们将 <span class="math inline">\(n\)</span> 取到比它大（或等于它）的最小的 <span class="math inline">\(2\)</span> 的幂次。（<span class="math inline">\(n \gets 2^k\)</span>）</p><p>设多项式为 <span class="math inline">\(F(x) = \sum_{i=0}^{n - 1} a_i x^i\)</span>，并且令点值表示法为 <span class="math inline">\([(v_0, y_0), (v_1, y_1), \cdots, (v_{n-1}, y_{n-1})]\)</span>。<br>容易发现 <span class="math inline">\(y_i = \sum_{j=0}^n a_j (v_i)^j = \sum_{j=0}^n a_j v_i^j\)</span>。</p><p>我们首先将 <span class="math inline">\(F(x)\)</span> 的系数 <span class="math inline">\(A = [a_0, a_1, \cdots, a_{n - 1}]\)</span> 按奇偶分为 <span class="math inline">\(A^{[0]}\)</span> 和 <span class="math inline">\(A^{[1]}\)</span>，即：<br><span class="math inline">\(A^{[0]} = [a_0, a_2, \cdots, a_{n - 2}]\)</span>, <span class="math inline">\(A^{[1]} = [a_1, a_3, \cdots, a_{n - 1}]\)</span>。</p><p>那么我们会发现 <span class="math inline">\(F(x) = F^{[0]}(x^2) + xF^{[1]}(x^2)\)</span>，<del>读者自证不难</del>。<br>所以我们就有了一个分治想法：用 <span class="math inline">\(F^{[0]}\)</span> 和 <span class="math inline">\(F^{[1]}\)</span> 的点值表示来算出 <span class="math inline">\(F\)</span> 的点值表示。</p><p>但是这里会有一个问题：<span class="math inline">\(F^{[0]}\)</span> 和 <span class="math inline">\(F^{[1]}\)</span> 的点值表示都只有 <span class="math inline">\(\frac n2\)</span> 个，所以合并后也只有 <span class="math inline">\(\frac n2\)</span> 个。<br>所以我们还需要用 <span class="math inline">\(F^{[0]}\)</span> 和 <span class="math inline">\(F^{[1]}\)</span> 的 <span class="math inline">\(\frac n2\)</span> 个点值来求出 <span class="math inline">\(F\)</span> 的后 <span class="math inline">\(\frac n2\)</span> 个点值。</p><p>这怎么办呢？随便取 <span class="math inline">\((v_i, y_i)\)</span> 的值肯定是无法做到的，我们要取一些有特殊性质的值。现在就要用到我们之前说的单位根了。</p><p>我们取 <span class="math inline">\(v_i = \omega_n^i\)</span>，这有什么用呢？我们代两个值进去看看：（记 <span class="math inline">\(k&#39; = k + \frac n2\)</span>）</p><p><span class="math display">\[ \begin{aligned} F(v_k) = F(\omega_n^k) = F^{[0]}((\omega_n^k)^2) + \omega_n^k F^{[1]}((\omega_n^k)^2) = F^{[0]}(\omega_{\frac n2}^k) + \omega_n^k F^{[1]}(\omega_{\frac n2}^k)\\ F(v_{k&#39;}) = F(\omega_n^{k&#39;}) = F^{[0]}((\omega_n^{k&#39;})^2) + \omega_n^{k&#39;} F^{[1]}((\omega_n^{k&#39;})^2) = F^{[0]}(\omega_{\frac n2}^k) - \omega_n^k F^{[1]}(\omega_{\frac n2}^k) \end{aligned} \]</span></p><p>所以我们只需要用 <span class="math inline">\(F^{[0]}\)</span> 和 <span class="math inline">\(F^{[1]}\)</span> 点值表示就可以直接求出 <span class="math inline">\(F\)</span> 的点值表示啦。</p><p>然后怎么办呢？对于 <span class="math inline">\(n = 1\)</span> 的情况，<span class="math inline">\(F(x) = A_0 x\)</span>，又由于 <span class="math inline">\(n = 1\)</span>，所以 <span class="math inline">\(x_0 = 1\)</span>，那么 <span class="math inline">\(F(x)\)</span> 的点值表示就是 <span class="math inline">\(A_0\)</span> 啦。</p><h3 id="非递归写法">非递归写法</h3><p>由于 FFT 非常的常用，常数也很大，所以我们需要一定的卡常技巧。<del>为了学习隔壁的 zkw 线段树</del>我们发明出了 FFT 的非递归写法。</p><p>首先我们发现，只要求出所有 <span class="math inline">\(n = 1\)</span> 时的点值表示，其它的就可以轻松地用循环求出（把递归树画出来，用循环模拟过程。因为 <span class="math inline">\(n\)</span> 是 2 的幂次，所以很好模拟）。</p><p>所以现在我们只需要求出 <span class="math inline">\(n = 1\)</span> 时的点值表示。考虑一个递归过程：（每次将上面一行 <span class="math inline">\(A\)</span> 分成两个 <span class="math inline">\(A^{[0]}\)</span> 和 <span class="math inline">\(A^{[1]}\)</span>，将两个数组用 <code>|</code> 隔开）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F(8): a[0]   a[1]   a[2]   a[3]   a[4]   a[5]   a[6]   a[7]</span><br><span class="line">F(4): a[0]   a[2]   a[4]   a[6] | a[1]   a[3]   a[5]   a[7]</span><br><span class="line">F(2): a[0]   a[4] | a[2]   a[6] | a[1]   a[5] | a[3]   a[7]</span><br><span class="line">F(1): a[0] | a[4] | a[2] | a[6] | a[1] | a[5] | a[3] | a[7]</span><br></pre></td></tr></table></figure><p>我们再来看最后一行的下标，这次我们用二进制表示出来：（上面是十进制，下面是二进制）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 0   4   2   6   1   5   3   7</span><br><span class="line">000 100 010 110 001 101 011 111</span><br></pre></td></tr></table></figure><p>这个二进制有什么规律呢？我们将每个二进制倒过来并转成十进制看看：（上面是倒过来的二进制，下面是十进制）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">000 001 010 011 100 101 110 111</span><br><span class="line"> 0   1   2   3   4   5   6   7</span><br></pre></td></tr></table></figure><p>现在规律已经很明显了。我们要求的数在二进制意义下倒过来是顺序排列的，我们把这种序列叫做 <strong>逆二进制序</strong>。</p><p>那么现在我们就解决了非递归版的 FFT。</p><p>代码在最后面。</p><h2 id="逆-fftifft">逆 FFT（IFFT）</h2><p>我们再回到之前的公式：<span class="math inline">\(y_i = \sum_{j=0}^n a_j \omega_n^{ij}\)</span>。<br>我们把它写成矩阵：<span class="math inline">\(\textbf{y} = \textbf{V}_n \times \textbf{a}\)</span>，其中 <span class="math inline">\(\left(\textbf{V}_n\right)_{i,j} = \omega_n^{ij}\)</span>。<br>所以 <span class="math inline">\(\textbf{a} = \textbf{V}_n^{-1} \textbf{y}\)</span>，其中 <span class="math inline">\(\textbf{V}_n^{-1}\)</span> 是 <span class="math inline">\(\textbf{V}\)</span> 的逆矩阵。<br>通过某些<del>我不会的</del>方法算出来：<span class="math inline">\(\left(\textbf{V}_n^{-1}\right)_{i,j} = \frac{\omega_n^{-ij}}{n}\)</span>。<br>然后就用 FFT 的方法，改一下公式就好了。</p><p>代码在最后面。</p><h2 id="ntt">NTT</h2><p>FFT 的优势很多，但是缺陷也很明显：需要用 <code>double</code>，所以会有精度问题，而且不能取模。</p><p>那么有没有其它的东西可以支持取模且没有精度问题呢？当然是有的，这就是快速数论变换（NTT，Number Theoretic Transform）。</p><p>这里的 NTT 解决的是模数为 <span class="math inline">\(998244353\)</span> 的做法。如果是其它的模数，需要使用下面的 <a href="#任意模数-nttmtt">任意模数 NTT</a>。</p><p>首先观察一下 <span class="math inline">\(998244353\)</span> 的性质：（数论不懂的可以看看我 <a href="/post/number-theory-initial/">这篇</a> 博客）</p><ul><li>它是一个质数。</li><li><span class="math inline">\(\varphi(998244353) = 998244352 = 2^{23} \times 7 \times 17\)</span></li><li>它有 <a target="_blank" rel="noopener" href="https://oi-wiki.org/math/number-theory/primitive-root/#_4">原根</a>，其中一个是 <span class="math inline">\(3\)</span>。</li></ul><details class="note no-icon info"><summary><p>什么是原根？</p></summary><p>对于两个数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(m\)</span>，如果 <span class="math inline">\(\gcd(a, m) = 1\)</span>，那么我们有 <span class="math inline">\(a^{\varphi(m)} \equiv 1 \pmod m\)</span>（欧拉定理）。</p><p>如果对于任意 <span class="math inline">\(0 \le n &lt; \varphi(m)\)</span>，满足 <span class="math inline">\(a^n \not \equiv 1 \pmod m\)</span>，那么我们称 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(m\)</span> 的原根。</p></details><p>我们回到 FFT 上来。当时我们为什么要令 <span class="math inline">\(x_i = \omega_n^i\)</span> 呢？因为它满足一下几条性质：</p><ul><li><span class="math inline">\(\{\omega_n^i\} (0 \le i &lt; n)\)</span> 互不相同</li><li><span class="math inline">\(\omega_{km}^{kn} = \omega_m^n\)</span></li><li><span class="math inline">\(\left(\omega_{n}^{k+\frac{n}{2}}\right)^2=\omega_{n}^{2k}=\omega_{\frac{n}{2}}^k\)</span></li></ul><p>那么我们用原根是否也能做到这几条性质呢？答案是可以。</p><p>记原根为 <span class="math inline">\(g\)</span>（模数为 <span class="math inline">\(998244353\)</span> 时 <span class="math inline">\(g=3\)</span>），那么我们令 <span class="math inline">\(g_n = g^{p - 1 \over n}\)</span>，并令 <span class="math inline">\(x_i = g_n^i\)</span>。</p><p>那么我们可以证明这几条性质：（第一条上面 OI-Wiki 的链接里有，我 <del>不会证</del> 就不证了）</p><ul><li><span class="math inline">\(g_{km}^{kn} = g^{\frac{km(p - 1)}{kn}} = g^{\frac{m(p - 1)}{n}} = g_m^n\)</span></li><li><span class="math inline">\(\left(g_n^{k + \frac n2}\right)^2 = g_n^{2k+n} = g_n^{2k} = g_{\frac n2}^k\)</span></li></ul><p>那么我们就完美解决了所有性质，把 FFT 的板子套上去，换成 NTT 的公式就好了。</p><p>这时候有小可爱可能就会问了：你这个 <span class="math inline">\(g^{\frac{p - 1}{n}}\)</span> 中指数 <span class="math inline">\(\frac{p - 1}{n}\)</span> 有没有可能不是整数啊？</p><p>这就要用到上面的质因数分解了：<span class="math inline">\(p - 1 = 998244352 = 2^{23} \times 7 \times 17\)</span>，又因为前面我们把 <span class="math inline">\(n\)</span> 调整为 <span class="math inline">\(2\)</span> 的幂次了，所以当 <span class="math inline">\(n \le 2^{23} = 8388608 \approx 8.3 \times 10^6\)</span> 时都是够用的啦。</p><p>另外，这种方法不止适用于 <span class="math inline">\(998244353\)</span>，还有 <span class="math inline">\(469762049\)</span> 和 <span class="math inline">\(1004535809\)</span>。（它们的原根都是 <span class="math inline">\(3\)</span> 哦）</p><p>另外一些数也可以用这种方法，参见 <a target="_blank" rel="noopener" href="https://paste.ubuntu.com/p/nFswQRkZmJ/">原根表</a>。</p><p>代码在最后面。</p><h2 id="任意模数-nttmtt">任意模数 NTT（MTT）</h2><p>如果模数不是上面的，或者在输入中给定，又怎么办呢？</p><p>这时候就需要 <strong>任意模数 NTT</strong>（any Module NTT）了。</p><p>对于任意模数，我们无法得到上面的性质了。怎么办呢？我们可以自己取模数！</p><p>具体地，我们取一些模数 <span class="math inline">\(p_1, p_2, \cdots p_k\)</span> 使得答案多项式的系数在 <strong>取模之前</strong> 不会超过 <span class="math inline">\(\prod p_i\)</span>。一般来说取 <span class="math inline">\(3\)</span> 个质数（<span class="math inline">\(998244353\)</span>，<span class="math inline">\(469762049\)</span>，<span class="math inline">\(1004535809\)</span>）就够了。</p><p>然后我们先算出答案对每个 <span class="math inline">\(p_i\)</span> 取模的结果，利用 CRT 就可以求得答案对 <span class="math inline">\(\prod p_i\)</span> 取模的结果。又因为答案小于 <span class="math inline">\(\prod p_i\)</span>，所以这个结果就是答案。（可以在 CRT 的过程中就对原题模数取模，这样就不会爆 <code>long long</code>）然后将这个答案对题目中的模数取一次模就好了。</p><p>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4245">洛谷 P4245</a></p><p>代码在最后面。</p><h2 id="代码">代码</h2><p>都是非递归版的。</p><details class="note no-icon info"><summary><p>FFT 和 IFFT</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="comment">/* ... */</span> + <span class="number">5</span>; <span class="comment">// 2 * (n + m)</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> x_ = <span class="number">0</span>, <span class="type">double</span> y_ = <span class="number">0</span>) : <span class="built_in">x</span>(x_), <span class="built_in">y</span>(y_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;a, <span class="type">const</span> Complex &amp;b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;a, <span class="type">const</span> Complex &amp;b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;a, <span class="type">const</span> Complex &amp;b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FFT</span> &#123;</span><br><span class="line">	<span class="type">int</span> rev[N];</span><br><span class="line">	<span class="type">int</span> limit;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">		limit = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(limit &lt;= mx) limit &lt;&lt;= <span class="number">1</span>, w++; <span class="comment">// w = log2(limit)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (w - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(Complex *a, <span class="type">int</span> type)</span> </span>&#123; <span class="comment">// type = 1 / -1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) <span class="keyword">if</span>(i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			Complex wn = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(PI / i), type * <span class="built_in">sin</span>(PI / i));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++, w = w * wn) &#123;</span><br><span class="line">					Complex x = a[j + k], y = w * a[j + i + k];</span><br><span class="line">					a[j + k] = x + y;</span><br><span class="line">					a[j + i + k] = x - y;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">-1</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) a[i].x /= limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">trans</span><span class="params">(Complex *a, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123; <span class="type">int</span> ret = <span class="built_in">init</span>(n); <span class="built_in">trans</span>(a, type); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 需要先 init 再调用第一个 trans，或者直接调用第二个 trans</span></span><br></pre></td></tr></table></figure></details><details class="note no-icon info"><summary><p>NTT</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="comment">/* ... */</span> + <span class="number">5</span>; <span class="comment">// 2 * (n + m)</span></span><br><span class="line"><span class="keyword">template</span>&lt;LL mod, LL g&gt; <span class="keyword">struct</span> <span class="title class_">NTT</span> &#123;</span><br><span class="line">	<span class="type">int</span> rev[N];</span><br><span class="line">	<span class="type">int</span> limit;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">		limit = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(limit &lt;= mx) limit &lt;&lt;= <span class="number">1</span>, w++; <span class="comment">// w = log2(limit)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (w - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">qpow</span><span class="params">(LL x, LL y)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % mod; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % mod; &#125; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> type)</span> </span>&#123; <span class="comment">// type = 1 / -1</span></span><br><span class="line">		LL invg = <span class="built_in">inv</span>(g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) <span class="keyword">if</span>(i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			LL wn = <span class="built_in">qpow</span>(type == <span class="number">-1</span> ? invg : g, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">				LL w = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++, w = w * wn % mod) &#123;</span><br><span class="line">					LL x = a[j + k], y = w * a[j + i + k] % mod;</span><br><span class="line">					a[j + k] = (x + y) % mod;</span><br><span class="line">					a[j + i + k] = (x - y + mod) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">-1</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) (a[i] *= <span class="built_in">inv</span>(limit)) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123; <span class="type">int</span> ret = <span class="built_in">init</span>(n); <span class="built_in">trans</span>(a, type); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 需要先 init 再调用第一个 trans，或者直接调用第二个 trans</span></span><br></pre></td></tr></table></figure></details><details class="note no-icon info"><summary><p>任意模数 NTT（MTT）例题代码</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL P1 = <span class="number">469762049</span>;</span><br><span class="line"><span class="type">const</span> LL P2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> LL P3 = <span class="number">1004535809</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;LL mod, LL g&gt; <span class="keyword">struct</span> <span class="title class_">NTT</span> &#123;</span><br><span class="line">	<span class="type">int</span> rev[N];</span><br><span class="line">	<span class="type">int</span> limit;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">		limit = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(limit &lt;= mx) limit &lt;&lt;= <span class="number">1</span>, w++; <span class="comment">// w = log2(limit)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (w - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">qpow</span><span class="params">(LL x, LL y)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % mod; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % mod; &#125; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> type)</span> </span>&#123; <span class="comment">// type = 1 / -1</span></span><br><span class="line">		LL invg = <span class="built_in">inv</span>(g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) <span class="keyword">if</span>(i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			LL wn = <span class="built_in">qpow</span>(type == <span class="number">-1</span> ? invg : g, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">				LL w = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++, w = w * wn % mod) &#123;</span><br><span class="line">					LL x = a[j + k], y = w * a[j + i + k] % mod;</span><br><span class="line">					a[j + k] = (x + y) % mod;</span><br><span class="line">					a[j + i + k] = (x - y + mod) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">-1</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) (a[i] *= <span class="built_in">inv</span>(limit)) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123; <span class="type">int</span> ret = <span class="built_in">init</span>(n); <span class="built_in">trans</span>(a, type); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LL a[N], b[N], ca[N], cb[N], ans1[N], ans2[N], ans3[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL P;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL x, LL y, LL mod)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % mod; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % mod; &#125; &#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x, LL mod)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>, mod); &#125;</span><br><span class="line"></span><br><span class="line">NTT&lt;P1, <span class="number">3</span>&gt; ntt1;</span><br><span class="line">NTT&lt;P2, <span class="number">3</span>&gt; ntt2;</span><br><span class="line">NTT&lt;P3, <span class="number">3</span>&gt; ntt3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;P);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line">	<span class="type">int</span> limit = ntt1.<span class="built_in">init</span>(n + m);</span><br><span class="line">	ntt2.<span class="built_in">init</span>(n + m), ntt3.<span class="built_in">init</span>(n + m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ca[i] = a[i], cb[i] = b[i];</span><br><span class="line">	ntt1.<span class="built_in">trans</span>(ca, <span class="number">1</span>), ntt1.<span class="built_in">trans</span>(cb, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ans1[i] = ca[i] * cb[i] % P1;</span><br><span class="line">	ntt1.<span class="built_in">trans</span>(ans1, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ca[i] = a[i], cb[i] = b[i];</span><br><span class="line">	ntt2.<span class="built_in">trans</span>(ca, <span class="number">1</span>), ntt2.<span class="built_in">trans</span>(cb, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ans2[i] = ca[i] * cb[i] % P2;</span><br><span class="line">	ntt2.<span class="built_in">trans</span>(ans2, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ca[i] = a[i], cb[i] = b[i];</span><br><span class="line">	ntt3.<span class="built_in">trans</span>(ca, <span class="number">1</span>), ntt3.<span class="built_in">trans</span>(cb, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ans3[i] = ca[i] * cb[i] % P3;</span><br><span class="line">	ntt3.<span class="built_in">trans</span>(ans3, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">		<span class="comment">// 三个质数可以手推 CRT</span></span><br><span class="line">		<span class="comment">// 看着这个推也可以 https://www.cnblogs.com/Memory-of-winter/p/10223844.html</span></span><br><span class="line">		LL out = <span class="number">0</span>;</span><br><span class="line">		LL tmp = ans1[i] + (ans2[i] - ans1[i] + P2) % P2 * <span class="built_in">inv</span>(P1, P2) % P2 * P1;</span><br><span class="line">		out = (tmp + (ans3[i] - tmp % P3 + P3) % P3 * <span class="built_in">inv</span>(P1 * P2 % P3, P3) % P3 * P1 % P * P2 % P) % P;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, out);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>完结撒花~</p><details class="note no-icon info"><summary><p>参考资料</p></summary><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zwfymqz/p/8244902.html" class="uri">https://www.cnblogs.com/zwfymqz/p/8244902.html</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Y7411W73U" class="uri">https://www.bilibili.com/video/BV1Y7411W73U</a><br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P4245" class="uri">https://www.luogu.com.cn/problem/solution/P4245</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Memory-of-winter/p/10223844.html" class="uri">https://www.cnblogs.com/Memory-of-winter/p/10223844.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouyuheng2003/article/details/85561887" class="uri">https://blog.csdn.net/zhouyuheng2003/article/details/85561887</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Sakits/p/8416918.html" class="uri">https://www.cnblogs.com/Sakits/p/8416918.html</a><br><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/poly/ntt/" class="uri">https://oi-wiki.org/math/poly/ntt/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zarth/p/7288456.html" class="uri">https://www.cnblogs.com/zarth/p/7288456.html</a><br><a target="_blank" rel="noopener" href="http://www.longluo.me/blog/2022/05/01/Number-Theoretic-Transform/" class="uri">http://www.longluo.me/blog/2022/05/01/Number-Theoretic-Transform/</a></p></details></div><footer class="post-footer"><div class="post-tags"><a href="/tags/number-theory/" rel="tag"><i class="fa fa-tag"></i> 数论</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/suffix-array/" rel="prev" title="后缀数组详解"><i class="fa fa-chevron-left"></i> 后缀数组详解</a></div><div class="post-nav-item"><a href="/post/number-theory-initial/" rel="next" title="数论初识">数论初识 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Eray</span></div><div class="busuanzi-count"></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://unpkg.com/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline-1-g2268155.deta.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"写下你的评论…","sofa":"还没有评论~"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/weibo","https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili","https://unpkg.com/@waline/emojis@1.0.1/qq","https://unpkg.com/@waline/emojis@1.0.1/tieba","https://unpkg.com/@waline/emojis@1.0.1/tw-emoji"],"meta":["nick","mail","link"],"requiredMeta":["nick"],"wordLimit":0,"login":"enable","pageSize":10,"libUrl":"https://unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/post/fast-fourier-transform/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script></body></html>