<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/avatar/32x32.svg"><link rel="icon" type="image/png" sizes="16x16" href="/images/avatar/16x16.svg"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="LavaqR3reMZmRPWz7fE1RgWE4SdWo2zZcJCFNM9LXd4"><meta name="baidu-site-verification" content="code-nON36aVCZ5"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Microsoft+Yahei:300,300italic,400,400italic,700,700italic%7CConsolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"xxeray.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"waline","storage":true,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="长文预警！"><meta property="og:type" content="article"><meta property="og:title" content="生成函数讲稿"><meta property="og:url" content="https://xxeray.github.io/post/generating-function-lecture-notes/"><meta property="og:site_name" content="Eray&#39;s Blog"><meta property="og:description" content="长文预警！"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-05T00:35:42.000Z"><meta property="article:modified_time" content="2024-06-20T02:37:32.164Z"><meta property="article:author" content="Eray"><meta property="article:tag" content="生成函数"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://xxeray.github.io/post/generating-function-lecture-notes/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xxeray.github.io/post/generating-function-lecture-notes/","path":"post/generating-function-lecture-notes/","title":"生成函数讲稿"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>生成函数讲稿 | Eray's Blog</title><link rel="dns-prefetch" href="https://waline-1-g2268155.deta.app/"><script src="/js/md5.js"></script><script>!function(){for(var a="请输入密码：",a="请根据密码提示输入密码：\n密码：cw 的 OJ 的域名（11 个字符）";"4f5e127a697ffb644aaa1f46a1a32c97"!==md5(prompt(a,""));)alert("密码错误，请重新输入")}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Eray's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Eray's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">不管怎么样，明天又是新的一天。</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-user-friends fa-fw"></i>友链</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comment fa-fw"></i>留言板</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%8E%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86"><span class="nav-text">矩阵、行列式与矩阵树定理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">简单线性代数前置知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86"><span class="nav-text">矩阵树定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-ogf"><span class="nav-text">普通生成函数 OGF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5"><span class="nav-text">引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%BF%90%E7%AE%97"><span class="nav-text">简单运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="nav-text">习题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-text">拓展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E6%95%B0%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="nav-text">指数生成函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-1"><span class="nav-text">引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%BF%90%E7%AE%97-1"><span class="nav-text">简单运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%8D%B7%E7%A7%AFln-exp-%E4%B8%8E-egf"><span class="nav-text">“组合对象的拼接”——卷积，ln, exp 与 EGF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-2"><span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="nav-text">多项式全家桶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fft-%E4%B8%8E-ntt"><span class="nav-text">FFT 与 NTT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="nav-text">牛顿迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86"><span class="nav-text">多项式求逆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BC%80%E6%A0%B9"><span class="nav-text">多项式开根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%96%E6%A8%A1"><span class="nav-text">多项式取模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F-ln"><span class="nav-text">多项式 ln</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F-exp"><span class="nav-text">多项式 exp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-text">多项式快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-3"><span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E9%AB%98%E9%98%B6%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95"><span class="nav-text">更高阶的多项式算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB-fft"><span class="nav-text">分治 FFT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%B2%BBfft"><span class="nav-text">分治+FFT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8A%E5%9C%A8%E7%BA%BF%E5%8D%B7%E7%A7%AF"><span class="nav-text">半在线卷积</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF%E4%B8%8E-bluestein-%E7%AE%97%E6%B3%95"><span class="nav-text">循环卷积与 bluestein 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="nav-text">转置原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-2"><span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9"><span class="nav-text">内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-text">离散傅里叶变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%E5%8D%B7%E7%A7%AF"><span class="nav-text">加法卷积</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC"><span class="nav-text">多项式多点求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BF%AB%E9%80%9F%E6%8F%92%E5%80%BC"><span class="nav-text">多项式快速插值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC"><span class="nav-text">连续整数拉格朗日插值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-4"><span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E5%8D%87%E5%B9%82%E4%B8%8B%E9%99%8D%E5%B9%82%E4%B8%8E%E6%96%AF%E7%89%B9%E6%9E%97"><span class="nav-text">上升幂、下降幂与斯特林</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E7%9A%84%E4%B8%80%E8%A1%8C%E5%88%97"><span class="nav-text">快速计算第一、二类斯特林数的一行、列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-text">下降幂多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC%E5%92%8C%E6%8F%92%E5%80%BC"><span class="nav-text">下降幂多项式多点求值和插值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95"><span class="nav-text">下降幂多项式乘法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E6%99%AE%E9%80%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BA%92%E8%BD%AC"><span class="nav-text">下降幂多项式与普通多项式互转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="nav-text">例题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-5"><span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%BA%94%E7%94%A8"><span class="nav-text">其它应用</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Eray" src="/images/avatar/640x640.svg"><p class="site-author-name" itemprop="name">Eray</p><div class="site-description" itemprop="description">主要记录 OI 中的算法、题解、经验交流。</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/xxEray" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xxEray" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:xxeray@qq.com" title="邮箱 → mailto:xxeray@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>邮箱</a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://unpkg.com/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://xxeray.github.io/post/generating-function-lecture-notes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar/640x640.svg"><meta itemprop="name" content="Eray"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Eray's Blog"><meta itemprop="description" content="主要记录 OI 中的算法、题解、经验交流。"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="生成函数讲稿 | Eray's Blog"><meta itemprop="description" content="长文预警！"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">生成函数讲稿</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-05 08:35:42" itemprop="dateCreated datePublished" datetime="2023-12-05T08:35:42+08:00">2023-12-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/knowledge-point/" itemprop="url" rel="index"><span itemprop="name">知识点</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/post/generating-function-lecture-notes/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/post/generating-function-lecture-notes/" itemprop="commentCount"></span></a></span></div><div class="post-description">长文预警！</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="矩阵行列式与矩阵树定理">矩阵、行列式与矩阵树定理</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/ixRic/matrix-tree-theory">参考</a></p><h3 id="简单线性代数前置知识">简单线性代数前置知识</h3><ol type="1"><li>矩阵<ul><li>矩阵的定义：数表<ul><li><span class="math inline">\(n\)</span> 阶矩阵</li><li>全 0 矩阵：<span class="math inline">\(O\)</span></li><li><span class="math inline">\(n\)</span> 维行向量、<span class="math inline">\(n\)</span> 维列向量</li><li>主对角线、副对角线</li><li>上三角矩阵、下三角矩阵、对角矩阵<ul><li>数量矩阵（对角线全相同的对角矩阵）</li><li>单位矩阵（对角线为 <span class="math inline">\(1\)</span> 的数量矩阵，一般记作 <span class="math inline">\(E\)</span>）</li></ul></li></ul></li><li>矩阵加法、数乘、乘法<ul><li>乘法满足结合律</li></ul></li><li>矩阵的转置<ul><li><span class="math inline">\((A^T)^T=A\)</span></li><li><span class="math inline">\((A+B)^T=A^T+B^T\)</span></li><li><span class="math inline">\((AB)^T=B^TA^T\)</span></li><li><span class="math inline">\((kA)^T=kA^T\)</span></li></ul></li><li>分块矩阵<ul><li>定义</li><li>加减法、数乘</li><li>乘法</li><li>转置</li><li>分块对角矩阵</li></ul></li><li>行/列初等变换<ul><li>内容<ul><li>交换两行/列</li><li>将一行/列 <span class="math inline">\(\times k\)</span></li><li>将一行/列 <span class="math inline">\(\times k\)</span> 并加到另一行/列上</li></ul></li><li>都是可逆的</li><li>行/列阶梯形矩阵、行/列最简形矩阵</li><li>标准型矩阵</li><li><strong>Bonus:</strong> 自行了解齐次线性方程组与行/列最简形矩阵的关系</li><li>初等矩阵（P25）<ul><li>初等矩阵的逆</li><li>行初等变换相当于左乘初等矩阵，列初等变换相当于右乘初等矩阵</li></ul></li><li>行等价、列等价与等价</li></ul></li><li>逆矩阵<ul><li>定义：对于 <span class="math inline">\(A\)</span>，如果存在 <span class="math inline">\(AB=BA=E\)</span>，那么称 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的逆矩阵，记作 <span class="math inline">\(A^{-1}\)</span></li><li>性质<ul><li>若 <span class="math inline">\(A\)</span> 可逆，则 <span class="math inline">\(A^{-1}\)</span> 可逆，且 <span class="math inline">\((A^{-1})^{-1}=A\)</span></li><li>若 <span class="math inline">\(A_1,A_2,\cdots A_k\)</span> 都可逆，则 <span class="math inline">\(A_1A_2\cdots A_k\)</span> 也可逆，且 <span class="math inline">\((A_1A_2\cdots A+k)^{-1} = A_k^{-1} A_{k-1}^{-1} \cdots A_1^{-1}\)</span></li><li>若 <span class="math inline">\(A\)</span> 可逆，则 <span class="math inline">\(A^T\)</span> 也可逆，且 <span class="math inline">\((A^T)^{-1}=(A^{-1})^T\)</span></li><li>若 <span class="math inline">\(A\)</span> 可逆且 <span class="math inline">\(k\ne 0\)</span>，则 <span class="math inline">\(kA\)</span> 可逆，且 <span class="math inline">\((kA)^{-1} = k^{-1}A^{-1}\)</span></li></ul></li><li>（逆矩阵与初等变换的关系）下面三个命题互相等价：（P27）<ul><li><span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(A\)</span> 可逆</li><li><span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(A\)</span> 行（列）等价于 <span class="math inline">\(E\)</span></li><li>矩阵 <span class="math inline">\(A\)</span> 可表示为若干初等矩阵的乘积</li></ul></li></ul></li></ul></li><li>行列式<ul><li><span class="math inline">\(n\)</span> 阶行列式的定义<ul><li><span class="math inline">\(|A|=\det A=\sum_{\{p_i\}\in P}(-1)^{\tau(p)}a_{1p_1}a_{2p_2}\cdots a_{np_n}\)</span></li></ul></li><li>性质<ul><li>上三角矩阵、下三角矩阵和对角矩阵的行列式都等于对角线元素之积</li><li><span class="math inline">\(|A| = |A^T|\)</span></li><li>互换行列式的两行/列，行列式变号</li><li>如果行列式的两行/列相等，则行列式为 <span class="math inline">\(0\)</span></li><li>行列式的数乘（将某行/列乘上 <span class="math inline">\(k\)</span>，行列式的值也乘上 <span class="math inline">\(k\)</span>）</li><li><span class="math inline">\(|kA| = k^n|A|\)</span></li><li>如果行列式的某行/列全为 <span class="math inline">\(0\)</span>，则行列式为 <span class="math inline">\(0\)</span></li><li>如果行列式的某两行/列对应成比例，则行列式为 <span class="math inline">\(0\)</span></li><li>行列式的拆分定理（P43）</li><li>把行列式的某行（列）<span class="math inline">\(\times k\)</span> 加到另外一行（列），行列式不变</li></ul></li><li>行列式可逆的充要条件是 <span class="math inline">\(|A|\ne 0\)</span></li><li><span class="math inline">\(|AB| = |A|\cdot |B|\)</span>（P49）</li></ul></li><li>余子式、代数余子式（选学，不想听证明可以不管）<ul><li>定义<ul><li>余子式：<span class="math inline">\(M_{ij}\)</span>，表示将矩阵 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列去掉得到的矩阵的行列式</li><li>代数余子式：<span class="math inline">\(A_{ij}=(-1)^{i+j}M_{ij}\)</span></li></ul></li><li>矩阵按行、列展开（拉普拉斯展开）（P53）<ul><li><span class="math inline">\(\forall 1\le i\le n, |A|=\sum_{k=1}^n a_{ik} A_{ik}\)</span></li><li><span class="math inline">\(\forall 1\le j\le n, |B|=\sum_{k=1}^n a_{kj} A_{kj}\)</span></li><li>推论：<span class="math inline">\(\forall i\ne j, a_{i1}A_{j1}+a_{i2}A_{j2}+\cdots a_{in}A_{jn}=0\)</span>（P56）</li><li>推论：<span class="math inline">\(\forall i\ne j, a_{1i}A_{1j}+a_{2i}A_{2j}+\cdots a_{ni}A_{nj}=0\)</span>（P56）</li></ul></li></ul></li></ol><h3 id="矩阵树定理">矩阵树定理</h3><ol type="1"><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/SalomeJLQ/binet-cauchy-gong-shi-ji-ji-ying-yong">Binet-Cauchy 定理</a></li><li>基尔霍夫矩阵</li><li>引理</li><li>证明</li></ol><p><strong>Bonus:</strong> Cayley 公式</p><h3 id="习题">习题</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3317">P3317 [SDOI2014] 重建</a><br><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/917/D">Stranger Trees</a><br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4336">P4336 [SHOI2016] 黑暗前的幻想乡</a></p><hr><h2 id="普通生成函数-ogf">普通生成函数 OGF</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan">参考</a></p><h3 id="引入">引入</h3><ol type="1"><li>定义<ul><li>ordinary generating function</li><li>数乘、卷积定义</li></ul></li><li>求 Fibonacci</li></ol><h3 id="简单运算">简单运算</h3><p>首先有一个经典的生成函数：</p><p><span class="math inline">\(\langle 1, 1, 1, \cdots \rangle {\overset{\mathbf{OGF}}{\longrightarrow}} \dfrac{1}{1 - x}\)</span></p><p>然后有一些变换：</p><ol type="1"><li>平移<ul><li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle \longrightarrow \langle \underbrace{0, 0, \cdots, 0}_{c\ 个}, a_0, a_1, a_2, \cdots \rangle\)</span></li><li><span class="math inline">\(F(x) \to x^c F(x)\)</span></li></ul></li><li>拉伸<ul><li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle \longrightarrow \langle a_0, \underbrace{0, 0, \cdots, 0}_{c - 1\ 个}, a_1, \underbrace{0, 0, \cdots, 0}_{c - 1\ 个}, \cdots \rangle\)</span></li><li><span class="math inline">\(F(x) \to F(x^c)\)</span></li></ul></li><li>扩倍（数乘）<ul><li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle \longrightarrow \langle ka_0, ka_1, ka_2, \cdots \rangle\)</span></li><li><span class="math inline">\(F(x) \to kF(x)\)</span></li></ul></li><li>乘等比数列<ul><li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle \longrightarrow \langle a_0c^0, a_1c^1, a_2c^2, \cdots \rangle\)</span></li><li><span class="math inline">\(F(x) \to F(cx)\)</span></li></ul></li><li>求导<ul><li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle \longrightarrow \langle a_1, 2a_2, 3a_3, \cdots \rangle\)</span></li><li><span class="math inline">\(F(x) \to F&#39;(x)\)</span></li><li>更进一步的：<ul><li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle \longrightarrow \langle c^{\underline{c}}\times a_c, (c+1)^{\underline{c}}\times a_{c + 1}, (c+2)^{\underline{c}}\times a_{c + 2}, \cdots \rangle = \sum\limits_{i=c}i^{\underline{c}}a_i x^{i-c}\)</span></li></ul></li></ul></li></ol><p>另外还有一些更加困难一点的东西：</p><p>（前置：二项式定理，广义二项式定理，经典微积分）</p><ul><li><span class="math inline">\(\sum\limits_{i=0}\dbinom{n}{i}x^i = (x+1)^n\)</span></li><li><span class="math inline">\(\sum\limits_{i=0}(-1)^i\dbinom{n}{i}x^i = (1-x)^n\)</span></li><li><span class="math inline">\(\sum\limits_{i=0}\dbinom{n+i}{i}x^i = \dfrac{1}{(1-x)^{n+1}}\)</span></li><li><span class="math inline">\(\sum\limits_{i=1}\dfrac{x^i}{i} = -\ln (1-x)\)</span></li></ul><h3 id="例题">例题</h3><ol type="1"><li><span class="math inline">\(a_n = 8a_{n-1} + 10^{n - 1}\)</span>，<span class="math inline">\(a_1=9\)</span>，求 <span class="math inline">\(a\)</span> 的通项公式。</li><li>生成函数推 Catalan 数 <span class="math inline">\(h_n (0\le n\le n)\)</span>：</li></ol><p><span class="math display">\[ h_n = \begin{cases} \sum_{i=0}^{n-1} h_i h_{n-i-1} &amp;(n\ge 2)\\ 1 &amp;(n\in [0, 1]) \end{cases} \]</span></p><ol start="3" type="1"><li>请尝试用生成函数方法证明下面两个问题的答案相等：（<strong>Bonus:</strong> 其实这个可以建立双射，<del>留作思考题</del>）<ul><li>把 <span class="math inline">\(n\)</span> 分为若干份，每份为正奇数的方案数</li><li>把 <span class="math inline">\(n\)</span> 分为若干个不同正整数之和的方案数</li></ul></li><li><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1821/F">CF1821F Timber</a><ul><li>比较入门的题</li></ul></li></ol><h3 id="习题-1">习题</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3978">P3978 [TJOI2015] 概率论</a><br><a target="_blank" rel="noopener" href="https://hydro.ac/d/bzoj/p/2173">BZOJ 2173 「国家集训队」整数的lqp拆分</a><br><a target="_blank" rel="noopener" href="https://hydro.ac/d/bzoj/p/3027">BZOJ 3027 [CEOI2004]Sweet</a></p><h3 id="拓展">拓展</h3><p>自行了解：</p><ul><li>计算 <span class="math inline">\(\sum\limits_{k\ge 0}\dbinom{k}{n-k}\)</span> 的封闭形式。（Snake Oil Trick，<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/77468">解法</a> 直接翻到 Snake Oil Trick 那里）</li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/456690/wu-bian-xing-shuo-ding-li">五边形数定理</a></li></ul><hr><h2 id="指数生成函数">指数生成函数</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan">参考</a></p><h3 id="引入-1">引入</h3><ol type="1"><li>定义<ul><li>exponential generating function</li><li>数乘、卷积定义</li></ul></li></ol><h3 id="简单运算-1">简单运算</h3><ol type="1"><li><span class="math inline">\(\langle 1, 1, 1, \cdots \rangle {\overset{\mathbf{EGF}}{\longrightarrow}} e^x\)</span><ul><li>泰勒展开</li></ul></li><li><span class="math inline">\(\langle 1, -1, 1, -1, 1, \cdots \rangle {\overset{\mathbf{EGF}}{\longrightarrow}} e^{-x}\)</span></li><li><span class="math inline">\(\langle c^0, c^1, c^2, \cdots \rangle {\overset{\mathbf{EGF}}{\longrightarrow}} e^{cx}\)</span></li><li><span class="math inline">\(\langle 1, 0, 1, 0, 1, 0, \cdots \rangle {\overset{\mathbf{EGF}}{\longrightarrow}} \dfrac{e^x+e^{-x}}{2}\)</span></li><li><span class="math inline">\(\langle 1, \alpha, \alpha^{\underline{1}}, \alpha^{\underline{2}}, \alpha^{\underline{3}}, \cdots \rangle {\overset{\mathbf{EGF}}{\longrightarrow}} (1 + x)^\alpha\)</span><ul><li><span class="math inline">\(\alpha\)</span> 可以为实数</li><li>广义二项式定理</li></ul></li></ol><h3 id="组合对象的拼接卷积ln-exp-与-egf">“组合对象的拼接”——卷积，ln, exp 与 EGF</h3><ol type="1"><li>EGF 卷积——组合对象的“归并”<ul><li><strong>OGF:</strong> <code>&#123;AAA&#125;×&#123;BBB&#125;=&#123;AAABBB&#125;</code>（集合的合并）</li><li><strong>EGF:</strong> <code>(AAA)×(BBB)=&#123;(AAABBB),(AABBAB),(ABBAAB),(BBAAAB),……&#125;</code>共 <span class="math inline">\(\binom{3+4}{3}\)</span> 种（序列的归并）</li></ul></li><li>对 EGF 进行 <span class="math inline">\(\exp\)</span>——组合对象的“生成集合”<ul><li><span class="math inline">\(\exp F(x) = \sum\limits_{i=0}\dfrac{F^i(x)}{i!}\)</span></li><li>将 <span class="math inline">\(F(x)\)</span> 看成一个“元素”，对若干个“元素”的有标号集合计数<ul><li>有标号集合的“元素”之间无序（因为除以了阶乘），“元素”内部的东西是 <strong>有编号</strong> 的（因为需要归并）</li><li>如果长度为 <span class="math inline">\(n\)</span> 的置换环个数为 <span class="math inline">\(f(n)\)</span>，设其 EGF 为 <span class="math inline">\(F(x)\)</span>，则长度为 <span class="math inline">\(n\)</span> 的置换环集合（即长度为 <span class="math inline">\(n\)</span> 的排列）的个数为 <span class="math inline">\([\frac{x^n}{n!}]\exp F(x)\)</span></li><li>如果 <strong>有标号</strong> 生成树的 EGF 为 <span class="math inline">\(F(x)\)</span>，则 <strong>有标号</strong> 森林的 EGF 为 <span class="math inline">\(\exp F(x)\)</span></li></ul></li></ul></li></ol><h3 id="例题-1">例题</h3><ol type="1"><li>求第一、二类斯特林数的一列。（需要多项式快速幂）</li><li>有标号连通无向图计数<ul><li>设有标号简单无向图的 EGF 为 <span class="math inline">\(F(x) = \sum\limits_{i=0} \dfrac{2^{i(i-1)/2}}{i!}x^i\)</span>，则答案为 <span class="math inline">\(\ln F(x)\)</span>。</li></ul></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7364">P7364 有标号二分图计数</a><ul><li>考虑一张连通二分图的黑白染色方案为 <span class="math inline">\(2\)</span></li><li>我们只需要枚举黑点集合然后连边，就能得出任意二分图染色数</li><li>然后 <span class="math inline">\(\ln\)</span> 就是连通二分图染色数</li><li>然后除以 <span class="math inline">\(2\)</span> 就能算出连通二分图个数</li><li>最后再 <span class="math inline">\(\exp\)</span> 回去就是任意二分图个数了</li><li>发现设任意二分图染色方案的 EGF 为 <span class="math inline">\(F(x)\)</span>，那么答案是 <span class="math inline">\(\exp(\frac 12 \ln F(x))\)</span>，容易发现这就等于 <span class="math inline">\(\sqrt{F(x)}\)</span>，可以减小代码长度和常数。</li></ul></li><li><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc231/tasks/abc231_g">ABC231G Balls in Boxes</a></li></ol><h3 id="习题-2">习题</h3><ol type="1"><li><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3734">POJ3734 Blocks</a>（无需 FFT/NTT）</li><li><a target="_blank" rel="noopener" href="http://poj.org/problem?id=1322">POJ1322 Chocolate</a>（无需 FFT/NTT）</li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4389">P4389 付公主的背包</a>（需要 FFT/NTT）</li></ol><hr><h2 id="多项式全家桶">多项式全家桶</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong">参考</a></p><p>题外话：我有一份封装模板，需要的可以找我要，<del>我感觉跑得还是挺快的</del>。</p><h3 id="fft-与-ntt">FFT 与 NTT</h3><p>移步<a href="/post/fast-fourier-transform">我的博客</a>。</p><p><strong>Bonus:</strong> DIF 与 DIT，可以参考<a target="_blank" rel="noopener" href="https://charleswu.site/archives/3065">这个</a>。</p><p><strong>例题：</strong> 求第二类斯特林数的一行。</p><h3 id="牛顿迭代法">牛顿迭代法</h3><p>对于函数 <span class="math inline">\(F(x)\)</span>，如果有 <span class="math inline">\(G(F(x)) = 0\)</span>，并且我们已经求出 <span class="math inline">\(G(F_*(x)) \equiv 0 \pmod{x^{\frac n2}}\)</span>，那么我们就可以通过牛顿迭代求出 <span class="math inline">\(F \bmod x^n\)</span>：</p><p><span class="math display">\[ F(x) \equiv F_*(x) - \frac{G(F_*(x))}{G&#39;(F_*(x))} \pmod{x^{n}} \]</span></p><p>注意这里的 <span class="math inline">\(G&#39;(F_*(x))\)</span> 是以 <span class="math inline">\(F(x)\)</span> 为主元的，即 <span class="math inline">\(\dfrac{\operatorname{d} G(F_*(x))}{\operatorname{d} F_*(x)}\)</span>。</p><p>一个需要注意的地方是 <span class="math inline">\(\dfrac{1}{G&#39;(F_*(x))}\)</span> 的精度只需要达到 <span class="math inline">\(x^{\frac n2}\)</span>，因为 <span class="math inline">\(G(F_*(x))\)</span> 的前 <span class="math inline">\(\frac n2\)</span> 项必然为 <span class="math inline">\(0\)</span>（定义）。</p><p>证明：</p><p>首先显然有 <span class="math inline">\(F(x) \equiv F_*(x) \pmod{x^{\frac n2}}\)</span>。我们把 <span class="math inline">\(G(F(x))\)</span> 在 <span class="math inline">\(F_*(x)\)</span> 处泰勒展开：</p><p><span class="math display">\[ G(F(x)) = G(F_*(x)) + \frac{G&#39;(F_*(x))}{1!}(F(x) - F_*(x)) + \frac{G&#39;&#39;(F_*(x))}{2!}(F(x) - F_*(x))^2 + \cdots \]</span></p><p>看起来这个式子更加复杂了，但是我们发现 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(F_*(x)\)</span> 的前 <span class="math inline">\(\frac n2\)</span> 项都相同，所以 <span class="math inline">\(F(x) - F_*(x)\)</span> 的后 <span class="math inline">\(\frac n2\)</span> 项为 <span class="math inline">\(0\)</span>，进而我们可以得到 <span class="math inline">\((F(x) - F_*(x))^c \bmod x^n = 0 (c\ge 2)\)</span>。所以我们可以把上面的式子写为：</p><p><span class="math display">\[ \begin{aligned} G(F(x)) &amp;\equiv G(F_*(x)) + G&#39;(F_*(x))(F(x) - F_*(x)) &amp;\pmod{x^n}\\ G&#39;(F_*(x))F(x) &amp;\equiv G(F(x)) - G(F_*(x)) + G&#39;(F_*(x))F_*(x) &amp;\pmod{x^n}\\ F(x) &amp;\equiv \frac{G(F(x)) - G(F_*(x)) + G&#39;(F_*(x))F_*(x)}{G&#39;(F_*(x))} &amp;\pmod{x^n}\\ &amp;\equiv F_*(x) + \frac{G(F(x)) - G(F_*(x))}{G&#39;(F_*(x))} &amp;\pmod{x^n}\\ &amp;\equiv F_*(x) - \frac{G(F_*(x))}{G&#39;(F_*(x))} &amp;\pmod{x^n} \end{aligned} \]</span></p><h3 id="多项式求逆">多项式求逆</h3><p>下面讲的东西基本上都有两种推法，第一种是直接推，第二种是用牛顿迭代。下面只讲牛顿迭代的方法。</p><p>记 <span class="math inline">\(F(x)\)</span> 的逆为 <span class="math inline">\(F^{-1}(x)\)</span>，我们令 <span class="math inline">\(G(H(x)) = F(x)H(x) - 1\)</span>，那么 <span class="math inline">\(G(F^{-1}(x))=0\)</span>。套用牛顿迭代的公式：</p><p><span class="math display">\[ \begin{aligned} F^{-1}(x) &amp;\equiv F^{-1}_*(x) - \frac{G(F^{-1}_*(x))}{G&#39;(F^{-1}_*(x))} &amp;\pmod{x^n}\\ &amp;\equiv F^{-1}_*(x) - \frac{F(x)F^{-1}_*(x) - 1}{F(x)} &amp;\pmod{x^n}\\ \end{aligned} \]</span></p><p>注意到 <span class="math inline">\(\dfrac{1}{F(x)}\)</span> 的精度只需要 <span class="math inline">\(x^{\frac n2}\)</span>，所以可以直接用 <span class="math inline">\(F^{-1}_*(x)\)</span>。最终的式子是</p><p><span class="math display">\[ \begin{aligned} F^{-1}(x) &amp;\equiv F^{-1}_*(x) - F^{-1}_*(x)(F(x)F^{-1}_*(x) - 1) &amp;\pmod{x^n}\\ &amp;\equiv F^{-1}_*(x)(2 - F(x)F^{-1}_*(x)) &amp;\pmod{x^n}\\ \end{aligned} \]</span></p><p>直接倍增+NTT 计算即可。复杂度 <span class="math inline">\(T(n)=T(\frac n2) + O(n\log n) = O(n\log n)\)</span>。</p><h3 id="多项式开根">多项式开根</h3><p>令 <span class="math inline">\(G(H(x)) = H^2(x) - F(x)\)</span>，记 <span class="math inline">\(H(x) = \sqrt{F(x)}\)</span>，则 <span class="math inline">\(G(H(x)) = 0\)</span>。</p><p><span class="math display">\[ \begin{aligned} H(x) &amp;\equiv H_*(x) - \frac{G(H_*(x))}{G&#39;(H_*(x))} &amp;\pmod{x^n}\\ &amp;\equiv H_*(x) - \frac{H_*^2(x) - F(x)}{2H_*(x)} &amp;\pmod{x^n}\\ &amp;\equiv \frac{H_*^2(x)+F(x)}{2H_*(x)} &amp;\pmod{x^n} \end{aligned} \]</span></p><p>直接做即可。</p><p>需要注意的是，<span class="math inline">\(\sqrt{F_0}\)</span> 需要求二次剩余。不过一般来说，由于生成函数是有实际意义的，所以基本上都有 <span class="math inline">\(F_0=1\)</span>，此时不需要二次剩余。（我的板子没写二次剩余，需要保证 <span class="math inline">\(F_0=1\)</span>）</p><h3 id="多项式取模">多项式取模</h3><p>这个比较简单。</p><p>对于 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(m\)</span> 次多项式 <span class="math inline">\(G(x)\)</span>，求商（<span class="math inline">\(n - m\)</span> 次）多项式 <span class="math inline">\(Q(x)\)</span> 和余数（至多 <span class="math inline">\(m - 1\)</span> 次）多项式 <span class="math inline">\(R(x)\)</span>。注意这里不是模 <span class="math inline">\(x^n\)</span> 意义下的，所以才会出现余数，和上面的多项式求逆不同。</p><p>不难得到 <span class="math inline">\(F(x) = Q(x)\times G(x) + R(x)\)</span>。</p><p>考虑用取模把余数去掉。但是由于余数必然是较低项不好去除，所以我们把所有多项式“翻转”。</p><p>具体地，对于 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(F\)</span>，定义 <span class="math inline">\(F^T(x)=x^nF(x^{-1})\)</span>，手玩发现 <span class="math inline">\(F^T(x)\)</span> 就是将 <span class="math inline">\(F(x)\)</span> 所有系数翻转得到的多项式。</p><p><span class="math display">\[ \begin{aligned} F(x) &amp;= Q(x)G(x) + R(x)&amp;\\ F(x^{-1}) &amp;= Q(x^{-1})G(x^{-1}) + R(x^{-1})&amp;\\ x^nF(x^{-1}) &amp;= x^n Q(x^{-1})G(x^{-1}) + x^n R(x^{-1})&amp;\\ F^T(x) &amp;= Q^T(x) G^T(x) + x^{n - m + 1}R^T(x)&amp;\\ F^T(x) &amp;\equiv Q^T(x) G^T(x) &amp;\pmod{x^{n - m + 1}}\\ Q^T(x) &amp;\equiv \frac{F^T(x)}{G^T(x)} &amp;\pmod{x^{n - m + 1}}\\ \end{aligned} \]</span></p><p>这样就可以用多项式求逆算出 <span class="math inline">\(Q(x)\)</span>，然后容易算出 <span class="math inline">\(R(x)\)</span>。</p><p><strong>Bonus:</strong> 常系数齐次线性递推（可以参考 <a target="_blank" rel="noopener" href="https://www.luogu.com/article/1s01et5m">这个</a>）</p><h3 id="多项式-ln">多项式 ln</h3><p>应该保证 <span class="math inline">\([x^0]F(x) = 1\)</span>。</p><p>这个很简单：<span class="math inline">\((\ln F(x))&#39; = \frac{F&#39;(x)}{F(x)}\)</span>，所以 <span class="math inline">\(\ln F(x) = \int \frac{F&#39;(x)}{F(x)}\)</span></p><p>这里说一下 <span class="math inline">\(\ln\)</span> 和 <span class="math inline">\(\exp\)</span> 的定义：</p><p><span class="math display">\[ \ln F(x) = -\sum_{i=0}\frac{(1-F(x))^i}{i} \]</span></p><p><span class="math display">\[ \exp F(x) = \sum_{i=0}\frac{F(x)^i}{i!} \]</span></p><p>这个是麦克劳林级数的定义，这个定义只用到了加法和乘法，所以可以对 <span class="math inline">\(x^n\)</span> 取模而不会出错。</p><p>经典的性质在这个定义下仍然成立，如 <span class="math inline">\(\exp\)</span>, <span class="math inline">\(\ln\)</span> 互为逆运算，<span class="math inline">\(\exp(\ln F(x)+\ln G(x))=F(x)\times G(x)\)</span> 等。</p><h3 id="多项式-exp">多项式 exp</h3><p>应该保证 <span class="math inline">\([x^0]F(x) = 0\)</span>。</p><p>由于 <span class="math inline">\(\exp\)</span> 与 <span class="math inline">\(\ln\)</span> 是逆运算，所以可以牛顿迭代：</p><p>令 <span class="math inline">\(G(H(x)) = \ln H(x) - F(x)\)</span>，记 <span class="math inline">\(H(x) = \exp F(x)\)</span>，则 <span class="math inline">\(G(H(x)) = 0\)</span>。</p><p><span class="math display">\[ \begin{aligned} H(x) &amp;\equiv H_*(x) - \frac{G(H_*(x))}{G&#39;(H_*(x))} &amp;\pmod{x^n}\\ &amp;\equiv H_*(x) - \frac{\ln H_*(x) - F(x)}{H^{-1}_*(x)} &amp;\pmod{x^n}\\ &amp;\equiv H_*(x) - (\ln H_*(x) - F(x))H_*(x) &amp;\pmod{x^n}\\ &amp;\equiv H_*(x)(1 - \ln H_*(x) + F(x)) &amp;\pmod{x^n}\\ \end{aligned} \]</span></p><p>但是这个做法既需要使用 <span class="math inline">\(\ln\)</span>，而且常数还大，根本没有性价比。所以还有一个分治 NTT 的 <span class="math inline">\(O(n\log^2 n)\)</span> 的做法：</p><p>设 <span class="math inline">\(G(x) = \exp F(x)\)</span>，两边同时求导可得 <span class="math inline">\(G&#39;(x)=G(x)F&#39;(x)\)</span>。</p><p>对两边同时提取 <span class="math inline">\(x^n\)</span> 系数，则 <span class="math inline">\((n+1)G_{n+1}=\sum_{i=0}^n (i+1)F_{i+1}G_{n-i}\)</span>，也就是 <span class="math inline">\(G_n = \frac 1n \sum_{i=1}^n iF_i G_{n-i}\)</span>。然后就可以分治 NTT 了。</p><h3 id="多项式快速幂">多项式快速幂</h3><p>很简单。</p><p><span class="math inline">\(F^k(x) \equiv \exp(k\times \ln F(x)) \pmod{x^n}\)</span></p><p><strong>应用：</strong> 求第一、二类斯特林数的一列。</p><h3 id="例题-2">例题</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3803">模板题</a></p><ol type="1"><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3338">P3338 [ZJOI2014] 力</a><ul><li>直接做</li></ul></li><li><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/JAG2013Spring/tasks/icpc2013spring_f">Point Distance</a><ul><li>考虑计算出横纵坐标距离分别为 <span class="math inline">\((x, y)\)</span> 的点对个数，这是一个“二维差卷积”</li><li>差卷积可以通过翻转下标解决</li><li>二维的话可以用经典做法：令 <span class="math inline">\(g_{iT+j}=f_{i,j} (T&gt;2n)\)</span> 并对 <span class="math inline">\(g\)</span> 做卷积，得到的序列再转回去就是二维 FFT 的答案了。</li></ul></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP8372">SPOJ8372 TSUM - Triple Sums</a><ul><li>容斥+NTT</li></ul></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4841">P4841 [集训队作业2013] 城市规划</a><ul><li>之前有 <span class="math inline">\(\ln\)</span> 的做法，不过这道题可以用多项式求逆做</li></ul></li></ol><h3 id="习题-3">习题</h3><ol type="1"><li><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=4609">HDU-4609 3-idiots</a></li><li><a target="_blank" rel="noopener" href="https://hydro.ac/d/bzoj/p/3771">BZOJ3771 Triple</a></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA12298">UVA12298 Super Poker II</a></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3723">P3723 [AH2017/HNOI2017] 礼物</a></li><li><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/623/E">CF623E Transforming Sequence</a>（较难）</li></ol><hr><h2 id="更高阶的多项式算法">更高阶的多项式算法</h2><h3 id="分治-fft">分治 FFT</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/ban-zai-xian-juan-ji-xiao-ji">参考</a></p><h4 id="分治fft">分治+FFT</h4><p>本质上这一部分应该叫 <strong>分治+FFT</strong> 或 <strong>分治套FFT</strong> 而不是 <strong>分治FFT</strong>。</p><p>经典运用是求形如 <span class="math inline">\(F(1, n) = \prod_{i=1}^n (1+a_ix)\)</span> 的多项式。</p><p>如果直接计算的话，由于 <span class="math inline">\(n\)</span> 阶多项式和 <span class="math inline">\(m\)</span> 阶多项式相乘的复杂度是 <span class="math inline">\(O((n+m)\log(n+m))\)</span>（FFT）或 <span class="math inline">\(O(nm)\)</span> 暴力，对于 <span class="math inline">\(m=2\)</span> 来说至少也是 <span class="math inline">\(O(n)\)</span> 的。所以直接计算是 <span class="math inline">\(1+2+\cdots+n=O(n^2)\)</span> 的。</p><p>考虑 <span class="math inline">\((n+m)\log (n+m)\)</span> 在 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 接近时会比较赚，所以考虑 cdq 分治。求 <span class="math inline">\(F(l, r)\)</span> 时先求 <span class="math inline">\(F(l, mid)\)</span> 和 <span class="math inline">\(F(mid + 1, r)\)</span> 再乘起来，这样复杂度是 <span class="math inline">\(T(n) = 2T(\frac n2) + O(n \log n) = O(n\log^2 n)\)</span> 的。</p><h4 id="半在线卷积">半在线卷积</h4><p>考虑求解形如 <span class="math inline">\(F(x) = F(x)G(x) + H(x)\)</span> 的多项式，其中 <span class="math inline">\(G(0) = 0\)</span>，那么可以用分治 FFT 解决。（这种情况有时也可以解方程然后多项式求逆）</p><p>做法是考虑 cdq。求 <span class="math inline">\(f_{l..r}\)</span> 时先求出 <span class="math inline">\(f_{l..mid}\)</span>，然后将 <span class="math inline">\(f_{l..mid}\)</span> 到 <span class="math inline">\(f_{mid+1,r}\)</span> 的贡献用卷积求出来，然后再求 <span class="math inline">\(f_{mid+1..r}\)</span>。</p><p>对于 <span class="math inline">\(F(x) = F(x)F(x) + H(x)\)</span> 之类的多项式也可以做，不过有点区别。具体来说我们将 <span class="math inline">\(f_{l..mid}\times f_{1..mid}\)</span> 对 <span class="math inline">\(f_{mid+1..r}\)</span> 的贡献求出后再递归 <span class="math inline">\(f_{mid+1..r}\)</span>。</p><h3 id="循环卷积与-bluestein-算法">循环卷积与 bluestein 算法</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/GreenDuck/p/14427244.html">参考</a></p><p>bluestein 算法又称 <a target="_blank" rel="noopener" href="https://oi-wiki.org/math/poly/czt/">Chirp-Z 变换</a>。</p><p>其实在 NTT 中，如果我们取恰好 <span class="math inline">\(n\)</span> 个点值而不是至少 <span class="math inline">\(2n\)</span> 个点值，那么求出来的就是循环卷积。不过 <span class="math inline">\(n\)</span> 有可能不是 <span class="math inline">\(2\)</span> 的幂次，所以需要 bluestein 来计算任意个数个点值。</p><p>首先带入点值 <span class="math inline">\(\omega_n^i\)</span>：<span class="math inline">\(F_k = \sum_{i=0}^n a_i \omega_n^{ik}\)</span>。</p><p>然后发现 <span class="math inline">\(ik = \binom{i+k}{2} - \binom{i}{2} - \binom{k}{2}\)</span>（考虑组合意义，即有两个盒子，每个盒子分别有 <span class="math inline">\(i\)</span> 个球和 <span class="math inline">\(k\)</span> 个球，求有多少种拿出两个球且分别属于两个盒子的方法），于是上式可以化为：</p><p><span class="math display">\[ \begin{aligned} F_k &amp;=\sum_{i=0}^n a_i \omega_n^{\binom{i+k}{2}-\binom{i}{2}-\binom{k}{2}}\\ &amp;=\omega_n^{\binom{k}{2}} \sum_{i=0}^n a_i \omega_n^{-\binom{i}{2}}\cdot \omega_n^\binom{i+k}{2}\\ &amp;=\omega_n^{\binom{k}{2}} \sum_i A_{-i}B_{i+k}\\ \end{aligned} \]</span></p><p>其中 <span class="math inline">\(A_i = a_{-i}\omega_n^{-\binom{-i}{2}}\)</span>，<span class="math inline">\(B_i=\omega_n^\binom{i}{2}\)</span>。</p><p>然后就可以用卷积计算了。</p><p>裸题：<a target="_blank" rel="noopener" href="http://poj.org/problem?id=2821">POJ2821 TN's Kingdom III - Assassination</a></p><h3 id="转置原理">转置原理</h3><p><strong>以下仅供了解。</strong></p><h4 id="引入-2">引入</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/wangrx/tellegen-s--principle">参考1</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/zhuai-zhi-yuan-li-xiao-ji">参考2</a></p><p>给定过程矩阵 <span class="math inline">\(A\)</span> 以及输入向量 <span class="math inline">\(a\)</span>，求解输出向量 <span class="math inline">\(b=Aa\)</span> 的算法，被称为线性算法。（又称线性变换）</p><p>对于一个线性算法 <span class="math inline">\(b=Aa\)</span>，一定有另外一个类似的算法 <span class="math inline">\(b=A^Ta\)</span>，我们称这两个算法 <strong>互为转置</strong>。</p><h4 id="内容">内容</h4><p><strong>转置原理</strong> 给出了两个互为转置的算法之间互相转化的方法。</p><p>对于一个可逆矩阵 <span class="math inline">\(A\)</span>，我们可以讲它分解为若干初等矩阵的乘积 <span class="math inline">\(E_1E_2\cdots E_m\)</span>，那么 <span class="math inline">\(b=E_1E_2\cdots E_ma\)</span>。那么它的转置问题就是 <span class="math inline">\(b=A^Ta=E_m^TE_{m-1}^T\cdots E_1^Ta\)</span>。</p><p>也就是说，对于一个线性算法，我们原来是不断将它左乘初等矩阵，那么它的转置问题就是不断地（倒序）左乘上初等矩阵的转置。</p><p>然后考虑一个初等矩阵和它转置之间的关系：</p><ul><li>对于一个交换第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 行的矩阵，它的转置和它是一样的</li><li>对于一个把第 <span class="math inline">\(i\)</span> 行乘 <span class="math inline">\(v\)</span> 加到第 <span class="math inline">\(j\)</span> 行的矩阵，它的转置变成了把第 <span class="math inline">\(j\)</span> 行乘 <span class="math inline">\(v\)</span> 加到第 <span class="math inline">\(i\)</span> 行。</li></ul><p>所以我们只需要按照上面的规则将原做法进行转置，就可以得到转置问题的解法了。</p><p>当然，在实际操作中，为了方便，我们不会真的以初等矩阵为单位来拆分并转置，而是以整合后的矩阵为单位描述算法。</p><h4 id="应用">应用</h4><h5 id="离散傅里叶变换">离散傅里叶变换</h5><p>观察 DFT 的矩阵：</p><p><span class="math display">\[ A = [\omega_n^{ij}]_{0\le i,j\le n} = \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\ 1 &amp; \omega_n &amp; \omega_n^2 &amp; \cdots &amp; \omega_n^{n - 1}\\ 1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \cdots &amp; \omega_n^{2(n - 1)}\\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ 1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \cdots &amp; \omega_n^{(n-1)(n-1)} \end{bmatrix} \]</span></p><p>我们发现它是关于主对角线对称的，也就是说 <span class="math inline">\(A=A^T\)</span>。所以 DFT 的转置算法就是它本身。</p><h5 id="加法卷积">加法卷积</h5><p>对于多项式 <span class="math inline">\(F,G,H\)</span> 的乘法 <span class="math inline">\(H=F\times G\)</span>，如果我们把 <span class="math inline">\(F\)</span> 看成输入，<span class="math inline">\(G\)</span> 看成常量，<span class="math inline">\(H\)</span> 看成输出，则有：</p><p><span class="math display">\[ H_k = \sum_{i=0}^k G_i F_{k-i} \]</span></p><p>于是我们可以得到 <span class="math inline">\(b=Aa\)</span> 中 <span class="math inline">\(a=\begin{bmatrix}F_0\\ F_1\\ \vdots\\ F_n\end{bmatrix}\)</span>，<span class="math inline">\(b=\begin{bmatrix}H_0\\ H_1\\ \vdots\\ H_n\end{bmatrix}\)</span>，</p><p><span class="math display">\[ A= \begin{bmatrix} G_0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0\\ G_1 &amp; G_0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0\\ G_2 &amp; G_1 &amp; G_0 &amp; \cdots &amp; 0 &amp; 0\\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ G_{n-1} &amp; G_{n-2} &amp; G_{n-3} &amp; \cdots &amp; G_0 &amp; 0\\ G_n &amp; G_{n-1} &amp; G_{n-2} &amp; \cdots &amp; G_1 &amp; G_0 \end{bmatrix} \]</span></p><p>也即 <span class="math inline">\(A_{ij} = [i\ge j]G_{i-j}\)</span>。</p><p>于是 <span class="math inline">\(A^T_{i,j} = [i\le j]G_{j-i}\)</span>，<span class="math inline">\((A^Ta)_i=\sum_{j=0}^nA_{i,j}b_j=\sum_{j=i}^nG_{j-i}F_j=\sum_{j=0}^{n-i}G_jF_{j+i}\)</span></p><p>于是加法卷积的转置问题是减法卷积，即差卷积。（下面用 <span class="math inline">\(\times^T\)</span> 表示差卷积）</p><h5 id="多项式多点求值">多项式多点求值</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/vocalise/multipoint-interpolation-vandermonde">参考</a></p><p>考虑多项式 <span class="math inline">\(F\)</span> 和序列 <span class="math inline">\(X\)</span>，求出答案序列 <span class="math inline">\(Y_i=F(X_i)\)</span>。那么：</p><p><span class="math display">\[ Y_k = F(X_k) = \sum_{i}F_iX_k^i \]</span></p><p>于是 <span class="math inline">\(A_{ij} = X_i^j\)</span>，所以 <span class="math inline">\(A^T_{ij} = X_j^i\)</span>。</p><p>那么转置问题就是 <span class="math inline">\(Y_k = \sum_{i}F_iX_i^k\)</span>，也就是求：</p><p><span class="math display">\[ \begin{aligned} G(x) &amp;=\sum_{k=0}^nY_kx^k\\ &amp;=\sum_{k=0}^nx^k\sum_{i=0}^nF_iX_i^k\\ &amp;=\sum_{i=0}^nF_i\sum_{k=0}^nx^kX_i^k\\ &amp;=\sum_{i=0}^n\frac{F_i}{1-xX_i} \end{aligned} \]</span></p><p>这是一个经典的分治 FFT 问题。为了下面讨论方便，我们把流程形式化地写出来：</p><p>对于区间 <span class="math inline">\([l, r)\)</span>，我们维护分母 <span class="math inline">\(Q_{[l, r)} = \prod\limits_{i=l}^{r-1}(1-xX_i)\)</span> 和分子 <span class="math inline">\(\sum\limits_{k=l}^{r-1} F_k \prod\limits_{\substack{i\in [l, r)\\i\ne k}}(1-xX_i)\)</span>，那么有：</p><p><span class="math display">\[ \begin{aligned} Q_{[l, r)} &amp;= Q_{[l, m)}\times Q_{[m, r)}\\ P_{[l, r)} &amp;= P_{[l, m)}\times Q_{[m, r)} + P_{[m, r)}\times Q_{[l, m)} \end{aligned} \]</span></p><p>最终答案就是 <span class="math inline">\(F = P_{[0, n)}\times \frac{1}{Q_{[0, n)}}\)</span>。</p><p>于是我们可以设计出转置问题的算法：</p><ol type="1"><li><span class="math inline">\(Q\)</span> 与输入无关，故视为常数，先预处理</li><li>求出 <span class="math inline">\(P_{[0, n)} = F\times^T \frac{1}{Q_{[0, n)}}\)</span></li><li>从上到下 cdq。转置问题的贡献图是 <span class="math inline">\(P_{[l, m)}\stackrel{\times Q_{[m, r)}}{\longrightarrow}P_{[l, r)}\stackrel{\times Q_{[l, m)}}{\longleftarrow}P_{[m, r)}\)</span>，所以原问题的贡献图是 <span class="math inline">\(P_{[l, m)}\stackrel{\times^T Q_{[m, r)}}{\longleftarrow}P_{[l, r)}\stackrel{\times^T Q_{[l, m)}}{\longrightarrow}P_{[m, r)}\)</span>。</li></ol><p>至此就完成了多点求值。</p><h3 id="多项式快速插值">多项式快速插值</h3><p>首先考虑拉格朗日插值公式：</p><p><span class="math display">\[ \begin{aligned} F(x) &amp;=\sum_{i=1}^n y_i \prod_{j\ne i}\frac{x-x_j}{x_i-x_j}\\ &amp;=\sum_{i=1}^n \frac{y_i}{\boxed{\prod_{j\ne i} (x_i-x_j)}}\prod_{j \ne i} (x - x_j) \end{aligned} \]</span></p><p>考虑设 <span class="math inline">\(g(x) = \prod_{i=1}^n (x-x_i)\)</span>，那么框出来的部分就是 <span class="math inline">\(\dfrac{g(x_i)}{x-x_i}\)</span>。由于它是连续可导的，且在除 <span class="math inline">\(x=x_i\)</span> 以外的点都和 <span class="math inline">\(\prod_{j\ne i} (x-x_j)\)</span> 值相同。所以 <span class="math inline">\(x-x_i\)</span> 是它的可去间断点。取极限得 <span class="math inline">\(\lim_{x\to x_i}\dfrac{F(x)}{x-x_i}=\lim_{x\to x_i}F&#39;(x) = F&#39;(x_i)\)</span>。</p><p>后面就考虑分治 FFT：</p><p><span class="math display">\[ \begin{aligned} F_{[l, r)} &amp;=\sum_{i=l}^r \frac{y_i}{g&#39;(x_i)} \prod_{j\ne i} (x-x_j)\\ &amp;=F_{[l, mid)}\prod_{j=mid}^{r-1}(x-x_j) + F_{[mid, r)}\prod_{j=l}^{mid-1}(x-x_j) \end{aligned} \]</span></p><h3 id="连续整数拉格朗日插值">连续整数拉格朗日插值</h3><p>应该不是属于我讲的部分？</p><p>给个 <del>板子</del> 例题吧：<a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/622/F">CF622F The Sum of the k-th Powers</a></p><h3 id="例题-3">例题</h3><ol type="1"><li><a target="_blank" rel="noopener" href="https://uoj.ac/problem/182">UOJ182 a^-1 + b problem</a><ul><li>找性质</li><li>推柿子</li><li>多点求值！</li></ul></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5450">P5450 [THUPC2018] 淘米神的树</a><ul><li>先考虑一个黑点？</li><li>建立虚点，转化成基环树</li><li>推柿子！</li><li>多点求值！</li></ul></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3321">P3321 [SDOI2015] 序列统计</a><ul><li>加法怎么做？<ul><li>需要循环卷积？</li></ul></li><li>模意义下的乘法转加法？<ul><li>原根！</li></ul></li></ul></li><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5293">P5293 [HNOI2019] 白兔之舞</a><ul><li>矩阵乘法</li><li>单位根反演</li></ul></li></ol><h3 id="习题-4">习题</h3><ol type="1"><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4191">P4191 [CTSC2010] 性能优化</a>（注意此题不是 bluestein 裸题）</li><li><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc060/tasks/agc060_d">AGC060D Same Descent Set</a>（较难）</li></ol><hr><h2 id="上升幂下降幂与斯特林">上升幂、下降幂与斯特林</h2><h3 id="快速计算第一二类斯特林数的一行列">快速计算第一、二类斯特林数的一行、列</h3><p>参考 <a target="_blank" rel="noopener" href="https://oi-wiki.org/math/combinatorics/stirling/">OI Wiki</a></p><p>模板题：P5408，P5409，P5395，P5396</p><h3 id="下降幂多项式">下降幂多项式</h3><p>形如 <span class="math inline">\(F(x) = \sum_{i=0}^n f_i x^{\underline{i}}\)</span> 的多项式叫做下降幂多项式。</p><p>类似的有上升幂多项式，由于和下降幂对称，而且也不常用，所以下面都不讲。</p><h4 id="下降幂多项式多点求值和插值">下降幂多项式多点求值和插值</h4><p>参考 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/solution-p5394">这里</a></p><h4 id="下降幂多项式乘法">下降幂多项式乘法</h4><p>先多点求值再插值即可。</p><h4 id="下降幂多项式与普通多项式互转">下降幂多项式与普通多项式互转</h4><p>有两种方法。</p><p>第一种比较无脑，但是常数较大，即先将其中一个多点求值，再将另一个快速插值。</p><p>第二种是分治 FFT/NTT，具体可以参考题解区（<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P5393">下降转普通</a>，<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P5383">普通转下降</a>）</p><h3 id="例题-4">例题</h3><ol type="1"><li>第一类斯特林数的一行</li><li><a target="_blank" rel="noopener" href="https://uoj.ac/problem/269">UOJ269 【清华集训2016】如何优雅地求和</a></li></ol><h3 id="习题-5">习题</h3><ol type="1"><li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6620">P6620 [省选联考 2020 A 卷] 组合数问题</a></li><li><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/1278/F">CF1278F Cards</a></li></ol><hr><h2 id="其它应用">其它应用</h2><ol type="1"><li><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/528/D">CF528D Fuzzy Search</a><ul><li>多项式×字符串</li></ul></li><li><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7054">HDU7054 Yiwen with Formula</a></li></ol><p>上面的题目比较有针对性，一般都是针对章节的较为模板化的题目。</p><p>如果想要做多项式杂题可以看 grass8cow 的 <a target="_blank" rel="noopener" href="https://vjudge.net/contest/543361">专题</a>（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cwhfy/protected/p/17123929.html">题解</a>，密码是经典密码）</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/generating-function/" rel="tag"><i class="fa fa-tag"></i> 生成函数</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/codeforces-814e/" rel="prev" title="CodeForces 814E An unavoidable detour for home 题解"><i class="fa fa-chevron-left"></i> CodeForces 814E An unavoidable detour for home 题解</a></div><div class="post-nav-item"><a href="/post/atcoder-arc175-f/" rel="next" title="AtCoder ARC175F Append Same Characters 题解">AtCoder ARC175F Append Same Characters 题解 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Eray</span></div><div class="busuanzi-count"></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://unpkg.com/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline-1-g2268155.deta.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"写下你的评论…","sofa":"还没有评论~"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/weibo","https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili","https://unpkg.com/@waline/emojis@1.0.1/qq","https://unpkg.com/@waline/emojis@1.0.1/tieba","https://unpkg.com/@waline/emojis@1.0.1/tw-emoji"],"meta":["nick","mail","link"],"requiredMeta":["nick"],"wordLimit":0,"login":"enable","pageSize":10,"libUrl":"https://unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/post/generating-function-lecture-notes/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script></body></html>