<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022.10.18 模拟赛题解</title>
    <url>/post/2022-10-18-solution/</url>
    <content><![CDATA[<p><a
href="https://local.cwoi.com.cn:8443/contest/C0137/problem/A">比赛链接</a></p>
<h2 id="a.-菜">A. 菜</h2>
<p><a
href="https://local.cwoi.com.cn:8443/contest/C0137/problem/A">原题链接</a></p>
<p>这种题赛时能写假做法……有猪啊！</p>
<p>考虑维护一个栈，每次加入一颗菜，然后尝试和当前栈顶的菜合并。正确性显然。</p>
<p>其中如果暴力求 <span
class="math inline">\(\operatorname{lcm}\)</span> 会炸，所以考虑用
<code>bitset</code> 维护每个因子是否出现。</p>
<p>时间复杂度 <span
class="math inline">\(O(\frac{nV}{\omega})\)</span>，<span
class="math inline">\(V\)</span> 是值域。</p>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::bitset&lt;1000&gt; a[N];</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::bitset&lt;1000&gt;&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x / <span class="built_in">gcd</span>(x, y) * y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">700</span>; j++) <span class="keyword">if</span>(x % j == <span class="number">0</span>) a[i][j] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">		<span class="keyword">while</span>(stk.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; (stk.<span class="built_in">back</span>() &amp; stk.<span class="built_in">end</span>()[<span class="number">-2</span>]).<span class="built_in">any</span>()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> x = stk.<span class="built_in">back</span>(); stk.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">auto</span> y = stk.<span class="built_in">back</span>(); stk.<span class="built_in">pop_back</span>();</span><br><span class="line">			stk.<span class="built_in">push_back</span>(x | y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(stk.<span class="built_in">size</span>() &gt; <span class="number">1</span> ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<h2 id="b.-狗">B. 狗</h2>
<p><a
href="https://local.cwoi.com.cn:8443/contest/C0137/problem/B">原题链接</a></p>
<p>发现 <code>U/D</code> 和 <code>L/R</code> 互不影响，所以拆成 <span
class="math inline">\(2\cdot n\)</span> 个括号序列。</p>
<p>容易发现每个括号序列互不影响，所以对于每个序列统计方案数和答案（所有方案中匹配上的括号数的和）然后直接算就好了。</p>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(x = <span class="number">0</span>; <span class="string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">char</span> b[N][N];</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v[<span class="number">2</span> * N], w[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> f[N][N], g[N][N], fv[<span class="number">2</span> * N], gv[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> &amp;x)</span> </span>&#123; x &gt;= MOD ? x -= MOD : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">while</span>(ch &lt; <span class="string">&#x27;A&#x27;</span> || ch &gt; <span class="string">&#x27;Z&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) b[i][j] = ch, ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="built_in">read</span>(a[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) v[i].<span class="built_in">push_back</span>(<span class="number">0</span>), w[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="keyword">if</span>(b[i][j] == <span class="string">&#x27;L&#x27;</span> || b[i][j] == <span class="string">&#x27;R&#x27;</span>) v[i].<span class="built_in">push_back</span>(b[i][j] == <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>), w[i].<span class="built_in">push_back</span>(a[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="keyword">if</span>(b[j][i] == <span class="string">&#x27;U&#x27;</span> || b[j][i] == <span class="string">&#x27;D&#x27;</span>) v[i + n].<span class="built_in">push_back</span>(b[j][i] == <span class="string">&#x27;D&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>), w[i + n].<span class="built_in">push_back</span>(a[j][i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span> * n; k++) &#123;</span><br><span class="line">		<span class="type">int</span> sz = (<span class="type">int</span>)v[k].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sz; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sz; j++) f[i][j] = <span class="number">0</span>, g[i][j] = <span class="number">-1</span>;</span><br><span class="line">		f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">			<span class="built_in">mod</span>(f[i][j] += f[i - <span class="number">1</span>][j]);</span><br><span class="line">			<span class="keyword">if</span>(g[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>) g[i][j] = g[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">0</span> &lt;= j - v[k][i] &amp;&amp; j - v[k][i] &lt;= sz) &#123;</span><br><span class="line">				LL extra = (v[k][i] == <span class="number">-1</span> ? j - v[k][i] : <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">mod</span>(f[i][j] += f[i - <span class="number">1</span>][j - v[k][i]] * extra % MOD);</span><br><span class="line">				<span class="keyword">if</span>(g[i - <span class="number">1</span>][j - v[k][i]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span>(g[i][j] == <span class="number">-1</span>) g[i][j] = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">mod</span>(g[i][j] += (g[i - <span class="number">1</span>][j - v[k][i]] + (LL)f[i - <span class="number">1</span>][j - v[k][i]] * w[k][i] % MOD) * extra % MOD);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fv[k] = f[sz][<span class="number">0</span>], gv[k] = g[sz][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//		for(int i = 1; i &lt;= sz; i++) for(int j = 0; j &lt;= sz; j++) printf(&quot;g[%d][%d] = %lld\n&quot;, i, j, g[i][j]);</span></span><br><span class="line"><span class="comment">//		printf(&quot;%d: (f=%lld, g=%lld) &quot;, k, fv[k], gv[k]);</span></span><br><span class="line"><span class="comment">//		for(int i = 1; i &lt;= sz; i++) printf(&quot;%d(%d) &quot;, v[k][i], w[k][i]);</span></span><br><span class="line"><span class="comment">//		puts(&quot;&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">		LL ret = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * n; j++) <span class="keyword">if</span>(i != j) (ret *= fv[j]) %= MOD;</span><br><span class="line">		(ans += ret * gv[i] % MOD) %= MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="c.-可">C. 可</h2>
<p><a
href="https://local.cwoi.com.cn:8443/contest/C0137/problem/C">原题链接</a></p>
<h3 id="做法-180-分">做法 1（80 分）</h3>
<p>首先显然题目就是求所有方案的 <span class="math inline">\(f\)</span>
值的和。</p>
<p>如果 <span class="math inline">\(k=1\)</span> 那么显然是数位 DP。</p>
<p>考虑如何拓展到 <span class="math inline">\(k&gt;1\)</span>。设 <span
class="math inline">\(dp(i,j)\)</span> 表示前 <span
class="math inline">\(i\)</span> 位，有 <span
class="math inline">\(j\)</span> 个卡上界，转移时需要再记一个
DP。总复杂度是 <span class="math inline">\(O(nk^4)\)</span>。</p>
<h3 id="做法-2100-分">做法 2（100 分）</h3>
<p>设 <span class="math inline">\(g(s)\)</span> 表示 <span
class="math inline">\(\sum a_i = s\)</span>
的方案数，那么就有一个经典的容斥：<span class="math inline">\(g(s) =
\sum_{i=0}^i (-1)^i \binom{k}{i}\binom{s - i(x + 1) + k - 1}{k -
1}\)</span>，其中 <span class="math inline">\(s - k(x + 1) + k - 1 &lt;
k - 1\)</span> 时 <span class="math inline">\(\binom{s - k(x + 1) + k -
1}{k - 1}\)</span> 定义为 <span class="math inline">\(0\)</span>。</p>
<p>那么答案就是 <span class="math inline">\(\sum_{i=0}^kx
f(i)g(i)\)</span>。</p>
<p>推一下式子：</p>
<p><span class="math display">\[
\begin{aligned}
     &amp;\sum_{i=0}^{kx} f(i)g(i)\\
    =&amp;\sum_{i=0}^{kx} f(i) \sum_{j=0}^k (-1)^j \binom{k}{j} \binom{i
- j(x + 1) + k - 1}{k - 1}\\
    =&amp;\sum_{j=0}^k (-1)^j \binom{k}{j} \sum_{i=0}^{kx} f(i) \binom{i
- j(x + 1) + k - 1}{k - 1}
\end{aligned}
\]</span></p>
<p>然后就很妙了。我们发现 <span class="math inline">\(\binom{i - j(x +
1) + k - 1}{k - 1} = \dfrac{\prod_{r = i - j(x + 1) + 1}^{i - j(x + 1) +
k - 1} r}{(k - 1)!} = \prod_{r = 1}^{k - 1}\left(\dfrac{1}{(k - 1)!}i +
\dfrac{-j(x + 1) + r}{(k - 1)!}\right)\)</span>，这是一个关于 <span
class="math inline">\(i\)</span> 的 <span class="math inline">\(k -
1\)</span> 次多项式。由于 <span class="math inline">\(k\)</span>
很小，所以可以暴力乘出系数。我们设 <span
class="math inline">\(l\)</span> 次项的系数为 <span
class="math inline">\(c(j, l)\)</span>。但是上面我们说过当 <span
class="math inline">\(s - k(x + 1) + k - 1 &lt; k - 1\)</span> 时 <span
class="math inline">\(\binom{s - k(x + 1) + k - 1}{k - 1}\)</span>
定义为 <span
class="math inline">\(0\)</span>，然而这里拆成多项式后就不对了。所以我们考虑将
<span class="math inline">\(\sum_{i=0}^{kx} f(i) \binom{i - j(x + 1) + k
- 1}{k - 1}\)</span> 中的 <span
class="math inline">\(\sum_{i=0}^{kx}\)</span> 改成 <span
class="math inline">\(\sum_{i=j(x + 1)}^{kx}\)</span>。</p>
<p>那么上式就等于</p>
<p><span class="math display">\[
\sum_{j=0}^k (-1)^j \binom{k}{j} \sum_{l=0}^{k - 1} c(j, l) \sum_{i=j(x
+ 1)}^{kx} f(i) i^l
\]</span></p>
<p>所以现在的问题就转化成了求 <span class="math inline">\(\sum_{i=0}^{s}
f(i)i^l\)</span>（然后用 <span
class="math inline">\(\left(\sum_{i=0}^{kx} f(i)i^l\right) -
\left(\sum_{i=0}^{j(x + 1) - 1} f(i)i^l\right)\)</span> 就好了）。</p>
<p>我们设 <span class="math inline">\(dp(i, j)\)</span> 表示 <span
class="math inline">\(\sum\limits_{t=0}^{s \bmod 10^i}
f(t)t^j\)</span>。然后我们来推式子：（没写范围的变量和上一行范围一样）</p>
<p><span class="math display">\[
\begin{aligned}
     &amp;dp(i, j)\\
    =&amp;\sum_{y=0}^{s \bmod 10^i} f(y)y^j\\
    =&amp;\sum_{\substack{y\in [0, s \bmod 10^i]\\t = y \bmod 10^{i -
1}\\t&#39; = y - t}} f(t + t&#39;) (t + t&#39;)^j\\
    =&amp;\sum_{t&#39;} \sum_{t} f(t)f(t&#39;) \sum_{r=0}^j \binom{j}{r}
t^r (t&#39;)^{j - r}\\
    =&amp;\sum_{t&#39;} f(t&#39;) \sum_{r=0}^j \binom{j}{r} (t&#39;)^{j
- r} \sum_{t} f(t)t^r\\
    =&amp;\sum_{r=0}^j \sum_{t&#39;} f(t&#39;) \binom{j}{r} (t&#39;)^{j
- r} dp(i - 1, r)
\end{aligned}
\]</span></p>
<p>所以单次 DP 的复杂度是 <span class="math inline">\(O(\log kx \cdot
k^2) = O(k^2(\log k + \log x)) = O(k^2 \log x)\)</span>，还带一个 <span
class="math inline">\(10\)</span> 的常数。</p>
<p>由于要跑 <span class="math inline">\(O(k)\)</span> 次
DP，所以总复杂度是 <span class="math inline">\(O(k^3 \log x)\)</span>
的。所以整道题的总复杂度也是 <span class="math inline">\(O(k^3\log
x)\)</span> 的。</p>
<p>是不是这样就过了呢？我们发现常熟太大，炸了。考虑优化掉 <span
class="math inline">\(10\)</span> 的常数：</p>
<p><span class="math display">\[
\begin{aligned}
     &amp;\sum_{r=0}^j \sum_{t&#39;} f(t&#39;) \binom{j}{r} (t&#39;)^{j
- r} dp(i - 1, r)\\
    =&amp;\sum_{r=0}^j
\left(\sum_{t&#39;}f(t&#39;)(t&#39;)^{j-r}\right)\binom{j}{r} dp(i - 1,
r)
\end{aligned}
\]</span></p>
<p>考虑预处理 <span class="math inline">\(sum(u, q) = \sum_{t&#39;=0}^u
f(t&#39;)(t&#39;)^q\)</span>，就可以优化掉 <span
class="math inline">\(10\)</span> 的常数了。</p>
<p>最终复杂度 <span class="math inline">\(O(k^3 \log x)\)</span>。</p>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<blockquote>
<p>No code yet.</p>
</blockquote>

</details>
<h2 id="d.-爱">D. 爱</h2>
<blockquote>
<p>No solution yet.</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder ABC172F Unfair Nim 题解</title>
    <url>/post/atcoder-abc172-f/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>题目链接：<a href="https://atcoder.jp/contests/abc172/tasks/abc172_f"
class="uri">https://atcoder.jp/contests/abc172/tasks/abc172_f</a></p>
<p>有 <span class="math inline">\(n\)</span> 堆石子，第 <span
class="math inline">\(i\)</span> 堆有 <span
class="math inline">\(a_i\)</span>
个，两人轮流选择一堆取石子，至少取一个，至多把这堆取完。<br />
后手开挂了，可以在开局前将第一堆石子中拿若干个石子到第二堆（不能把第一堆拿完），问最少拿多少石子到第二堆才能使后手必胜。
<span class="math inline">\(2 \le n \le 300\)</span>, <span
class="math inline">\(1 \le a_i \le 10^{12}\)</span></p>
<h2 id="思路">思路</h2>
<h3 id="前置芝士">前置芝士</h3>
<p><a href="https://oi-wiki.org/math/game-theory/#nim">Nim
游戏</a><br />
<a href="https://oi-wiki.org/math/game-theory/#nim_1">Nim
游戏解法</a><br />
<a href="https://oi-wiki.org/math/game-theory/#_3">Nim
游戏解法证明</a></p>
<h3 id="问题转化">问题转化</h3>
<p>令 <span class="math inline">\(A = a_1\)</span>，<span
class="math inline">\(B = a_2\)</span>，<span class="math inline">\(C =
\oplus_{i=3}^n a_i\)</span>，<br />
则原问题转化为求最大的 <span
class="math inline">\(A&#39;\)</span>，<span
class="math inline">\(B&#39;\)</span> 使得 <span
class="math inline">\(A&#39; \oplus B&#39; \oplus C = 0\)</span> 且
<span class="math inline">\(A&#39; + B&#39; = A + B\)</span></p>
<h3 id="大体确定">大体确定</h3>
<p>令 <span class="math inline">\(D = \frac{A&#39; + B&#39; -
C}{2}\)</span>，不难发现 <span class="math inline">\(D = A&#39;
\operatorname{and} B&#39;\)</span>。<br />
我们可以按位考虑，对于每一位：</p>
<ul>
<li>如果 <span class="math inline">\(A&#39; = B&#39; = 0\)</span>，则
<span class="math inline">\(C = 0\)</span>，那么 <span
class="math inline">\(D = 0 = A&#39; \operatorname{and}
B&#39;\)</span></li>
<li>如果 <span class="math inline">\(A&#39; = B&#39; = 1\)</span>，则
<span class="math inline">\(C = 0\)</span>，那么 <span
class="math inline">\(D = 1 = A&#39; \operatorname{and}
B&#39;\)</span></li>
<li>如果 <span class="math inline">\(A&#39;\)</span>, <span
class="math inline">\(B&#39;\)</span> 一个为 <span
class="math inline">\(0\)</span>，另一个为 <span
class="math inline">\(1\)</span>，则 <span class="math inline">\(C =
1\)</span>，那么 <span class="math inline">\(D = 0 = A&#39;
\operatorname{and} B&#39;\)</span></li>
</ul>
<p>又因为 <span class="math inline">\(D = \frac{A&#39; + B&#39; - C}{2}
= \frac{A + B - C}{2}\)</span>，所以我们可以求出 <span
class="math inline">\(D\)</span>。<br />
而我们要求 <span class="math inline">\(A&#39;\)</span> 最大，所以 <span
class="math inline">\(D = A&#39; \operatorname{and} B&#39;\)</span>
应该都放到 <span class="math inline">\(A&#39;\)</span> 上。</p>
<h3 id="细微调整">细微调整</h3>
<p>还是按位考虑。</p>
<p>对于每一位，如果 <span class="math inline">\(C = 1\)</span>，那么
<span class="math inline">\(A&#39;\)</span>, <span
class="math inline">\(B&#39;\)</span> 中必有一个为 <span
class="math inline">\(1\)</span>，如果将这一位的 <span
class="math inline">\(1\)</span> 加到 <span
class="math inline">\(A&#39;\)</span> 上满足题意（加上后 <span
class="math inline">\(A&#39; &lt; A\)</span>）就加到 <span
class="math inline">\(A&#39;\)</span> 上。</p>
<p>最后加一些特判（见代码）就完了。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码中的 a 是上面的 A&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    LL A = <span class="number">0</span>, B = <span class="number">0</span>, C = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;A, &amp;B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LL x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">        C ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">    LL D = (A + B - C) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(((A + B - C) &amp; <span class="number">1</span>) || D &lt; <span class="number">0</span> || D &gt; A || D &amp; C)</span><br><span class="line">        &#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    LL a = D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>((C &amp; (<span class="number">1LL</span> &lt;&lt; i)) &amp;&amp; (a | (<span class="number">1LL</span> &lt;&lt; i)) &lt;= A)</span><br><span class="line">            a |= (<span class="number">1LL</span> &lt;&lt; i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a == <span class="number">0</span> ? <span class="number">-1LL</span> : A - a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder ABC177F I hate Shortest Path Problem 题解</title>
    <url>/post/atcoder-abc177-f/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>题目链接：<a href="https://atcoder.jp/contests/abc177/tasks/abc177_f"
class="uri">https://atcoder.jp/contests/abc177/tasks/abc177_f</a></p>
<p>一个 <span class="math inline">\((H + 1) \times W\)</span>
的网格，每个位置都可以往右走一格（最右边一列不行），第 <span
class="math inline">\(i\)</span> 行除了第 <span
class="math inline">\(A_i\)</span> 到第 <span
class="math inline">\(B_i\)</span> 个格子以外都可以往下走。<br />
你可以从第 <span class="math inline">\(1\)</span>
行任意一个格子开始走，对于每一个 <span class="math inline">\(i \in [2, n
+ 1]\)</span>，求走到第 <span class="math inline">\(i\)</span>
行任意一个格子的最小步数。<br />
其中 <span class="math inline">\(H, W \le 2 \times 10^5\)</span>，<span
class="math inline">\(1 \le A_i \le B_i \le W\)</span></p>
<h2 id="思路">思路</h2>
<h3 id="贪心思想">贪心思想</h3>
<p>容易发现，除了第 <span class="math inline">\(1\)</span>
行，每个格子肯定是尽量往下走，即只有当不能往下走时才往右走。<br />
那么初步想法是进行 DP。</p>
<h3 id="dp">DP</h3>
<p>下面用 <span class="math inline">\((i, j)\)</span> 表示第 <span
class="math inline">\(i\)</span> 行第 <span
class="math inline">\(j\)</span> 列的格子。</p>
<p><span class="math inline">\(f(i, j)\)</span>
表示从第一行任意一个格子走到 <span class="math inline">\((i, j)\)</span>
时的最小步数。 那么对于 <span class="math inline">\(f(i, j)\)</span>
有以下三种情况：</p>
<ol type="1">
<li>如果上面有挡板，则 <span class="math inline">\(f(i, j) =
\inf\)</span>，可以证明这样对答案没有影响。</li>
<li>如果上面和左上（即 <span class="math inline">\((i - 1, j -
1)\)</span>）都没有挡板，则 <span class="math inline">\(f(i, j) = f(i -
1, j) + 1\)</span></li>
<li>如果上面没有挡板，左上有挡板，则 <span class="math inline">\(f(i, j)
= \min_{k = 1}^j f(i - 1, k) + 1\)</span></li>
</ol>
<p>其中从左边往右边走的贡献全部集中在了第三种转移。</p>
<p>上面的转移即：</p>
<p><span class="math display">\[
f(i, j) =
\begin{cases}
    0&amp;(i=1)\\
    \inf&amp;(A_{i - 1} \le j \le B_{i - 1})\\
    f(i - 1, j) + 1&amp;(B_{i - 1} &lt; j - 1 \;\texttt{or}\; A_{i - 1}
&gt; j)\\
    \min_{k = 1}^j f(i - 1, k) + 1&amp;(B_{i - 1} = j - 1)
\end{cases}
\]</span></p>
<h3 id="数据结构优化">数据结构优化</h3>
<p>但是上面 DP 的复杂度是 <span class="math inline">\(O(HW)\)</span>
的，在这道题肯定是过不去的。这时候我们可以用线段树优化。</p>
<p>我们对于每个 <span class="math inline">\(f(i, \cdots)\)</span>
用线段树维护，直接 <span class="math inline">\(O(\log H)\)</span>
进行维护。（类似背包的思想，直接在原线段树上进行更改）</p>
<p>对于第一种转移，区间赋值/区间加 <span
class="math inline">\(\inf\)</span>。<br />
对于第二种转移，区间加 <span class="math inline">\(1\)</span>。<br />
对于第三种转移，需要再维护一个线段树，值为 <span
class="math inline">\(f(i, j) + W -
j\)</span>。此时第三种转移就用第二个线段树的值来维护。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span> &#123;</span><br><span class="line">    LL t[N &lt;&lt; <span class="number">2</span>], ladd[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">lazy_down</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        t[x &lt;&lt; <span class="number">1</span>] += ladd[x];</span><br><span class="line">        t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += ladd[x];</span><br><span class="line">        ladd[x &lt;&lt; <span class="number">1</span>] += ladd[x];</span><br><span class="line">        ladd[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += ladd[x];</span><br><span class="line">        ladd[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify_add</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, LL qadd, <span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) &#123; t[x] += qadd, ladd[x] += qadd; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">lazy_down</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify_add</span>(ql, qr, qadd, x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="keyword">if</span>(qr &gt; mid) <span class="built_in">modify_add</span>(ql, qr, qadd, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        t[x] = <span class="built_in">min</span>(t[x &lt;&lt; <span class="number">1</span>], t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">query_min</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[x];</span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">lazy_down</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(qr &lt;= mid) <span class="keyword">return</span> <span class="built_in">query_min</span>(ql, qr, x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; mid) <span class="keyword">return</span> <span class="built_in">query_min</span>(ql, qr, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query_min</span>(ql, qr, x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">query_min</span>(ql, qr, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SegTree ans1; <span class="comment">// f[][i]</span></span><br><span class="line">SegTree ans2; <span class="comment">// f[][i] + m - i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans2.<span class="built_in">modify_add</span>(i, i, m - i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LL tmp = ans2.<span class="built_in">query_min</span>(<span class="number">1</span>, b[i] + <span class="number">1</span>) - ((LL)m - b[i] - <span class="number">1</span>);</span><br><span class="line">        ans1.<span class="built_in">modify_add</span>(b[i] + <span class="number">1</span>, b[i] + <span class="number">1</span>, <span class="built_in">min</span>(tmp - ans1.<span class="built_in">query_min</span>(b[i] + <span class="number">1</span>, b[i] + <span class="number">1</span>), <span class="number">0LL</span>));</span><br><span class="line">        ans2.<span class="built_in">modify_add</span>(b[i] + <span class="number">1</span>, b[i] + <span class="number">1</span>, <span class="built_in">min</span>(tmp + m - (b[i] + <span class="number">1</span>) - ans2.<span class="built_in">query_min</span>(b[i] + <span class="number">1</span>, b[i] + <span class="number">1</span>), <span class="number">0LL</span>));</span><br><span class="line">        ans1.<span class="built_in">modify_add</span>(a[i], b[i], INF);</span><br><span class="line">        ans2.<span class="built_in">modify_add</span>(a[i], b[i], INF);</span><br><span class="line">        ans1.<span class="built_in">modify_add</span>(<span class="number">1</span>, m, <span class="number">1</span>);</span><br><span class="line">        ans2.<span class="built_in">modify_add</span>(<span class="number">1</span>, m, <span class="number">1</span>);</span><br><span class="line">        tmp = ans1.<span class="built_in">query_min</span>(<span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt;= INF) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder ARC175F Append Same Characters 题解</title>
    <url>/post/atcoder-arc175-f/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p><a
href="https://atcoder.jp/contests/arc175/tasks/arc175_f">传送门</a></p>
<p>给出由 <span class="math inline">\(n\)</span>
个仅含小写英文字母的字符串组成的序列，你可以做下列两种操作：</p>
<ol type="1">
<li>选择一个小写英文字母，并在序列中 <strong>每个</strong>
字符串末尾添加这个字符；</li>
<li>交换序列中两个相邻的字符串。</li>
</ol>
<p>你需要通过若干次操作使得字符串序列的字典序
<strong>单调不降</strong>，求最小操作次数。</p>
<p><span class="math inline">\(2\le n\le 3\times
10^5\)</span>，字符串长度之和 <span class="math inline">\(\le 3\times
10^5\)</span></p>
<h2 id="思路">思路</h2>
<p>首先发现我们肯定会先做完操作 1 再做操作 2，并且操作 2
的次数等于序列的逆序对数，所以问题转化为在每个串后面加一个字符串 <span
class="math inline">\(X\)</span>，并最小化逆序对个数加 <span
class="math inline">\(|X|\)</span>。</p>
<p>于是我们先计算出原序列的逆序对个数，然后再考虑 <span
class="math inline">\(X\)</span> 的影响。</p>
<p>考虑怎样的两个字符串 <span class="math inline">\(A,B\)</span> 会被
<span class="math inline">\(X\)</span> 影响（不妨设 <span
class="math inline">\(|A|\le|B|\)</span>）。如果 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 在前 <span
class="math inline">\(\min(|A|,|B|)\)</span> 个字符就比出结果了，那么
<span class="math inline">\(X\)</span> 显然是没用的。所以只有当 <span
class="math inline">\(A\)</span> 是 <span
class="math inline">\(B\)</span> 的前缀的时候 <span
class="math inline">\(X\)</span> 才有用。</p>
<p>记 <span class="math inline">\(B\)</span> 除去 <span
class="math inline">\(A,B\)</span> 的公共前缀部分后的字符串为 <span
class="math inline">\(Y\)</span>，那么 <span
class="math inline">\(AX&gt;BX\iff X&gt;YX\)</span>。于是其实答案只和
<span class="math inline">\(X,Y\)</span> 有关。</p>
<p>然后似乎就做不下去了。这时需要用到一些结论，这里先不给出证明，在文末统一给出证明（下同）。</p>
<div class="note no-icon info"><p><strong>引理 1:</strong> <span class="math inline">\(X&lt;YX\iff
X&lt;Y^{\infty}\)</span></p>
</div>
<p>有了这个之后就有了一个大致思路。我们把所有 <span
class="math inline">\(Y^{\infty}\)</span> 排序，那么一个 <span
class="math inline">\(X\)</span> 会影响到的 <span
class="math inline">\(Y\)</span> 就是一段前缀。我们对于每个 <span
class="math inline">\(Y\)</span>
统计它对逆序对的贡献，然后枚举一个前缀算答案就行了。</p>
<p>那么怎么对 <span class="math inline">\(Y^{\infty}\)</span>
排序呢？这里需要用到另外的结论。</p>
<div class="note no-icon info"><p><strong>引理 2:</strong> <span
class="math inline">\(X^{\infty}&lt;Y^{\infty}\iff XY&lt;YX\)</span></p>
</div>
<p>然后就可以很容易用 SA 做到 <span class="math inline">\(O(n\log
n)\)</span>，或者用哈希做到 <span class="math inline">\(O(n\log^2
n)\)</span>。</p>
<p>然后考虑一个 <span class="math inline">\(Y\)</span>
对逆序对的贡献到底是什么。对于一个原串 <span
class="math inline">\(B\)</span>，Trie
上它到根的链上所有的（终止）节点都可以作为 <span
class="math inline">\(A\)</span>。不过要注意字符串可以重复，所以一个点可能有多个字符串在这里终止。</p>
<p>由于 <span class="math inline">\(\sum |s_i|\le 3\times
10^5\)</span>，所以我们可以枚举 Trie
上每个节点上的每个字符串，然后再枚举它到根的路径上每个点，这样的总复杂度是
<span class="math inline">\(\sum
|s_i|\)</span>。假设我们枚举了一个字符串 <span
class="math inline">\(s_i=B\)</span> 和它到根路径上一个点 <span
class="math inline">\(x\)</span>，那么 <span
class="math inline">\(x\)</span> 上的所有字符串都可以作为 <span
class="math inline">\(A\)</span> 产生贡献。对于一个 <span
class="math inline">\(A=s_j\)</span>，本来是 <span
class="math inline">\(A&lt;B\)</span>，但如果加上 <span
class="math inline">\(X(X&gt;Y^{\infty})\)</span> 后大小关系会变成 <span
class="math inline">\(AX&gt;BX\)</span>，此时如果 <span
class="math inline">\(j&lt;i\)</span> 对答案的贡献为 <span
class="math inline">\(+1\)</span>（增加一个逆序对），否则（<span
class="math inline">\(i&gt;j\)</span>）对答案的贡献为 <span
class="math inline">\(-1\)</span>（减少一个逆序对）。所以对于 <span
class="math inline">\(x\)</span> 上的所有 <span
class="math inline">\(A\)</span> 我们只需要二分有多少个 <span
class="math inline">\(A\)</span> 的下标小于 <span
class="math inline">\(i\)</span> 并计算贡献就好了。</p>
<p>最后还一个问题就是，假如我们枚举了 <span class="math inline">\(Y_1,
Y_2\)</span> 并让 <span class="math inline">\(Y_1^{\infty}&lt;X\le
Y_2^{\infty}\)</span>，我们如何算出 <span
class="math inline">\(|X|\)</span>
的最小值呢？考虑对于有限的字符串来说，答案是简单的，就是 <span
class="math inline">\(P&lt;X\le Q \implies
|X|_{\min}=\operatorname{lcp}(P,Q)+1\)</span>。所以问题转化为 <span
class="math inline">\(\operatorname{lcp}(Y_1^{\infty},Y_2^{\infty})\)</span>。这里又需要用一个结论。</p>
<div class="note no-icon info"><p><strong>引理 3:</strong> 如果 <span
class="math inline">\(X^{\infty}\ne Y^{\infty}\)</span>，那么 <span
class="math inline">\(\operatorname{lcp}(X^{\infty},Y^{\infty})=\operatorname{lcp}(XY,
YX)\)</span>。</p>
</div>
<p>然后就很容易用 SA
或哈希解决这个问题。具体来说就是把所有串拼在一起并用一个特殊字符隔开，然后就可以用
<code>height</code> 来 <span class="math inline">\(O(1)\)</span>
比较两个串以及它们的（有限）拼接。</p>
<p>还有一点细节需要注意。比如 <span class="math inline">\(X\)</span>
比所有 <span class="math inline">\(Y^{\infty}\)</span>
都大的时候，要特殊处理，具体就是找到第一个非 <code>z</code>
的字符（如果没有就说明不可能找到一个 <span class="math inline">\(X&gt;
Y^{\infty}\)</span>）。以及每个 <span class="math inline">\(Y\)</span>
的贡献都是可能爆 int 的。</p>
<p>总时间复杂度为 <span class="math inline">\(O(n+\sum |s_i| \log
n)\)</span>，如果用哈希就是 <span class="math inline">\(O(n+\sum
|s_i|\log^2 n)\)</span>。</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> st[N], len[N];</span><br><span class="line"><span class="type">int</span> L;</span><br><span class="line"><span class="type">char</span> s[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sa[<span class="number">2</span> * N &lt;&lt; <span class="number">1</span>], rk[<span class="number">2</span> * N &lt;&lt; <span class="number">1</span>], tot[<span class="number">2</span> * N], tp[<span class="number">2</span> * N], ht[<span class="number">2</span> * N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m = std::<span class="built_in">max</span>(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> basic_sort = [&amp;]() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) tot[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= L; i++) tot[rk[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) tot[i] += tot[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = L; i &gt;= <span class="number">1</span>; i--) sa[tot[rk[tp[i]]]--] = tp[i];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= L; i++) rk[i] = s[i], tp[i] = i;</span><br><span class="line">	<span class="built_in">basic_sort</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; L; i &lt;&lt;= <span class="number">1</span>, m = p) &#123;</span><br><span class="line">		p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) tp[++p] = L - i + j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= L; j++) <span class="keyword">if</span>(sa[j] &gt; i) tp[++p] = sa[j] - i;</span><br><span class="line">		<span class="built_in">basic_sort</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= L; j++) tp[j] = rk[j];</span><br><span class="line">		p = rk[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= L; j++)</span><br><span class="line">			rk[sa[j]] = (tp[sa[j - <span class="number">1</span>]] == tp[sa[j]] &amp;&amp; tp[sa[j - <span class="number">1</span>] + i] == tp[sa[j] + i] ? p : ++p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= L; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(rk[i] == <span class="number">1</span>) &#123; ht[rk[i]] = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span>(k) k--;</span><br><span class="line">		<span class="type">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span>(i + k &lt;= L &amp;&amp; j + k &lt;= L &amp;&amp; s[i + k] == s[j + k]) k++;</span><br><span class="line">		ht[rk[i]] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SparseTable</span> &#123;</span><br><span class="line">	<span class="type">int</span> go[<span class="number">21</span>][<span class="number">2</span> * N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= L; i++) go[<span class="number">0</span>][i] = ht[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= L; i++)</span><br><span class="line">				go[j][i] = std::<span class="built_in">min</span>(go[j - <span class="number">1</span>][i], go[j - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l == r) <span class="keyword">return</span> std::<span class="built_in">min</span>(L - sa[l] + <span class="number">1</span>, L - sa[r] + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(l &gt; r) std::<span class="built_in">swap</span>(l, r);</span><br><span class="line">		<span class="type">int</span> k = <span class="number">31</span> ^ __builtin_clz(r - l);</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">min</span>(go[k][l + <span class="number">1</span>], go[k][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ST;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[<span class="number">2</span> * N][<span class="number">26</span>], dep[<span class="number">2</span> * N], sz[<span class="number">2</span> * N];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; end[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> ctrie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123; <span class="type">int</span> l, r; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> lc = ST.<span class="built_in">get</span>(rk[i], rk[j]);</span><br><span class="line">	<span class="keyword">if</span>(lc &gt;= k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> s[i + lc] &lt; s[j + lc] ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(String x, String y) &#123;</span><br><span class="line">	<span class="type">int</span> lenx = x.r - x.l + <span class="number">1</span>, leny = y.r - y.l + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">comp</span>(x.l, y.l, std::<span class="built_in">min</span>(lenx, leny));</span><br><span class="line">	<span class="keyword">if</span>(ret) <span class="keyword">return</span> ret == <span class="number">-1</span>;</span><br><span class="line">	ret = <span class="built_in">comp</span>(lenx &gt; leny ? x.l + leny : y.l, leny &gt; lenx ? y.l + lenx : x.l, std::<span class="built_in">max</span>(lenx, leny) - std::<span class="built_in">min</span>(lenx, leny));</span><br><span class="line">	<span class="keyword">if</span>(ret) <span class="keyword">return</span> ret == <span class="number">-1</span>;</span><br><span class="line">	ret = <span class="built_in">comp</span>(lenx &gt; leny ? y.l : y.l + (leny - lenx), leny &gt; lenx ? x.l : x.l + (lenx - leny), std::<span class="built_in">min</span>(lenx, leny));</span><br><span class="line">	<span class="keyword">return</span> ret == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> lc = ST.<span class="built_in">get</span>(rk[i], rk[j]);</span><br><span class="line">	<span class="keyword">if</span>(lc &gt;= k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> lc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcp</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> lenx = x.r - x.l + <span class="number">1</span>, leny = y.r - y.l + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">lcp</span>(x.l, y.l, std::<span class="built_in">min</span>(lenx, leny));</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">-1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">	ret = <span class="built_in">lcp</span>(lenx &gt; leny ? x.l + leny : y.l, leny &gt; lenx ? y.l + lenx : x.l, std::<span class="built_in">max</span>(lenx, leny) - std::<span class="built_in">min</span>(lenx, leny));</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">-1</span>) <span class="keyword">return</span> ret + std::<span class="built_in">min</span>(lenx, leny);</span><br><span class="line">	ret = <span class="built_in">lcp</span>(lenx &gt; leny ? y.l : y.l + (leny - lenx), leny &gt; lenx ? x.l : x.l + (lenx - leny), std::<span class="built_in">min</span>(lenx, leny));</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">-1</span>) <span class="keyword">return</span> ret + std::<span class="built_in">max</span>(lenx, leny);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">std::vector&lt;std::pair&lt;String, LL&gt;&gt; vct;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!end[x].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y : stk) &#123;</span><br><span class="line">			<span class="type">int</span> j = st[end[x].<span class="built_in">front</span>()] + len[end[x].<span class="built_in">front</span>()] - <span class="number">1</span>;</span><br><span class="line">			vct.<span class="built_in">push_back</span>(&#123;&#123;j - (dep[x] - dep[y]) + <span class="number">1</span>, j&#125;, <span class="number">0</span>&#125;);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i : end[x]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(end[y].<span class="built_in">begin</span>(), end[y].<span class="built_in">end</span>(), i);</span><br><span class="line">				vct.<span class="built_in">back</span>().second += it - end[y].<span class="built_in">begin</span>();</span><br><span class="line">				vct.<span class="built_in">back</span>().second -= end[y].<span class="built_in">end</span>() - it;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		stk.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(trie[x][i]) dep[trie[x][i]] = dep[x] + <span class="number">1</span>, <span class="built_in">dfs</span>(trie[x][i]);</span><br><span class="line">	<span class="keyword">if</span>(!end[x].<span class="built_in">empty</span>()) stk.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	st[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	LL base = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + st[i]);</span><br><span class="line">		len[i] = <span class="built_in">strlen</span>(s + st[i]);</span><br><span class="line">		s[st[i] + len[i]] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">		st[i + <span class="number">1</span>] = st[i] + len[i] + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = st[i]; j &lt;= st[i] + len[i] - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = s[j] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>; k &lt; <span class="number">26</span>; k++) base += sz[trie[now][k]];</span><br><span class="line">			<span class="keyword">if</span>(!trie[now][s[j] - <span class="string">&#x27;a&#x27;</span>]) trie[now][s[j] - <span class="string">&#x27;a&#x27;</span>] = ++ctrie;</span><br><span class="line">			now = trie[now][s[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			sz[now]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) base += sz[trie[now][k]];</span><br><span class="line">		end[now].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	L = st[n] + len[n] - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">get_SA</span>();</span><br><span class="line">	ST.<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	std::<span class="built_in">sort</span>(vct.<span class="built_in">begin</span>(), vct.<span class="built_in">end</span>());</span><br><span class="line">	LL ans = base, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)vct.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		sum += vct[i].second;</span><br><span class="line">		<span class="type">int</span> val = <span class="built_in">lcp</span>(vct[i].first, vct[i + <span class="number">1</span>].first);</span><br><span class="line">		<span class="keyword">if</span>(val != <span class="number">-1</span>) ans = std::<span class="built_in">min</span>(ans, base + sum + val + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!vct.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		sum += vct.<span class="built_in">back</span>().second;</span><br><span class="line">		<span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(vct.<span class="built_in">back</span>().first.l + val &lt;= vct.<span class="built_in">back</span>().first.r &amp;&amp; s[vct.<span class="built_in">back</span>().first.l + val] == <span class="string">&#x27;z&#x27;</span>) val++;</span><br><span class="line">		<span class="keyword">if</span>(vct.<span class="built_in">back</span>().first.l + val &lt;= vct.<span class="built_in">back</span>().first.r) ans = std::<span class="built_in">min</span>(ans, base + sum + val + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="证明">证明</h2>
<p><del>下面的题解其实基本上是<a
href="https://atcoder.jp/contests/arc175/editorial/9662">官方题解</a>的翻译。</del></p>
<h3 id="前置">前置</h3>
<p>可能需要了解一下 <a
href="https://www.luogu.com/article/d4y3zqqv">Border 理论和 period
相关的东西</a>。（不用了解太多，知道 Border 和 period
的定义以及弱周期定理就行了，也可以先往下看，看到不懂的再到这篇文章里找）</p>
<h3 id="引理-1">引理 1</h3>
<div class="note no-icon info"><p><strong>引理 1:</strong> <span class="math inline">\(X&lt;YX\iff
X&lt;Y^{\infty}\)</span></p>
</div>
<p>对于 <span class="math inline">\(Y\)</span> 不是 <span
class="math inline">\(X\)</span> 的前缀的情况，此时 <span
class="math inline">\(X&gt;YX\iff X&gt;Y\iff
X&gt;Y^{\infty}\)</span>。</p>
<p>然后对于 <span class="math inline">\(Y\)</span> 是 <span
class="math inline">\(X\)</span> 的前缀，则令 <span
class="math inline">\(X&#39;=YX\)</span>，那么 <span
class="math inline">\(X&gt;YX\iff YX&#39;&gt;Y^2X&#39;\iff
X&#39;&gt;YX&#39;\)</span>，根据归纳法 <span
class="math inline">\(X&#39;&gt;YX&#39;\iff X&#39;&gt;Y^{\infty}\iff
YX&#39;&gt;Y^{\infty}\iff X&gt;Y^{\infty}\)</span>。</p>
<h3 id="引理-2">引理 2</h3>
<div class="note no-icon info"><p><strong>引理 2:</strong> <span
class="math inline">\(X^{\infty}&lt;Y^{\infty}\iff XY&lt;YX\)</span></p>
</div>
<p>对于字符串 <span class="math inline">\(X,Y\)</span> 和 <span
class="math inline">\(g=\gcd(|X|,
|Y|)\)</span>，下面三个结论都是等价的：</p>
<ol type="1">
<li><span class="math inline">\(X^{\infty}=Y^{\infty}\)</span></li>
<li><span class="math inline">\(g\)</span> 同时是 <span
class="math inline">\(X,Y\)</span> 的循环节（且 <span
class="math inline">\(X[0..g)=Y[0..g)）\)</span></li>
<li><span class="math inline">\(XY=YX\)</span></li>
</ol>
<p>其中 <span class="math inline">\(2 \Rightarrow 1\)</span> 以及 <span
class="math inline">\(2 \Rightarrow 3\)</span> 是显然的。</p>
<div class="note no-icon success"><p><span class="math inline">\(1\Rightarrow 2\)</span>：</p>
<p>根据中国剩余定理，只要 <span class="math inline">\(i\equiv j \pmod
g\)</span>，就一定可以找到 <span class="math inline">\(k\)</span> 满足
<span class="math inline">\(k\equiv i \pmod{|X|}\)</span> 且 <span
class="math inline">\(k\equiv j \pmod{|Y|}\)</span>，因为 <span
class="math inline">\(\gcd(|X|,|Y|)=g\)</span>。所以 <span
class="math inline">\(X_i = (X^{\infty})_k = (Y^{\infty})_k =
Y_j\)</span>，又因为 <span class="math inline">\(i+g\equiv j\pmod
g\)</span> 也成立，所以同理可得 <span class="math inline">\(X_{i+g} =
Y_j\)</span>，所以 <span class="math inline">\(X_i =
X_{i+g}\)</span>，即 <span class="math inline">\(g\)</span> 是 <span
class="math inline">\(X\)</span> 的周期。<span
class="math inline">\(Y\)</span> 同理。</p>
</div>
<div class="note no-icon success"><p><span class="math inline">\(3\Rightarrow 2\)</span>：</p>
<p>不妨设 <span class="math inline">\(|X|\le|Y|\)</span>。由于 <span
class="math inline">\(XY=YX\)</span>，所以 <span
class="math inline">\(Y[0, |X|)=X=Y[|Y|-|X|,|Y|)\)</span>，故 <span
class="math inline">\(X\)</span> 是 <span
class="math inline">\(Y\)</span> 的 Border，即 <span
class="math inline">\(|Y|-|X|\)</span> 是 <span
class="math inline">\(Y\)</span> 的循环节。同理，由于 <span
class="math inline">\(XY=YX\)</span>，所以 <span
class="math inline">\(Y[|X|,|Y|)=Y[0,|Y|-|X|)\)</span>，故 <span
class="math inline">\(Y[0,|Y|-|X|)\)</span> 是 <span
class="math inline">\(Y\)</span> 的 Border，即 <span
class="math inline">\(|X|\)</span> 是 <span
class="math inline">\(Y\)</span> 的循环节。所以 <span
class="math inline">\(|X|\)</span> 和 <span
class="math inline">\(|Y|-|X|\)</span> 都是 <span
class="math inline">\(Y\)</span> 的循环节，根据
<strong>弱周期定理</strong>，<span class="math inline">\(g=\gcd(|X|,
|Y|-|X|)\)</span> 也是 <span class="math inline">\(Y\)</span>
的循环节。</p>
</div>
<h3 id="引理-3">引理 3</h3>
<div class="note no-icon info"><p><strong>引理 3:</strong> 如果 <span
class="math inline">\(X^{\infty}\ne Y^{\infty}\)</span>，那么 <span
class="math inline">\(\operatorname{lcp}(X^{\infty},Y^{\infty})=\operatorname{lcp}(XY,
YX)\)</span>。</p>
</div>
<p>由于 <span class="math inline">\(X^{\infty}\ne
Y^{\infty}\)</span>，由 <strong>引理 1</strong> 可得 <span
class="math inline">\(XY\ne YX\)</span>。不妨设 <span
class="math inline">\(|X|\le |Y|\)</span>。</p>
<p>考虑 <span class="math inline">\(Y\)</span> 是 <span
class="math inline">\(X^{\infty}\)</span> 的前缀的情况。因为 <span
class="math inline">\(Y\)</span> 是 <span
class="math inline">\(X^{\infty}\)</span> 的前缀，所以 <span
class="math inline">\(XY\)</span> 也是 <span
class="math inline">\(X^{\infty}\)</span> 的前缀。又由于 <span
class="math inline">\(|X|\le |Y|\)</span>，所以 <span
class="math inline">\(X\)</span> 也是 <span
class="math inline">\(Y\)</span> 的前缀，然后可以得到 <span
class="math inline">\(YX\)</span> 是 <span
class="math inline">\(Y^2\)</span> 的前缀，继而可以得到 <span
class="math inline">\(YX\)</span> 是 <span
class="math inline">\(Y^{\infty}\)</span> 的前缀。由于我们知道 <span
class="math inline">\(XY\ne YX\)</span>，而 <span
class="math inline">\(|XY|=|YX|\)</span>，所以 <span
class="math inline">\(XY\)</span> 和 <span
class="math inline">\(YX\)</span> 一定会在第 <span
class="math inline">\(|X|+|Y|\)</span> 位或之前比较出结果。而 <span
class="math inline">\(X^{\infty}\)</span> 和 <span
class="math inline">\(Y^{\infty}\)</span>
分别是它们两个的前缀，所以也一定会在同一个位置比较出结果。故 <span
class="math inline">\(\operatorname{lcp}(XY,YX)=\operatorname{lcp}(X^{\infty},Y^{\infty})\)</span>。</p>
<p>然后考虑 <span class="math inline">\(Y\)</span> 不是 <span
class="math inline">\(X^{\infty}\)</span> 的前缀的情况。我们不断把 <span
class="math inline">\(Y\)</span> 开头的 <span
class="math inline">\(X\)</span> 提出来，即找到最大的 <span
class="math inline">\(n\)</span> 使得 <span
class="math inline">\(Y=X^nY&#39;\)</span>，那么此时 <span
class="math inline">\(X\)</span> 不是 <span
class="math inline">\(Y&#39;\)</span> 的前缀。又由于 <span
class="math inline">\(Y=X^nY&#39;\)</span> 不是 <span
class="math inline">\(X^{\infty}\)</span> 的前缀，所以 <span
class="math inline">\(Y&#39;\)</span> 也不是 <span
class="math inline">\(X\)</span> 的前缀。因此 <span
class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y&#39;\)</span> 一定会在第 <span
class="math inline">\(\min(|X|,|Y&#39;|)\)</span>
位前比出结果，用于上面引理 1 类似的方法我们可以得到 <span
class="math inline">\(\operatorname{lcp}(X^{\infty},Y&#39;Y^{\infty})=\operatorname{lcp}(X,Y&#39;)\)</span>，同理可得
<span
class="math inline">\(\operatorname{lcp}(X,Y&#39;)=\operatorname{lcp}(XY&#39;,Y&#39;X)\)</span>。于是：</p>
<p><span class="math display">\[
\begin{aligned}
    &amp;\operatorname{lcp}(X^{\infty},Y^{\infty})\\
    =&amp;\operatorname{lcp}(X^nX^{\infty},X^nY&#39;Y^{\infty})\\
    =&amp;n|X|+\operatorname{lcp}(X^{\infty},Y&#39;Y^{\infty})\\
    =&amp;n|X|+\operatorname{lcp}(XY&#39;,Y&#39;X)\\
    =&amp;\operatorname{lcp}(X^{n+1}Y&#39;,X^nY&#39;X)\\
    =&amp;\operatorname{lcp}(XY,YX)
\end{aligned}
\]</span></p>
<h2 id="参考资料">参考资料</h2>
<div class="note no-icon info"><p><a href="https://www.luogu.com/article/d4y3zqqv"
class="uri">https://www.luogu.com/article/d4y3zqqv</a><br />
<a href="https://atcoder.jp/contests/arc175/editorial/9662"
class="uri">https://atcoder.jp/contests/arc175/editorial/9662</a></p>
</div>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2022 游记</title>
    <url>/post/csp-s-2022-travel/</url>
    <content><![CDATA[<h2 id="section">10.27</h2>
<p>进行了一个试的考，但是一道都不会，<span
class="math inline">\(40pts\)</span> 垫底。被 xy
的满分爆搜打爆了。感觉周二和周四的考试应该 swap 一下。</p>
<p>然后讲题发现前 3 题都好简单。T1 就是爆搜，我太蠢了。改了
T2，对拍出错了，但是第二天发现 A 了。</p>
<h2 id="section-1">10.28</h2>
<p>和 grass8woc，black_trees
竞速了一上午加半个下午的的板子，<del>获得了前</del>三<del>的好成绩</del>，全程拖后腿，没赢过一次。</p>
<p>然后又和他们 VP 了 ARC080，但是我只会前 3 题。（我的 VP 记录在<a
href="/post/arc-080-solution">这里</a>，grass8woc 的 VP 记录在<a
href="https://www.cnblogs.com/Sakurajima-Mai/p/16836914.html">这里</a>，black_trees
的 VP 记录在<a
href="https://hylwxqwq.github.io/rec/arc-vp-record/#arc080">这里</a>）。</p>
<p>晚上玩了 <span class="math inline">\(\frac 34\)</span>
个晚自习，写游记，看了一下 grass8woc 的<del>卷题记录</del>题解。</p>
<h2 id="csp-s-当天">10.29（CSP-S 当天）</h2>
<p>上午睡到 9 点钟哈哈哈，玩了一会去考试。</p>
<p>场上看到 T1 想了一会儿不会很慌，然后发现会了，写完已经 1h。然后开
T2，发现很简单，半个小时写完。然后开 T3。T3
想了一下不会，写了一个乱搞做法，自以为很厉害，然后本来想写对拍，但是 T1
暴力挂了调了好久，于是 T2 没拍。然后 T2 复杂度分析的假了，我还以为能过
65 分。</p>
<p>然后出考场和同学交流，发现 T3 假的，T4 复杂度假了，心态爆炸。然后发现
grass8woc AK 了，然后又发现全世界都会后两题。</p>
<p>这场前两天难度还是比去年高不少，但是后两题比去年简单了。</p>
<p>民间数据 100+100+40+20，挂大分。本来暴力打满 T3 和 T4 可以
60+44，但是却两道题都挂掉。而且这两道题确实都是我见过的套路，以我的能力应该也能做出来？但是没有。</p>
<p>这次可以说也暴露出了许多问题吧，暴力写挂，还有考场上思路不清晰。</p>
<h2 id="section-2">10.30</h2>
<p>今天去问了一下同年级的一些很厉害的人，发现大家都挂了很多分呢，好像挺多人都比我挂得惨。这么想也许会好受点吧？</p>
<p>也幸好这是 CSP 吧，如果是 NOIP
可能就真的寄惨了。还有不到一个月的时间，也许还能再搏一搏？每次考完，都会有许多遗憾，每次都会下定决心以后一定要认真学，不能水过每一天。也许会有许多感触，也许会有不甘心，也许还会有对下次考试的殷勤希望。<strong>但是，随着光阴流转，一切终将归于平静。那时的是晴是雨，也终将没入时间的长河。而当初的决心，在雨水的冲刷下，还能等到天晴的那一天吗……</strong></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>CSP-S2022 题解</title>
    <url>/post/csp-s-2022-solution/</url>
    <content><![CDATA[<p><a href="/post/csp-s-2022-travel">CSP-S2022 游记</a></p>
<h2 id="a.-假期计划holiday">A. 假期计划(holiday)</h2>
<p>首先我们可以跑 <span class="math inline">\(n\)</span> 次
bfs，预处理出哪些景点之间可以转 <span class="math inline">\(k\)</span>
次车到达。</p>
<p>然后我们设路径是 <span class="math inline">\(\text{Home} \to A \to B
\to C \to D \to \text{Home}\)</span>。我们对于每个点 <span
class="math inline">\(X\)</span>，预处理 <span
class="math inline">\(\text{Home} \to Y \to X\)</span> 路径中 <span
class="math inline">\(a_X + a_Y\)</span> 前三大的值，以及此时对应的
<span class="math inline">\(Y\)</span>。然后我们枚举 <span
class="math inline">\(A, B\)</span>，然后暴力 <span
class="math inline">\(3 \times 3\)</span> 枚举 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span>
的前三大。可以证明答案一定在前三大内。</p>
<details class="note no-icon info"><summary><p>考场代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__int128_t</span> Lint;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, K;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> to, nxt; &#125; edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="type">static</span> <span class="type">int</span> k = <span class="number">1</span>; edge[k] = (Edge)&#123;v, head[u]&#125;, head[u] = k++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> st)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[i] = <span class="literal">false</span>, dis[st][i] = INF;</span><br><span class="line">	dis[st][st] = <span class="number">0</span>, vis[st] = <span class="literal">true</span>, q.<span class="built_in">push</span>(st);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = edge[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			dis[st][v] = dis[st][u] + <span class="number">1</span>, vis[v] = <span class="literal">true</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> e[N][N];</span><br><span class="line"><span class="type">int</span> r[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Lint x)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> stk[<span class="number">200</span>]; <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">0</span>) stk[top++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) stk[top++] = x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>, x /= <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span>(top--; top &gt;= <span class="number">0</span>; top--) <span class="built_in">putchar</span>(stk[top]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;holiday.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;holiday.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v); <span class="built_in">add_edge</span>(u, v), <span class="built_in">add_edge</span>(v, u); &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">bfs</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) e[i][j] = (i == j ? <span class="literal">false</span> : dis[i][j] &lt;= K + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(e[<span class="number">1</span>][j] &amp;&amp; e[j][i] &amp;&amp; (r[i][<span class="number">0</span>] == <span class="number">0</span> || a[r[i][<span class="number">0</span>]] &lt; a[j])) r[i][<span class="number">0</span>] = j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(e[<span class="number">1</span>][j] &amp;&amp; e[j][i] &amp;&amp; j != r[i][<span class="number">0</span>] &amp;&amp; (r[i][<span class="number">1</span>] == <span class="number">0</span> || a[r[i][<span class="number">1</span>]] &lt; a[j])) r[i][<span class="number">1</span>] = j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(e[<span class="number">1</span>][j] &amp;&amp; e[j][i] &amp;&amp; j != r[i][<span class="number">0</span>] &amp;&amp; j != r[i][<span class="number">1</span>] &amp;&amp; (r[i][<span class="number">2</span>] == <span class="number">0</span> || a[r[i][<span class="number">2</span>]] &lt; a[j])) r[i][<span class="number">2</span>] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	Lint ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(e[i][j]) &#123;</span><br><span class="line">		<span class="type">int</span> x1 = r[i][<span class="number">0</span>], x2 = r[i][<span class="number">1</span>], y1 = r[j][<span class="number">0</span>], y2 = r[j][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(x1 == j) x1 = r[i][<span class="number">1</span>], x2 = r[i][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x2 == j) x2 = r[i][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span>(y1 == i) y1 = r[j][<span class="number">1</span>], y2 = r[j][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(y2 == i) y2 = r[j][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span>(x1 != y1) &#123;</span><br><span class="line">			<span class="keyword">if</span>(x1 &amp;&amp; y1) ans = std::<span class="built_in">max</span>(ans, (Lint)a[i] + a[j] + a[x1] + a[y1]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(x1 &amp;&amp; y2) ans = std::<span class="built_in">max</span>(ans, (Lint)a[i] + a[j] + a[x1] + a[y2]);</span><br><span class="line">			<span class="keyword">if</span>(x2 &amp;&amp; y1) ans = std::<span class="built_in">max</span>(ans, (Lint)a[i] + a[j] + a[x2] + a[y1]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="b.-策略游戏game">B. 策略游戏(game)</h2>
<p>考虑如果小 L 已经选了一个正数，那么小 Q 一定会选一个最小值；反之则小
Q 一定会选一个最大值。</p>
<p>所以如果小 L 已经决定要选一个正数，那么他相当于已经知道小 Q
会选哪个数了。如果小 Q 将要选的是一个正数，那么小 L
一定会选择最大的正数，否则他会选最小的正数。反过来，如果小 L
已经决定要选一个负数，也是一样的道理。由于最开始的选择权在小
L，所以他一定是在正数和负数的解中取最大的一个。</p>
<p>至于 <span
class="math inline">\(0\)</span>，我们现在一直都没考虑过它，但其实我们可以随便将他归到正数或者负数。</p>
<p>然后就做完了，好水的 T2 啊。</p>
<details class="note no-icon info"><summary><p>考场代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NONE = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ST</span> &#123;</span><br><span class="line">	<span class="type">int</span> lg[N], mn[N][<span class="number">21</span>], mx[N][<span class="number">21</span>];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">calcmin</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x == NONE || y == NONE ? (x == NONE ? y : x) : std::<span class="built_in">min</span>(x, y); &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">calcmax</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x == NONE || y == NONE ? (x == NONE ? y : x) : std::<span class="built_in">max</span>(x, y); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preprocess</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> bd, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">		lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bd; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bd; i++) mn[i][<span class="number">0</span>] = mx[i][<span class="number">0</span>] = (type == <span class="number">2</span> ? arr[i] : (type == <span class="number">1</span> ? (arr[i] &gt;= <span class="number">0</span> ? arr[i] : NONE) : (arr[i] &lt;= <span class="number">0</span> ? arr[i] : NONE)));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= bd; i++) &#123;</span><br><span class="line">				mn[i][j] = <span class="built_in">calcmin</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">				mx[i][j] = <span class="built_in">calcmax</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">calcmin</span>(mn[l][k], mn[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">calcmax</span>(mx[l][k], mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; sta[<span class="number">2</span>], stb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;game.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;game.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">	sta[<span class="number">0</span>].<span class="built_in">preprocess</span>(a, n, <span class="number">0</span>), sta[<span class="number">1</span>].<span class="built_in">preprocess</span>(a, n, <span class="number">1</span>), stb.<span class="built_in">preprocess</span>(b, m, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">		<span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">		<span class="type">int</span> mn2 = stb.<span class="built_in">getmin</span>(l2, r2), mx2 = stb.<span class="built_in">getmax</span>(l2, r2);</span><br><span class="line">		LL ans = -LLINF;</span><br><span class="line">		<span class="keyword">if</span>(mn2 &gt;= <span class="number">0</span> &amp;&amp; sta[<span class="number">1</span>].<span class="built_in">getmax</span>(l1, r1) != NONE) ans = std::<span class="built_in">max</span>(ans, (LL)sta[<span class="number">1</span>].<span class="built_in">getmax</span>(l1, r1) * mn2);</span><br><span class="line">		<span class="keyword">if</span>(mn2 &lt;= <span class="number">0</span> &amp;&amp; sta[<span class="number">1</span>].<span class="built_in">getmin</span>(l1, r1) != NONE) ans = std::<span class="built_in">max</span>(ans, (LL)sta[<span class="number">1</span>].<span class="built_in">getmin</span>(l1, r1) * mn2);</span><br><span class="line">		<span class="keyword">if</span>(mx2 &gt;= <span class="number">0</span> &amp;&amp; sta[<span class="number">0</span>].<span class="built_in">getmax</span>(l1, r1) != NONE) ans = std::<span class="built_in">max</span>(ans, (LL)sta[<span class="number">0</span>].<span class="built_in">getmax</span>(l1, r1) * mx2);</span><br><span class="line">		<span class="keyword">if</span>(mx2 &lt;= <span class="number">0</span> &amp;&amp; sta[<span class="number">0</span>].<span class="built_in">getmin</span>(l1, r1) != NONE) ans = std::<span class="built_in">max</span>(ans, (LL)sta[<span class="number">0</span>].<span class="built_in">getmin</span>(l1, r1) * mx2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="c.-星战galaxy">C. 星战(galaxy)</h2>
<p>首先发现一个结论：输出 <code>YES</code>
当且仅当每个点都有恰好一条出边。</p>
<p>证明也很显然。充分性：对于每个点，我们考虑一直沿着唯一的出边走，那么最坏情况下走
<span class="math inline">\(n - 1\)</span> 条边就能走完 <span
class="math inline">\(n\)</span> 个点（否则一定有重复的点），所以走
<span class="math inline">\(n\)</span>
条边一定能走完所有点，并且会有重复，即出现了环。必要性：根据条件，边数等于
<span
class="math inline">\(n\)</span>，如果有点有多条出边，那么一定会出现有的点没有出边，不符合题意。</p>
<p>然后我们显然可以维护边数，但是怎么维护每个点只有一条出边这个信息呢？根号算法应该是过不了的，难道要用一些
nb 的数据结构？其实不用，我们考虑直接哈希。显然我们只需要有每 <span
class="math inline">\(n\)</span> 条边，而且每个点各一条出边，至于是哪
<span class="math inline">\(n\)</span>
条，我们不关心。所以哈希应该和边无关，我们可以考虑只哈希每条边的起点。然后，这
<span class="math inline">\(n\)</span>
个点的顺序其实也是无关紧要的。这就让我们想到了 XOR Hashing 或者 Sum
Hashing。考虑对于每次操作维护边的起点的
XOR/SUM，但是这样很容易哈希冲突。所以我们给每个点随机赋一个很大的权值，就可以有效避免哈希冲突。这个很好维护。</p>
<p>挺巧妙的一道题。</p>
<details class="note no-icon info"><summary><p>赛后代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> ind[N], d[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">bigrand</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (LL)<span class="built_in">rand</span>() &lt;&lt; <span class="number">31</span> | <span class="built_in">rand</span>(); &#125; <span class="comment">// linux 下 rand() 的范围是 0~2^31-1</span></span><br><span class="line">LL a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;galaxy.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;galaxy.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	cnt = m;</span><br><span class="line">	LL val = <span class="number">0</span>, xor_all = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">bigrand</span>(), xor_all ^= a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v); ind[v]++, b[v] ^= a[u], val ^= a[u]; &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) d[i] = ind[i], c[i] = b[i];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q);</span><br><span class="line">	<span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">		<span class="type">int</span> t, x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), cnt--, d[y]--, val ^= a[x], c[y] ^= a[x];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), cnt -= d[x], d[x] = <span class="number">0</span>, val ^= c[x], c[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">3</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), cnt++, d[y]++, val ^= a[x], c[y] ^= a[x];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">4</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), cnt += ind[x] - d[x], d[x] = ind[x], val ^= b[x] ^ c[x], c[x] = b[x];</span><br><span class="line">		<span class="built_in">puts</span>(cnt == n &amp;&amp; val == xor_all ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="d.-数据传输transmit">D. 数据传输(transmit)</h2>
<p>首先我们考虑哪些点能够出现在答案中。对于一个 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的询问，显然 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span>
路径上的点是有可能出现在答案中的。然后和路径的距离为 <span
class="math inline">\(1\)</span> 的点也是有可能出现在答案中的，这只在
<span class="math inline">\(K = 3\)</span> 时出现，样例 2
就有这种情况。那么和路径距离为 <span class="math inline">\(2\)</span>
或者更大的点有没有可能呢？其实是不可能的，因为如果我们跳到某一个和路径距离为
<span class="math inline">\(2\)</span>
的点，就必须还要跳回来，这样显然不如直接不经过这个点优秀。</p>
<p>所以我们其实可以直接在 <span class="math inline">\(u\)</span> 到
<span class="math inline">\(v\)</span> 的路径上进行 DP：设 <span
class="math inline">\(f(i, j)\)</span> 表示考虑了路径上前 <span
class="math inline">\(i\)</span>
个点，上一台需要计算代价的机器距离当前机器已经 <span
class="math inline">\(j(j &lt; K)\)</span> 根网线了（<span
class="math inline">\(K = 0\)</span>
表示当前机器需要计算代价），传输的最小代价。转移也很显然：</p>
<p><span class="math display">\[
f(i, j) = \min
\begin{cases}
    \min\limits_{0 \le j&#39; &lt; K} \{f(i&#39;, j&#39;)\} + v_i,
&amp;j = 0\\
    f(i&#39;, 1) + v_{son(i)}, &amp;j = 1 \text{ and } K = 3\\
    f(i&#39;, j - 1), &amp;0 &lt; j &lt; K\\
\end{cases}
\]</span></p>
<p>其中 <span class="math inline">\(i&#39;\)</span>
表示路径上的上一个点，<span class="math inline">\(son(u)\)</span> 表示
<span class="math inline">\(u\)</span>
的权值最小的儿子的编号，第二行的转移是跳到了 <span
class="math inline">\(i\)</span> 的一个儿子的情况。</p>
<p>初值就是 <span class="math inline">\(f(0, j) = \begin{cases}0, &amp;j
= K - 1\\+\infty, &amp;0 \le j &lt; K - 1\end{cases}\)</span>，答案是
<span class="math inline">\(f(m, 0)\)</span>。</p>
<p>但是这样是 <span class="math inline">\(O(n^2)\)</span>
的。怎么办呢？虽然说每个询问的链都不一样，但是每个点的转移都是一样的。这让我们想到了矩阵乘法。所以如果我们可以预处理每个点的转移矩阵，那转移相当于是路径乘积。这个可以用倍增解决，不必用树剖。注意矩阵没有交换律，所以需要预处理从上往下乘和从下往上乘。</p>
<p>还有一种例外，就是走到了 <span class="math inline">\(u, v\)</span> 的
<span class="math inline">\(lca\)</span>
的父亲，这个相当于是路径上多了两个点（<span class="math inline">\(\cdots
\times trans_{lca} \times \cdots\)</span> 变成 <span
class="math inline">\(\cdots \times trans_{lca} \times trans_{fa(lca)}
\times trans_{lca} \times \cdots\)</span>），也可以解决。</p>
<p>但是怎么把转移写成矩阵呢？我们发现，式子里要求 <span
class="math inline">\(\min\)</span> 和 <span
class="math inline">\(\operatorname{sum}\)</span>，但是不需要乘积，这是一个套路，我们可以重新定义矩阵乘法，把
<span class="math inline">\(\min\limits_{1 \le j&#39; \le K} \{f(i - 1,
j&#39;)\} + v_i\)</span> 写成 <span class="math inline">\(\min\limits_{1
\le j&#39; \le K} \{f(i - 1, j&#39;) +
v_i\}\)</span>，然后把原来的“乘”定义为加，原来的“加”定义为求 <span
class="math inline">\(\min\)</span>。换句话说就是 <span
class="math inline">\(C = A \times B \iff C_{i, j} =
\min\limits_{k}\{A_{i, k} + B_{k, j}\}\)</span>。</p>
<p>那么我们就可以写出矩阵了：</p>
<p><span class="math inline">\(K = 1\)</span> 时：</p>
<p><span class="math display">\[
\begin{bmatrix}
    f(i&#39;, 0)
\end{bmatrix}
\times
\begin{bmatrix}
    v_i
\end{bmatrix}
=
\begin{bmatrix}
    f(i, 0)
\end{bmatrix}
\]</span></p>
<p><span class="math inline">\(K = 2\)</span> 时：</p>
<p><span class="math display">\[
\begin{bmatrix}
    f(i&#39;, 0) &amp; f(i&#39;, 1)
\end{bmatrix}
\times
\begin{bmatrix}
    v_i &amp; 0       \\
    v_i &amp; +\infty \\
\end{bmatrix}
=
\begin{bmatrix}
    f(i, 0) &amp; f(i, 1)
\end{bmatrix}
\]</span></p>
<p><span class="math inline">\(K = 3\)</span> 时：</p>
<p><span class="math display">\[
\begin{bmatrix}
    f(i&#39;, 0) &amp; f(i&#39;, 1) &amp; f(i&#39;, 2)
\end{bmatrix}
\times
\begin{bmatrix}
    v_i &amp; 0          &amp; +\infty \\
    v_i &amp; v_{son(i)} &amp; 0       \\
    v_i &amp; +\infty    &amp; +\infty \\
\end{bmatrix}
=
\begin{bmatrix}
    f(i, 0) &amp; f(i, 1) &amp; f(i, 2)
\end{bmatrix}
\]</span></p>
<p>然后就做完了，感觉比较板，比 T3 简单。</p>
<p>另外，qiuzx 有<a
href="https://www.luogu.com.cn/blog/qiuzx-ggmu/csp-jian-yao-ti-jie">非矩阵做法</a><del>并且表示出对矩阵做法的唾弃</del>，大家可以去<del>膜拜</del>围观。</p>
<details class="note no-icon info"><summary><p>赛后代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, K, Q;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> to, nxt; &#125; edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="type">static</span> <span class="type">int</span> k = <span class="number">1</span>; edge[k] = (Edge)&#123;v, head[u]&#125;, head[u] = k++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N], dep[N], son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	dep[u] = dep[fa[u]] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = edge[i].nxt) <span class="keyword">if</span>(edge[i].to != fa[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = edge[i].to;</span><br><span class="line">		fa[v] = u;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(!son[u] || a[son[u]] &gt; a[v]) son[u] = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123; LL a[<span class="number">3</span>][<span class="number">3</span>]; &#125; e, initial;</span><br><span class="line"><span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix x, Matrix y)</span> </span>&#123;</span><br><span class="line">	Matrix z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++) z.a[i][j] = LLINF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++) <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; k++) z.a[i][k] = std::<span class="built_in">min</span>(z.a[i][k], x.a[i][j] + y.a[j][k]);</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix trans[N];</span><br><span class="line"></span><br><span class="line">Matrix prod1[N][<span class="number">21</span>], prod2[N][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> go[N][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preprocess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) go[i][<span class="number">0</span>] = fa[i], prod1[i][<span class="number">0</span>] = prod2[i][<span class="number">0</span>] = trans[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			go[i][j] = go[go[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">			prod1[i][j] = <span class="built_in">mul</span>(prod1[i][j - <span class="number">1</span>], prod1[go[i][j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">			prod2[i][j] = <span class="built_in">mul</span>(prod2[go[i][j - <span class="number">1</span>]][j - <span class="number">1</span>], prod2[i][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">	<span class="type">int</span> d = dep[u] - dep[v];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="keyword">if</span>(d &gt;&gt; i &amp; <span class="number">1</span>) u = go[u][i];</span><br><span class="line">	<span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(go[u][i] != go[v][i]) u = go[u][i], v = go[v][i];</span><br><span class="line">	<span class="keyword">return</span> fa[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">multiply1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	Matrix x = e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="keyword">if</span>(d &gt;&gt; i &amp; <span class="number">1</span>) x = <span class="built_in">mul</span>(x, prod1[u][i]), u = go[u][i];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">multiply2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	Matrix x = e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="keyword">if</span>(d &gt;&gt; i &amp; <span class="number">1</span>) x = <span class="built_in">mul</span>(prod2[u][i], x), u = go[u][i];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;transmit.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;transmit.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;Q, &amp;K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v); <span class="built_in">add_edge</span>(u, v), <span class="built_in">add_edge</span>(v, u); &#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++) e.a[i][j] = (i == j ? <span class="number">0</span> : LLINF);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++) initial.a[i][j] = LLINF;</span><br><span class="line">	initial.a[<span class="number">0</span>][K - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++) <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; k++) trans[i].a[j][k] = LLINF;</span><br><span class="line">		trans[i].a[<span class="number">0</span>][<span class="number">0</span>] = a[i];</span><br><span class="line">		<span class="keyword">if</span>(K &gt;= <span class="number">2</span>) trans[i].a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, trans[i].a[<span class="number">1</span>][<span class="number">0</span>] = a[i];</span><br><span class="line">		<span class="keyword">if</span>(K &gt;= <span class="number">3</span>) trans[i].a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>, trans[i].a[<span class="number">2</span>][<span class="number">0</span>] = a[i], trans[i].a[<span class="number">1</span>][<span class="number">1</span>] = (son[i] ? a[son[i]] : LLINF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">preprocess</span>();</span><br><span class="line">	<span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">		<span class="type">int</span> f = <span class="built_in">lca</span>(u, v);</span><br><span class="line">		<span class="type">int</span> du = dep[u] - dep[f] + <span class="number">1</span>, dv = dep[v] - dep[f] + <span class="number">1</span>;</span><br><span class="line">		LL ans = <span class="built_in">mul</span>(initial, <span class="built_in">mul</span>(<span class="built_in">multiply1</span>(u, du), <span class="built_in">multiply2</span>(v, dv - <span class="number">1</span>))).a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span>(fa[f]) ans = std::<span class="built_in">min</span>(ans, <span class="built_in">mul</span>(initial, <span class="built_in">mul</span>(<span class="built_in">multiply1</span>(u, du + <span class="number">1</span>), <span class="built_in">multiply2</span>(v, dv))).a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p><del>啊终于填完坑了</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>动态规划</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 605E Intergalaxy Trips 题解</title>
    <url>/post/codeforces-605e/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<blockquote>
<p>有一张 <span class="math inline">\(n\)</span> 个点的有向完全图，边
<span class="math inline">\(i \to j\)</span> 有 <span
class="math inline">\(p_{i,j}\)</span> 的概率出现（<span
class="math inline">\(p_{i,i}=1\)</span>）。你要从 <span
class="math inline">\(1\)</span>
开始，每天可以走一条出边或留在原地，求最优策略下走到 <span
class="math inline">\(n\)</span> 的期望天数。输出小数（不取模）。<br />
<span class="math inline">\(n \le 10^3\)</span></p>
</blockquote>
<h2 id="思路">思路</h2>
<p>设 <span class="math inline">\(f(i)\)</span> 表示从 <span
class="math inline">\(i\)</span> 走到 <span
class="math inline">\(n\)</span> 的期望天数，那么答案就是 <span
class="math inline">\(f(1)\)</span>。接下来考虑怎么计算 <span
class="math inline">\(f\)</span>。</p>
<p>首先考虑怎么转移 <span class="math inline">\(f\)</span>。<br />
考虑当前我们在 <span class="math inline">\(i\)</span>，下一步要去 <span
class="math inline">\(j(1\le j\le n)\)</span>（<span
class="math inline">\(j\)</span> 可以等于 <span
class="math inline">\(i\)</span>）。因为要算最优方案，所以当我们选择去
<span class="math inline">\(j\)</span> 的时候，一定满足所有优于 <span
class="math inline">\(j\)</span> 的点都没有边。<br />
现在就可以把方程写出来了：</p>
<p><span class="math display">\[
f(i)=1+\sum_{j=1}^n f(j)p_{i,j}\prod_{1\le k\le
n}^{f(k)&lt;f(j)}(1-p_{i,k})
\]</span></p>
<p>但是这个式子需要依赖已经计算好的 <span
class="math inline">\(f\)</span>，所以还是没法做。<br />
我们观察发现，由于 <span
class="math inline">\(p_{i,i}=1\)</span>，所以对于所有满足 <span
class="math inline">\(f(j)&gt;f(i)\)</span> 的 <span
class="math inline">\(j\)</span>，后面的那个 <span
class="math inline">\(\prod_{1\le k\le
n}^{f(k)&lt;f(j)}(1-p_{i,k})\)</span> 一定会包含 <span
class="math inline">\(k=i\)</span> 的一项，也就是 <span
class="math inline">\(1-p_{i,i}=0\)</span>。换句话说，这样的 <span
class="math inline">\(j\)</span> 一定对 <span
class="math inline">\(i\)</span> 没有贡献。<br />
其实还有另一种解释，因为我们总是可以原地停留的，所以我们不可能从 <span
class="math inline">\(f\)</span> 较小的走向 <span
class="math inline">\(f\)</span>
较大的，这样明显不如原地停留优秀。<br />
所以，<span class="math inline">\(f\)</span>
总是会从较小的往较大的转移。也就是说，把原地停留的情况移项过后，<strong><span
class="math inline">\(f\)</span> 的转移就是一个 DAG</strong>。</p>
<p>先把移项过后的式子写出来：</p>
<p><span class="math display">\[
f(i)=\frac{1+\sum_{1\le j\le n}^{f(j)&lt;f(i)} f(j)p_{i,j}\prod_{1\le
k\le n}^{f(k)&lt;f(j)}(1-p_{i,k})}{1-\prod_{1\le j\le
n}^{f(j)&lt;f(i)}(1-p_{i,j})}
\]</span></p>
<p>现在考虑怎么找出 DAG 的形态。<br />
首先 <span class="math inline">\(f(n)=0\)</span> 肯定是最小的 <span
class="math inline">\(f\)</span>。然后我们用 <span
class="math inline">\(f(n)\)</span> 去转移其它的点（也就是作为式子里的
<span class="math inline">\(j\)</span>）。这个时候每个点都有一个当前的
<span class="math inline">\(f\)</span>（仅考虑 <span
class="math inline">\(u \to n\)</span> 的边计算得来的 <span
class="math inline">\(f\)</span>）了。我们把当前的 <span
class="math inline">\(f\)</span> 记为 <span
class="math inline">\(f&#39;\)</span>。<br />
考虑这些 <span class="math inline">\(f&#39;\)</span>
中最小的那一个，假设是 <span
class="math inline">\(f&#39;(i)\)</span>。可以证明，此时 <span
class="math inline">\(f(i)=f&#39;(i)\)</span>（证明在下面）。所以这时我们就算出了
<span class="math inline">\(f(i)\)</span>。然后继续用 <span
class="math inline">\(f(i)\)</span>
去转移其它的点，然后再在剩下的点里面找出当前 <span
class="math inline">\(f\)</span> 最小的，假设是 <span
class="math inline">\(f&#39;&#39;(k)\)</span>。按照类似的证明我们知道
<span
class="math inline">\(f&#39;&#39;(k)=f(k)\)</span>。以此类推，就可以找出
DAG 形态并算出答案了。总复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>现在我们证明 <span
class="math inline">\(f(i)=f&#39;(i)\)</span>。（对于其它的也类似）<br />
首先发现一个性质，对于任意时刻的 <span
class="math inline">\(f&#39;\)</span> 来说（不只是最终答案的 <span
class="math inline">\(f\)</span>），如果用 <span
class="math inline">\(f&#39;(j)\)</span> 转移到 <span
class="math inline">\(f&#39;(i)\)</span>，那么一定满足 <span
class="math inline">\(f&#39;(i)\ge f&#39;(j)\)</span>。因为我们是从
<span class="math inline">\(i\)</span> 走到 <span
class="math inline">\(j\)</span> 的，那 <span
class="math inline">\(i\)</span> 的步数肯定要多一步，所以不可能比 <span
class="math inline">\(j\)</span> 小。严谨证明就是如果 <span
class="math inline">\(f&#39;(j) \ge f&#39;(i)\)</span>，那么可以继续用
<span class="math inline">\(i\)</span> 去转移到 <span
class="math inline">\(j\)</span>，这样 <span
class="math inline">\(f&#39;(i)\)</span> 和 <span
class="math inline">\(f&#39;(j)\)</span>
就会要么越来越小，要么相等。如果相等那么结论得证；如果越来越小那么显然矛盾。<br />
然后就很简单了，因为 <span class="math inline">\(f&#39;(i)\)</span> 是除
<span
class="math inline">\(f(n)\)</span>（或者那些已经转移过其它点的点）以外最小的，而比
<span class="math inline">\(f&#39;(i)\)</span> 小的已经转移到 <span
class="math inline">\(i\)</span> 过了，所以不可能有其它的点转移到 <span
class="math inline">\(i\)</span> 使 <span
class="math inline">\(f&#39;(i)\)</span> 更小了。如果让 <span
class="math inline">\(f&#39;(i)\)</span> 更大显然是不优的，所以 <span
class="math inline">\(f&#39;(i) = f(i)\)</span>。</p>
<h2 id="代码">代码</h2>
<p>代码其实很好写。</p>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> p[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> f[N], g[N], h[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> done[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">int</span> j, <span class="type">int</span> i)</span> </span>&#123; g[i] += p[i][j] * f[j] * h[i], h[i] *= <span class="number">1</span> - p[i][j], f[i] = g[i] / (<span class="number">1</span> - h[i]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123; <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); p[i][j] = x / <span class="number">100.0</span>; &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = g[i] = h[i] = <span class="number">1</span>;</span><br><span class="line">	done[n] = <span class="literal">true</span>, f[n] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!done[i]) <span class="built_in">trans</span>(n, i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> _ = <span class="number">2</span>; _ &lt;= n; _++) &#123;</span><br><span class="line">		<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">		<span class="type">double</span> val = <span class="number">1e18</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!done[i] &amp;&amp; f[i] &lt; val) now = i, val = f[i];</span><br><span class="line">		done[now] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!done[i]) <span class="built_in">trans</span>(now, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, f[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="参考资料">参考资料</h2>
<details class="note no-icon info"><summary><p>参考资料</p>
</summary>
<p><a href="https://www.luogu.com.cn/blog/SDNetFriend/solution-cf605e"
class="uri">https://www.luogu.com.cn/blog/SDNetFriend/solution-cf605e</a><br />
<a href="https://www.luogu.com.cn/blog/LCA/solution-cf605e"
class="uri">https://www.luogu.com.cn/blog/LCA/solution-cf605e</a><br />
<a href="https://www.luogu.com.cn/blog/user33243/solution-cf605e"
class="uri">https://www.luogu.com.cn/blog/user33243/solution-cf605e</a><br />
<a href="https://codeforces.com/blog/entry/22019"
class="uri">https://codeforces.com/blog/entry/22019</a></p>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>动态规划</tag>
        <tag>思维</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 814E An unavoidable detour for home 题解</title>
    <url>/post/codeforces-814e/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p><a
href="https://codeforces.com/problemset/problem/814/E">题目链接</a></p>
<p>（洛谷翻译）</p>
<ul>
<li>给出 <span class="math inline">\(n\)</span> 个点，和每个点的度 <span
class="math inline">\(d_i\)</span>
让你构造出一张无向图满足以下两条性质：
<ul>
<li>点 <span class="math inline">\(1\)</span> 到点 <span
class="math inline">\(i\)</span> 仅有 <strong>唯一</strong>
一条最短路。</li>
<li>点 <span class="math inline">\(1\)</span> 到点 <span
class="math inline">\(i\)</span> 的最短路长度大于等于点 <span
class="math inline">\(1\)</span> 到点 <span
class="math inline">\(i-1\)</span> 的最短路长度。</li>
</ul></li>
<li>求能构成满足条件的无向图的个数？</li>
<li><span class="math inline">\(n \leq 50\)</span>，<span
class="math inline">\(2 \leq d_i \leq 3\)</span>。</li>
<li>这篇题解提供了 <span class="math inline">\(n \le 1000\)</span>
的做法（时间复杂度 <span
class="math inline">\(O(n^3)\)</span>，空间复杂度 <span
class="math inline">\(O(n^2)\)</span>）。</li>
</ul>
<h2 id="思路">思路</h2>
<p>设 <span class="math inline">\(d_i\)</span> 表示 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(i\)</span> 的最短路，那么根据题意 <span
class="math inline">\(d_i\)</span>
一定是单调不降的。那么我们容易想到分层图，显然同一层的点的编号一定是连续的。因为这个是最短路，所以每个点（除了
<span
class="math inline">\(1\)</span>）一定会有一条边连向上一层，并且不可能有连向两层以前的边。又因为最短路唯一，所以一定是恰好一条边连向上一层。然后发现同层之间也可以任意连边。</p>
<p>因为 <span class="math inline">\(2\sim n\)</span>
的点一定要向前面连一条边，所以我们不考虑它，也就是讲 <span
class="math inline">\(2\sim n\)</span>
的度数减去一。现在我们认为所有点的度数为 <span class="math inline">\([1,
2]\)</span>。</p>
<p>然后容易想到 DP。设 <span class="math inline">\(f(i, j)\)</span>
表示考虑了点 <span class="math inline">\(1 \sim i\)</span>，<span
class="math inline">\(i\)</span> 刚好是一层的结束，第 <span
class="math inline">\(i\)</span> 层有 <span
class="math inline">\(j\)</span> 条边连向下一层的方案数。那么转移显然是
<span class="math inline">\(f(i + j, k) \leftarrow f(i, j) + g(c_1, c_2,
k)\)</span>。其中 <span class="math inline">\(c_1,c_2\)</span> 分别表示
<span class="math inline">\((i, i + j]\)</span> 中度数为 <span
class="math inline">\(1,2\)</span> 的点的个数；<span
class="math inline">\(g(c_1, c_2, k)\)</span> 表示分别有 <span
class="math inline">\(c_1,c_2\)</span> 个度数为 <span
class="math inline">\(1, 2\)</span> 的点，并且在内部连边之后剩下了 <span
class="math inline">\(k\)</span> 条边（连到下一层）。</p>
<p>现在的问题是 <span class="math inline">\(g(c_1, c_2, k)\)</span>
怎么转移。显然我们有一个空间为 <span
class="math inline">\(O(n^3)\)</span>
的做法，就是考虑某一个点的连边方案来转移，这里不详细展开了。但是我们想要一个空间为
<span class="math inline">\(O(n^2)\)</span> 的做法，这迫使我们抛弃 DP
的想法，使用组合方式计算。</p>
<p>首先考虑 <span class="math inline">\(c_2=k=0\)</span>，也就是 <span
class="math inline">\(c_1\)</span> 个点两两配对的方案数。设其为 <span
class="math inline">\(u(i)\)</span>（<span
class="math inline">\(i\)</span> 为偶数），那么显然 <span
class="math inline">\(u(i) = u(i - 2) \cdot (i - 1)\)</span>，容易得到
<span class="math inline">\(u(i) = (i - 1)\times (i - 3)\times \cdots
\times 3\times 1 = (i - 1)!!\)</span>。</p>
<p>然后考虑加上 <span
class="math inline">\(c_2\)</span>。首先有一个想法是把一个度数为 <span
class="math inline">\(2\)</span> 的点拆成两个，记为 <span
class="math inline">\(i_1, i_2\)</span>，并记 <span
class="math inline">\(i \leftrightarrow j\)</span> 表示 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 连边。但是这样会有问题三个问题：</p>
<ul>
<li><span class="math inline">\(i_1 \leftrightarrow
i_2\)</span>，下面称为自环；</li>
<li><span class="math inline">\(i_1 \leftrightarrow
j_1,i_2\leftrightarrow j_2\)</span>（或者 <span
class="math inline">\(i_1\leftrightarrow j_2,i_2\leftrightarrow
j_1\)</span>），以下称为重边；</li>
<li>我们拆出来的两个点实际上是同一个，所以 <span
class="math inline">\(i_1\leftrightarrow j,i_2\leftrightarrow k\)</span>
和 <span class="math inline">\(i_1\leftrightarrow k,i_2\leftrightarrow
j\)</span> 是一样的，所以要乘 <span class="math inline">\(\frac
12\)</span>，但是我们并不知道要乘多少 <span class="math inline">\(\frac
12\)</span>。</li>
</ul>
<p>首先考虑解决第三个问题。假设分别和 <span class="math inline">\(i_1,
i_2\)</span> 连边的点为 <span
class="math inline">\(j,k\)</span>。我们发现一共会有三种情况：</p>
<ul>
<li><span class="math inline">\(j,k\)</span> 都和 <span
class="math inline">\(i\)</span> 在同一层；</li>
<li><span class="math inline">\(j\)</span> 和 <span
class="math inline">\(i\)</span> 在同一层，<span
class="math inline">\(k\)</span> 连到下一层（或者对称的，<span
class="math inline">\(k\)</span> 和 <span
class="math inline">\(i\)</span> 在同一层，<span
class="math inline">\(j\)</span> 连到下一层）；</li>
<li><span class="math inline">\(j,k\)</span> 都连到下一层。</li>
</ul>
<p>我们发现不管是哪种情况，我们会重复计算 <span
class="math inline">\(i_1\leftrightarrow j,i_2\leftrightarrow k\)</span>
和 <span class="math inline">\(i_1\leftrightarrow k,i_2\leftrightarrow
j\)</span>，所以都需要乘上 <span class="math inline">\(\frac
12\)</span>。所以其实我们只需要整体乘上 <span
class="math inline">\(\left(\frac 12\right)^{c_2}\)</span>
而不需要管具体哪些是同层的。</p>
<p>然后解决前两个问题。我们发现这个可以容斥解决。我们枚举 <span
class="math inline">\(r\)</span> 表示钦定 <strong>自环和重边加起来一共有
<span class="math inline">\(r\)</span>
个</strong>，其中自环是一个点拆出来的一对点算一个，重边是两个点拆出来的两对点算一个。然后再枚举
<span class="math inline">\(i\le r\)</span> 表示重边的个数，然后令 <span
class="math inline">\(j=r-i\)</span>
表示自环的个数。那么此时我们一共钦定的点数为 <span
class="math inline">\(2i+j=r+i\)</span>（未拆点之前），拆点之后未被钦定的点数为
<span
class="math inline">\(p=c_1+2(c_2-(2i+j))\)</span>。那么式子应该是：</p>
<p><span class="math display">\[
g(c_1, c_2, 0) =
\frac{1}{2^{c_2}}\sum_{r=0}^{c_2}(-1)^r\sum_{\substack{i+j=r\\p=c_1+2(c_2-(2i+j))}}\binom{c_2}{2i+j}\binom{2i+j}{j}(p-1)!!(2i-1)!!2^i
\]</span></p>
<p>然后我们加上 <span
class="math inline">\(k\)</span>。这个很简单，就是先选 <span
class="math inline">\(k\)</span>
个点出来再套用刚才的式子。注意要乘上一个 <span
class="math inline">\(k!\)</span>。式子如下：</p>
<p><span class="math display">\[
g(c_1, c_2, k) =
\frac{k!}{2^{c_2}}\sum_{r=0}^{c_2}(-1)^r\sum_{\substack{i+j=r\\p=c_1+2(c_2-(2i+j))}}\binom{c_2}{2i+j}\binom{p}{k}\binom{2i+j}{j}(p-k-1)!!(2i-1)!!2^i
\]</span></p>
<p>考虑把这个式子化的好看一点。我们交换枚举顺序，先枚举 <span
class="math inline">\(x=2i+j=r+i\)</span>，再枚举 <span
class="math inline">\(i\le\lfloor\frac x2 \rfloor\)</span>，那么 <span
class="math inline">\(p=c_1+2(c_2-x)\)</span>。式子如下：</p>
<p><span class="math display">\[
g(c_1, c_2, k) =
\frac{k!}{2^{c_2}}\sum_{x=0}^{c_2}\binom{c_2}{x}\binom{p}{k}(p-k-1)!!\boxed{\sum_{\substack{0\le
i\le\lfloor x/2 \rfloor\\j=x-2i}}(-1)^{i+j}\binom{x}{j}(2i-1)!!2^i}
\]</span></p>
<p>我们发现框起来的部分只和 <span class="math inline">\(x\)</span>
有关，我们可以预处理它，并记为 <span
class="math inline">\(h(x)\)</span>。</p>
<p>然后现在我们把这个式子代回 <span class="math inline">\(f\)</span>
的转移：</p>
<p><span class="math display">\[
f(i+j, k)\leftarrow
f(i,j)\frac{k!}{2^{c_2}}\sum_{x=0}^{c_2}\binom{p}{k}(p-k-1)!!\binom{c_2}{x}h(x)
\]</span></p>
<p>化一下可以得：</p>
<p><span class="math display">\[
f(i+j,k)\leftarrow
\boxed{\frac{k!}{2^{c_2}}\binom{p}{k}(p-k-1)!!}f(i,j)\sum_{x=0}^{c_2}\binom{c_2}{x}h(x)
\]</span></p>
<p>容易发现框起来的部分只和 <span class="math inline">\(p,k\)</span>
相关，而剩下部分都和 <span class="math inline">\(p,k\)</span>
无关。所以我们可以分步转移：</p>
<p><span class="math display">\[
g(i+j,p=c_1+2(c_2-x))\leftarrow f(i,j)\sum_{x=0}^{c_2}\binom{c_2}{x}h(x)
\]</span></p>
<p><span class="math display">\[
f(i,k)\leftarrow \frac{k!}{2^{c_2}}\binom{p}{k}(p-k-1)!!g(i, p)
\]</span></p>
<p>然后就做完了。时间复杂度 <span
class="math inline">\(O(n^3)\)</span>，空间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">LL fac[<span class="number">2</span> * N], invfac[<span class="number">2</span> * N];</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL x, LL y)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % MOD; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % MOD; &#125; &#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, MOD - <span class="number">2</span>); &#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> fac[x] * invfac[y] % MOD * invfac[x - y] % MOD; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_factorial</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">	invfac[mx] = <span class="built_in">inv</span>(fac[mx]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = mx; i &gt;= <span class="number">1</span>; i--) invfac[i - <span class="number">1</span>] = invfac[i] * i % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL match[<span class="number">2</span> * N], f[N][N], g[N][<span class="number">2</span> * N], h[<span class="number">2</span> * N];</span><br><span class="line">LL powerinv2[N], power2[N];</span><br><span class="line"><span class="type">int</span> pre[<span class="number">3</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) a[i]--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[<span class="number">1</span>][i] = pre[<span class="number">1</span>][i - <span class="number">1</span>] + (a[i] == <span class="number">1</span>), pre[<span class="number">2</span>][i] = pre[<span class="number">2</span>][i - <span class="number">1</span>] + (a[i] == <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">get_factorial</span>(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">	powerinv2[<span class="number">0</span>] = <span class="number">1</span>, power2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) powerinv2[i] = powerinv2[i - <span class="number">1</span>] * <span class="built_in">inv</span>(<span class="number">2</span>) % MOD, power2[i] = power2[i - <span class="number">1</span>] * <span class="number">2</span> % MOD;</span><br><span class="line">	match[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n + <span class="number">2</span>; i += <span class="number">2</span>) match[i] = match[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % MOD;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">2</span> * n + <span class="number">1</span>; x++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x / <span class="number">2</span>; i++)</span><br><span class="line">			(h[x] += (((x - i) &amp; <span class="number">1</span>) ? MOD - <span class="number">1</span> : <span class="number">1</span>) * <span class="built_in">C</span>(x, <span class="number">2</span> * i) % MOD * match[<span class="number">2</span> * i] % MOD * power2[i]) %= MOD;</span><br><span class="line">	<span class="comment">// for(int i = 0; i &lt;= 2 * n + 1; i++) printf(&quot;h[%d] = %lld\n&quot;, i, h[i]);</span></span><br><span class="line">	f[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">2</span> * i + <span class="number">1</span>; p++) <span class="keyword">if</span>(g[i][p])</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = (p &amp; <span class="number">1</span>); k &lt;= std::<span class="built_in">min</span>(p, n - i); k++)</span><br><span class="line">				(f[i][k] += g[i][p] * <span class="built_in">C</span>(p, k) % MOD * match[p - k] % MOD * fac[k]) %= MOD;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - i; j++) <span class="keyword">if</span>(f[i][j]) &#123;</span><br><span class="line">			<span class="type">int</span> c1 = pre[<span class="number">1</span>][i + j] - pre[<span class="number">1</span>][i], c2 = pre[<span class="number">2</span>][i + j] - pre[<span class="number">2</span>][i];</span><br><span class="line">			<span class="comment">// printf(&quot;i = %d, j = %d, c1 = %d, c2 = %d\n&quot;, i, j, c1, c2);</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt;= c2; x++) &#123;</span><br><span class="line">				<span class="type">int</span> p = c1 + <span class="number">2</span> * (c2 - x);</span><br><span class="line">				<span class="comment">// printf(&quot;    x = %d, p = %d\n&quot;, x, p);</span></span><br><span class="line">				(g[i + j][p] += f[i][j] * powerinv2[c2] % MOD * <span class="built_in">C</span>(c2, x) % MOD * h[x]) %= MOD;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= n; i++)  &#123;</span></span><br><span class="line">	<span class="comment">// 	for(int j = 0; j &lt;= 2 * n + 1; j++) if(g[i][j]) printf(&quot;g[%d][%d] = %lld\n&quot;, i, j, g[i][j]);</span></span><br><span class="line">	<span class="comment">// 	for(int j = 0; j &lt;= n - i; j++) if(f[i][j]) printf(&quot;f[%d][%d] = %lld\n&quot;, i, j, f[i][j]);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>「Jack 的钻石」题解</title>
    <url>/post/jacks-diamond/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p><a href="https://www.luogu.com.cn/problem/U168149">题目</a></p>
<p>有 <span class="math inline">\(n\)</span>
名黑帮成员，为了方便，分别编号为 <span class="math inline">\(1\)</span>
到 <span class="math inline">\(n\)</span>。并且假设老大编号为 <span
class="math inline">\(n\)</span>。开始，Jack
老大应把战利品拿出来给大家过目，并提出一个分配方案，然后所有 <span
class="math inline">\(n\)</span>
名成员（含自己）分别表示赞同或不赞同，如果不赞同的成员比例严格大于一半，那么根据规矩，老大
Jack 就会被处理掉，由编号为 <span class="math inline">\(n-1\)</span>
的成员维任，并依照同样的过程继续分配刚才的战利品，否则这个分配过程就完成了。在黑帮团伙中成员们的目的都比较单纯，所有成员首先要保住自己的性命，在能保住性命的前提下，当然要拿尽可能多的钻石:
一旦在当前这个方案里，他拿到的钻石数不大于之后所有情况下可能拿到的最大钻石数，那么他就会反对当前分配方案，否则支持。</p>
<p>这个黑帮是一一个理性的黑帮（不然早就被端掉了），因此你可以认为所有成员都是无穷阶理性的，也就是说每个人都知道其他人也拥有与自己相同的想法，在任意步过后也同样追求最优解，并且计算上不会出错。</p>
<p>Jack 老大在尝试制定不同的分配原则，因此有时他要求自己必须要分配到至少
<span class="math inline">\(1\)</span>
个，而有时不需要，现在他想知道为了满足分配规则和保住他的性命，钻石至少要有多少个。</p>
<h2 id="思路">思路</h2>
<p>记最小需要的钻石为 <span class="math inline">\(D\)</span>。<br />
分别对 <span class="math inline">\(S = 0\)</span> 和 <span
class="math inline">\(S = 1\)</span> 进行讨论。</p>
<h3 id="对于-s-1">对于 S = 1</h3>
<p>首先对于 <span class="math inline">\(n = 1\)</span> 和 <span
class="math inline">\(n = 2\)</span> ，<span class="math inline">\(D =
1\)</span>，即给 Jack 自己。</p>
<p>然后对于 <span class="math inline">\(n = 3\)</span> 时，因为就算 Jack
被杀，<span class="math inline">\(2\)</span> 号也可以存活，所以 <span
class="math inline">\(1\)</span> 号和 <span
class="math inline">\(2\)</span> 号都反对。所以 Jack 必须拿出一个钻石给
<span class="math inline">\(1\)</span> 号（因为 <span
class="math inline">\(2\)</span> 号在 Jack 被杀后也可以拿到 <span
class="math inline">\(1\)</span> 个钻石）</p>
<p>以此类推，<span class="math inline">\(n = 4\)</span> 时需要给 <span
class="math inline">\(2\)</span> 号和 <span
class="math inline">\(4\)</span> 号。</p>
<p>综上，<span class="math inline">\(n\)</span> 个人时需要给所有的 <span
class="math inline">\(x (x \equiv n \pmod 2)\)</span>，即给所有编号与
<span class="math inline">\(n\)</span> 奇偶性相同的人。所以答案为 <span
class="math inline">\(\lceil \frac n2 \rceil\)</span>。</p>
<h3 id="对于-s-0">对于 S = 0</h3>
<p>首先对于 <span class="math inline">\(n = 1\)</span> 和 <span
class="math inline">\(n = 2\)</span>，<span class="math inline">\(D =
0\)</span>。</p>
<p>然后我们考虑什么情况下 <span class="math inline">\(D =
0\)</span>。</p>
<ul>
<li>在 <span class="math inline">\(n = 3\)</span> 时 <span
class="math inline">\(D = 0\)</span> 是不行的，因为此时只有 Jack
一个人投票。<br />
</li>
<li>在 <span class="math inline">\(n = 4\)</span> 时，<span
class="math inline">\(3\)</span> 号会投票，因为当 Jack 死后就会变成
<span class="math inline">\(n = 3\)</span> 的情况，而此时上面算过 <span
class="math inline">\(3\)</span> 号必死。此时 <span
class="math inline">\(D = 0\)</span> 时 Jack 可以活下来。<br />
</li>
<li>在 <span class="math inline">\(n = 5\)</span> 时，只有 Jack
会投票。<br />
</li>
<li>在 <span class="math inline">\(n = 6\)</span> 时，<span
class="math inline">\(5, 6\)</span> 号会投票。<br />
</li>
<li>在 <span class="math inline">\(n = 7\)</span> 时，<span
class="math inline">\(5,6,7\)</span> 号会投票，因为 <span
class="math inline">\(6,7\)</span> 号都死后 <span
class="math inline">\(5\)</span> 还是必死。<br />
</li>
<li>在 <span class="math inline">\(n = 8\)</span> 时，<span
class="math inline">\(5,6,7,8\)</span> 号会投票，Jack 存活。</li>
</ul>
<p>所以，<span class="math inline">\(i\)</span> 号会投票当且仅当 <span
class="math inline">\(i = n\)</span> 或 <strong>人数在 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(n\)</span> 之间时提出方案的人都必死</strong>。</p>
<p>根据这个，容易得出当 <span class="math inline">\(n = 2^k\)</span> 时
Jack 可以存活。</p>
<p>那么，对于不是 <span class="math inline">\(2\)</span> 的正整数次幂的
<span class="math inline">\(n\)</span>，就只有用钻石让 Jack 活下来。</p>
<p>对于 <span class="math inline">\(n = 2^k + 2m (k, m \in \mathbb
Z^+)\)</span>，<span class="math inline">\(2^k\)</span>
部分不需要任何钻石，而 <span class="math inline">\(2m\)</span>
部分每两个人需要一个钻石让其中一个人投票，所以 <span
class="math inline">\(D = m\)</span>。</p>
<p>现在的任务就是找最小的 <span class="math inline">\(m\)</span> 使得
<span class="math inline">\(n = 2^k + 2m\)</span>。</p>
<p>当 <span class="math inline">\(n\)</span> 为偶数时，<span
class="math inline">\(m_{min} = \frac{n - highbit(n)}{2}\)</span>。其中
<span class="math inline">\(highbit(x)\)</span> 表示 <span
class="math inline">\(x\)</span> 最高的二进制位的位权（即最大的 <span
class="math inline">\(2^k\)</span>）</p>
<p>当 <span class="math inline">\(n\)</span> 为奇数时，因为 <span
class="math inline">\(2m\)</span> 是偶数，所以只有让 <span
class="math inline">\(2^k\)</span> 为奇数，那么 <span
class="math inline">\(k = 0\)</span>，所以 <span class="math inline">\(m
= \frac{n - 1}{2}\)</span>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">highbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(x &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="type">int</span> n, t;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (n + <span class="number">1</span>) / <span class="number">2</span>); <span class="comment">// A1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (n &amp; <span class="number">1</span>) ? (n - <span class="number">1</span>) / <span class="number">2</span> : (n - <span class="built_in">highbit</span>(n)) / <span class="number">2</span>); <span class="comment">// A2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 详解</title>
    <url>/post/kmp/</url>
    <content><![CDATA[<h2 id="引入">引入</h2>
<blockquote>
<p>什么是 KMP？</p>
</blockquote>
<p>KMP 是一种 <span class="math inline">\(O(n)\)</span> 求解一个字符串
<span class="math inline">\(t\)</span> （模式串）在另一个字符串 <span
class="math inline">\(s\)</span> （主串）中
<strong>所有</strong> 出现的地方和总次数。</p>
<blockquote>
<p>KMP 有什么用？</p>
</blockquote>
<p>可以解决很多关于子串的问题。</p>
<div class="note info"><p>以下使用 <span class="math inline">\(s[l .. r]\)</span> 表示 <span
class="math inline">\(s_ls_{l + 1}\cdots s_r\)</span>。</p>
</div>
<h2 id="思路">思路</h2>
<h3 id="暴力算法">暴力算法</h3>
<p>首先考虑暴力算法：</p>
<blockquote>
<p>枚举 <span class="math inline">\(i \in [1, n]\)</span>，比较 <span
class="math inline">\(t[i .. i + len(m) - 1]\)</span> 和 <span
class="math inline">\(s\)</span>。<br />
时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
</blockquote>
<p>过程：</p>
<img data-src="/post/kmp/%E6%9A%B4%E5%8A%9B.gif" class="" title="暴力算法">
<p>那么为什么暴力这么慢呢？<br />
问题出在两个地方：</p>
<ol type="1">
<li>每一个位置都要比较</li>
<li>字符串需要 <span class="math inline">\(O(n)\)</span> 比较</li>
</ol>
<p>第二个基本上没法优化了（因为字符串比较真的需要 <span
class="math inline">\(O(n)\)</span>），但第一个可以优化。<br />
我们只需要不让每一个位置都需要比较就好了。</p>
<p>于是我们就得到 KMP 的核心思想。</p>
<h3 id="kmp-思想">KMP 思想</h3>
<p>我们在暴力匹配时除了匹配成功与失败，还有
<strong>别的有用信息</strong> 吗？<br />
答案是有的。</p>
<p>除了没有匹配成功以外，我们还可以得到
<strong>有多少个字符的前缀是可以匹配的</strong>。</p>
<p>例如：</p>
<img data-src="/post/kmp/%E6%9C%89%E7%94%A8%E4%BF%A1%E6%81%AF%E4%B8%BE%E4%BE%8B.png" class="" title="有用信息举例">
<p>那么知道了这些信息有什么用呢？<br />
我们可以
<strong>将一些情况排除</strong>，也就是跳过从某些位置开始匹配的步骤！</p>
<p>具体的：</p>
<img data-src="/post/kmp/KMP%E6%80%9D%E6%83%B31.gif" class="" title="KMP 思想 1">
<p>再看一个例子：</p>
<img data-src="/post/kmp/KMP%E6%80%9D%E6%83%B32.gif" class="" title="KMP 思想 2">
<p>当我们发现已知的字符串可以匹配主串前几位时，就可以计算出下一步直接移动到哪里，跳过一些情况。<br />
这就是 <span class="math inline">\(next\)</span> 数组！</p>
<h3 id="next-数组">next 数组</h3>
<h4 id="next-定义">next 定义</h4>
<p><span class="math inline">\(next(i)\)</span> 表示在 <span
class="math inline">\(t[1 .. i]\)</span> 中，满足 <span
class="math inline">\(t[1 .. x] = t[i - x + 1 .. i]\)</span> 且 <span
class="math inline">\(x &lt; i\)</span> 的最大的 <span
class="math inline">\(x\)</span>。（这里是对模式串做匹配哦）</p>
<div class="note info"><p><span class="math inline">\(s\)</span> 是主串，<span
class="math inline">\(t\)</span> 是模式串。</p>
</div>
<h4 id="next-用法">next 用法</h4>
<p>求出了 next 数组如何求出答案呢？</p>
<p>考虑一个字符串：</p>
<img data-src="/post/kmp/%E7%94%A8%E6%B3%951.png" class="" title="字符串 1">
<p>那么它的 next 如下：</p>
<img data-src="/post/kmp/%E7%94%A8%E6%B3%952.png" class="" title="字符串 2">
<p>这个 next 有什么用呢？看下图：</p>
<img data-src="/post/kmp/%E7%94%A8%E6%B3%953.png" class="" title="字符串 3">
<p>我们发现，每次向后移动是将 <strong>能匹配上的字符串</strong> 的
<strong>长度为 <span class="math inline">\(next(i)\)</span>
的前缀后缀</strong> 对齐。<br />
也即：如果模式串 <span class="math inline">\(t\)</span> 的前 <span
class="math inline">\(i\)</span> 个字符能匹配上，那么将模式串向后移动
<span class="math inline">\(i - next(i)\)</span> 个字符，匹配下标从
<span class="math inline">\(i - next(i)\)</span> 移动到 <span
class="math inline">\(next(i)\)</span>。（见下图）</p>
<img data-src="/post/kmp/%E7%94%A8%E6%B3%954.png" class="" title="字符串 4">
<h4 id="next-求法">next 求法</h4>
<p>采用 DP 思想：现在已经求出了 <span class="math inline">\(next(1 .. i
- 1)\)</span>，如何求 <span class="math inline">\(next(i)\)</span>？</p>
<p>对于下面字符串：</p>
<img data-src="/post/kmp/%E8%BD%AC%E7%A7%BB1.png" class="" title="转移 1">
<p>第一种情况，向后一个字符（图中蓝色）也相同，直接转移即可。</p>
<img data-src="/post/kmp/%E8%BD%AC%E7%A7%BB2.png" class="" title="转移 2">
<p>第二种情况，向后一个字符（图中红色）不同。</p>
<img data-src="/post/kmp/%E8%BD%AC%E7%A7%BB3.png" class="" title="转移 3">
<p>怎么办呢？<br />
这时就要退而求其次，也就是说我们要取一个比 <span
class="math inline">\(next(i - 1)\)</span> 更小一点的 <span
class="math inline">\(x\)</span> 使得 <span class="math inline">\(t[1 ..
x] = t[i - x + 1 .. i]\)</span>。<br />
直接上结论：取 <span class="math inline">\(x = next(next(i -
1))\)</span></p>
<img data-src="/post/kmp/%E8%BD%AC%E7%A7%BB4.png" class="" title="转移 4">
<p>原因：<br />
由 <span class="math inline">\(next(i - 1)\)</span>
（红色）得③处相等，而由 <span class="math inline">\(next(next(i -
1))\)</span> （绿色）得①处相等。<br />
①和③放在一起推得①②的四个字符串都相等，所以得到 <span
class="math inline">\(t[1 .. x] = t[i - x + 1 .. i]\)</span>。</p>
<h3 id="复杂度">复杂度</h3>
<p>容易发现 <span class="math inline">\(j\)</span> 的增量不超过 <span
class="math inline">\(n\)</span> （见代码），所以它的减少量也不超过
<span class="math inline">\(n\)</span>，所以总复杂度 <span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *t, vector&lt;<span class="type">int</span>&gt; &amp;ans)</span> </span>&#123; <span class="comment">// s, t 下标从 1 开始</span></span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 如果下标从 0 开始，那么这里应该是 next[0] = -1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; t[j + <span class="number">1</span>] != t[i]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span>(t[j + <span class="number">1</span>] == t[i]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; t[j + <span class="number">1</span>] != s[i]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span>(t[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == m) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i - m + <span class="number">1</span>);</span><br><span class="line">            j = next[j]; <span class="comment">// 匹配结束之后也要继续匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题">例题</h2>
<details class="note no-icon info"><summary><p><a href="https://www.luogu.com.cn/problem/P3375">洛谷 P3375</a></p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">	n = std::<span class="built_in">strlen</span>(s + <span class="number">1</span>), m = std::<span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">	nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> j = nxt[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span>(t[j + <span class="number">1</span>] != t[i] &amp;&amp; j != <span class="number">-1</span>) j = nxt[j];</span><br><span class="line">		nxt[i] = j + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; t[j + <span class="number">1</span>] != s[i]) j = nxt[j];</span><br><span class="line">		<span class="keyword">if</span>(t[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">		<span class="keyword">if</span>(j == m) &#123;</span><br><span class="line">			std::<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - m + <span class="number">1</span>);</span><br><span class="line">			j = nxt[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) std::<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nxt[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ 6479 [ICPC World Finals 2017] 小小水管工 Son of Pipe Stream 题解</title>
    <url>/post/loj-6479/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p><a href="https://loj.ac/p/6479">原题链接</a></p>
<ul>
<li>给出 <span class="math inline">\(n\)</span> 个城市和 <span
class="math inline">\(m\)</span> 条双向管道，以及两个实数 <span
class="math inline">\(v\)</span> 和 <span
class="math inline">\(a\)</span>。有两种液体，分别是水和
Flubber（下面简写为 W 和 F）。<span class="math inline">\(1\)</span>
号和 <span class="math inline">\(2\)</span> 号城市分别生产 Flubber
和水，并通过管道流入 <span class="math inline">\(3\)</span>
号城市。对于一条管道，其中可以同时存在两种液体，但是方向必须相同。每条管道有一个容量
<span class="math inline">\(c_i\)</span>，如果一条管道中有 <span
class="math inline">\(w\)</span> 个单位的水和 <span
class="math inline">\(f\)</span> 个单位的 Flubber，那么需要满足 <span
class="math inline">\(v\cdot f + w \le c_i\)</span>。记最终流到 <span
class="math inline">\(3\)</span> 号城市的水和 Flubber 分别为 <span
class="math inline">\(W\)</span> 和 <span
class="math inline">\(F\)</span>，求 <span
class="math inline">\(F^a\cdot W^{1-a}\)</span>
的最大值，并给出任意一个方案。</li>
<li><span class="math inline">\(n \le 200\)</span>，<span
class="math inline">\(n - 1 \le m \le \frac{n(n - 1)}{2}\)</span>，<span
class="math inline">\(1\le v,c_i\le 10\)</span>，<span
class="math inline">\(0.01\le a\le 0.99\)</span>。</li>
</ul>
<p><a
href="https://www.csc.kth.se/~austrin/icpc/finals2017solutions.pdf">英文题解</a></p>
<h2 id="做法">做法</h2>
<p>首先 <span class="math inline">\(v\)</span>
是没有用的，因为我们可以把所有的 Flubber 都乘上 <span
class="math inline">\(v\)</span>，最后把答案除以 <span
class="math inline">\(v^a\)</span>，这样就把 <span
class="math inline">\(v\)</span> 去掉了。</p>
<p>考虑如果我们不区分两种液体（即两个源点都可以产出两种液体），那么这就是一个普通最大流。设此时的流量为
<span class="math inline">\(Z\)</span>。</p>
<p>现在考虑区分两种液体怎么做。<br />
设两种液体的流量分别为 <span class="math inline">\(F\)</span> 和 <span
class="math inline">\(W\)</span>，那么容易发现 <span
class="math inline">\(F+W\le Z\)</span>。那是不是 <span
class="math inline">\(F\)</span> 的取值范围就是 <span
class="math inline">\([0, Z]\)</span> 呢？<br />
很容易发现这是错的。假设我们只保留 Flubber，设此时的最大流为 <span
class="math inline">\(F_{\max}\)</span>，类似地定义 <span
class="math inline">\(W_{\max}\)</span>，那么容易发现 <span
class="math inline">\(F\)</span> 的取值范围其实应该是 <span
class="math inline">\([Z-W_{\max},F_{\max}]\)</span>。</p>
<p>接下来就是人类智慧。感性理解一下我们能够发现，似乎对于任意一个 <span
class="math inline">\(F\in [Z-W_{\max},
F_{\max}]\)</span>，都存在一种方案使得 <span
class="math inline">\(F+W=Z\)</span>（我们先不考虑 Flubber
和水的方向不能相同的限制）。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>我们任取一个 <span class="math inline">\(F=F_{\max}\)</span>
的方案，记为 <span class="math inline">\(\overrightarrow
f\)</span>；然后任取一个 <span class="math inline">\(W=W_{\max}\)</span>
的方案，记为 <span class="math inline">\(\overrightarrow
w\)</span>。<br />
因为在 <span class="math inline">\(\overrightarrow f\)</span> 中 <span
class="math inline">\(F=F_{\max}\)</span>，而在 <span
class="math inline">\(\overrightarrow w\)</span> 中 <span
class="math inline">\(F=Z-W_{\max}\)</span>，而我们知道 <span
class="math inline">\(F\in[Z-W_{\max},
F_{\max}]\)</span>，所以必然存在实数 <span
class="math inline">\(\alpha\in[0,1]\)</span> 使得 <span
class="math inline">\(\alpha F_{\max} + (1-\alpha)(Z-W_{\max}) =
F\)</span>，那么此时 <span class="math inline">\(\alpha\overrightarrow
f+(1-\alpha)\overrightarrow w\)</span> 就是流量为 <span
class="math inline">\(F\)</span> 的一个方案。</p>

</details>
<p>现在问题转化为，对于任意 <span class="math inline">\(F\)</span> 满足
<span class="math inline">\(F\in[Z-W_{\max}, F_{\max}]\)</span>，求
<span class="math inline">\(F^a\cdot (Z-F)^{1-a}\)</span>
的最大值。简单求导发现应该取 <span class="math inline">\(F=a\cdot
Z\)</span>。如果 <span class="math inline">\(a\cdot Z\)</span> 不在
<span class="math inline">\([Z-W_{\max}, F_{\max}]\)</span>
内，就取区间内离 <span class="math inline">\(a\cdot Z\)</span>
最近的点就好了。记这个点为 <span
class="math inline">\(F^*\)</span>，并记 <span
class="math inline">\(Z-F^*=W^*\)</span>。</p>
<details class="note info"><summary><p>求导过程</p>
</summary>
<p>记 <span class="math inline">\(G(F) =
F^a(Z-F)^{1-a}\)</span>，那么</p>
<p><span class="math display">\[
\begin{aligned}
     &amp;G&#39;(F)\\
    =&amp;(F^a(Z-F)^{1-a})&#39;\\
    =&amp;(F^a)&#39;\cdot (Z-F)^{1-a}+((Z-F)^{1-a})&#39;\cdot F^a\\
    =&amp;aF^{a-1}(Z-F)^{1-a}+(a-1)(Z-F)^{-a}F^a\\
    =&amp;F^{a-1}(Z-F)^{-a}(a(Z-F)+(a-1)F)\\
    =&amp;F^{a-1}(Z-F)^{-a}(aZ-F)
\end{aligned}
\]</span></p>
<p>因为 <span class="math inline">\(G(F)\)</span>
在定义域内连续，所以极值点即为所有 <span
class="math inline">\(G&#39;(F)=0\)</span> 的点，即 <span
class="math inline">\(0,Z,aZ\)</span> 三个点。代入原式发现 <span
class="math inline">\(0,Z\)</span> 都是最小值，所以最大值就是 <span
class="math inline">\(F=aZ\)</span>。</p>

</details>
<p>现在答案已经求出来了，但是还要构造方案。注意到我们一直没考虑水和
Flubber
的方向不能相反的限制，但其实这不影响，只要我们最终构造出来的方案满足这个限制就行了。<br />
求方案其实也比较简单。首先我们给 <span class="math inline">\(1\)</span>
号点限制 <span class="math inline">\(F^*\)</span> 的流量，给 <span
class="math inline">\(2\)</span> 号点限制 <span
class="math inline">\(W^*\)</span>
的流量，跑一个最大流，这样可以求出最优解中每条边的方向和总流量。但是我们没法把
Flubber 和水区分开。<br />
于是我们建一个新的图，点还是原图的点，但是边的方向和流量为最优解中这条边的方向和流量。那么这个图其实本来就是一个最大流。然后我们
<strong>只</strong> 给 <span class="math inline">\(1\)</span> 号点 <span
class="math inline">\(F^*\)</span> 的流量，那么此时的最大流就是 Flubber
的方案。这样会不会导致水的方案出问题呢？其实不会，因为一个合法流减去它的子流还是一个合法流。而且这个方案也满足水和
Flubber 的方向不能相反的限制。</p>
<p>那么这道题就做完了，感觉难点在于这个结论和找方案。</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N * N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FLOW_N = N + <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FLOW_M = N * N * <span class="number">2</span> + N + <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> FINF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GraphEdge</span> &#123; <span class="type">int</span> u, v; <span class="type">double</span> w; &#125; e[M];</span><br><span class="line"><span class="type">double</span> fe[M];</span><br><span class="line"><span class="type">double</span> V, A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> to, nxt; <span class="type">double</span> r; &#125; edge[FLOW_M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> head[FLOW_N], cur[FLOW_N], ek;</span><br><span class="line">	<span class="type">int</span> n, s, t;</span><br><span class="line">	<span class="type">int</span> dep[FLOW_N];</span><br><span class="line">	std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add_one_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">double</span> c)</span> </span>&#123; edge[ek] = (Edge)&#123;v, head[u], c&#125;, head[u] = ek++; &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dep[i] = <span class="number">0</span>;</span><br><span class="line">		dep[s] = <span class="number">1</span>, q.<span class="built_in">push</span>(s);</span><br><span class="line">		<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = edge[i].nxt) <span class="keyword">if</span>(!dep[edge[i].to] &amp;&amp; edge[i].r &gt; eps) &#123;</span><br><span class="line">				<span class="type">int</span> v = edge[i].to;</span><br><span class="line">				dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dep[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">double</span> in)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u == t) <span class="keyword">return</span> in;</span><br><span class="line">		<span class="type">double</span> out = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i = cur[u]; i; i = edge[i].nxt) <span class="keyword">if</span>(dep[u] + <span class="number">1</span> == dep[edge[i].to] &amp;&amp; edge[i].r &gt; eps) &#123;</span><br><span class="line">			<span class="type">int</span> v = edge[i].to;</span><br><span class="line">			<span class="type">double</span> ret = <span class="built_in">dfs</span>(v, std::<span class="built_in">min</span>(in, edge[i].r));</span><br><span class="line">			<span class="keyword">if</span>(ret &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">			edge[i].r -= ret, edge[i ^ <span class="number">1</span>].r += ret;</span><br><span class="line">			in -= ret, out += ret;</span><br><span class="line">			<span class="keyword">if</span>(in &lt; eps) <span class="keyword">return</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(out &lt; eps) dep[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Dinic</span>() : <span class="built_in">ek</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_)</span> </span>&#123; n = n_; ek = <span class="number">2</span>; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) head[i] = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">double</span> c)</span> </span>&#123; <span class="built_in">add_one_edge</span>(u, v, c), <span class="built_in">add_one_edge</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">maxflow</span><span class="params">(<span class="type">int</span> s_, <span class="type">int</span> t_)</span> </span>&#123;</span><br><span class="line">		s = s_, t = t_;</span><br><span class="line">		<span class="type">double</span> ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = head[i];</span><br><span class="line">			ret += <span class="built_in">dfs</span>(s, FINF);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; dinic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf%lf&quot;</span>, &amp;n, &amp;m, &amp;V, &amp;A);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);</span><br><span class="line">	<span class="type">int</span> src = n + <span class="number">1</span>, dst = n + <span class="number">2</span>;</span><br><span class="line">	dinic.<span class="built_in">init</span>(n + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dinic.<span class="built_in">add_edge</span>(e[i].u, e[i].v, e[i].w), dinic.<span class="built_in">add_edge</span>(e[i].v, e[i].u, e[i].w);</span><br><span class="line">	dinic.<span class="built_in">add_edge</span>(src, <span class="number">2</span>, FINF), dinic.<span class="built_in">add_edge</span>(src, <span class="number">1</span>, FINF), dinic.<span class="built_in">add_edge</span>(<span class="number">3</span>, dst, FINF);</span><br><span class="line">	<span class="type">double</span> flow = dinic.<span class="built_in">maxflow</span>(src, dst);</span><br><span class="line">	dinic.<span class="built_in">init</span>(n + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dinic.<span class="built_in">add_edge</span>(e[i].u, e[i].v, e[i].w), dinic.<span class="built_in">add_edge</span>(e[i].v, e[i].u, e[i].w);</span><br><span class="line">	dinic.<span class="built_in">add_edge</span>(src, <span class="number">1</span>, FINF), dinic.<span class="built_in">add_edge</span>(<span class="number">3</span>, dst, FINF);</span><br><span class="line">	<span class="type">double</span> Fmax = dinic.<span class="built_in">maxflow</span>(src, dst);</span><br><span class="line">	dinic.<span class="built_in">init</span>(n + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dinic.<span class="built_in">add_edge</span>(e[i].u, e[i].v, e[i].w), dinic.<span class="built_in">add_edge</span>(e[i].v, e[i].u, e[i].w);</span><br><span class="line">	dinic.<span class="built_in">add_edge</span>(src, <span class="number">2</span>, FINF), dinic.<span class="built_in">add_edge</span>(<span class="number">3</span>, dst, FINF);</span><br><span class="line">	<span class="type">double</span> Wmax = dinic.<span class="built_in">maxflow</span>(src, dst);</span><br><span class="line">	<span class="type">double</span> F = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(A * flow, Fmax), flow - Wmax);</span><br><span class="line">	<span class="type">double</span> W = flow - F;</span><br><span class="line">	<span class="comment">// printf(&quot;flow = %.3f, Fmax = %.3f, Wmax = %.3f, F = %.3f\n&quot;, flow, Fmax, Wmax, F);</span></span><br><span class="line">	dinic.<span class="built_in">init</span>(n + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dinic.<span class="built_in">add_edge</span>(e[i].u, e[i].v, e[i].w), dinic.<span class="built_in">add_edge</span>(e[i].v, e[i].u, e[i].w);</span><br><span class="line">	dinic.<span class="built_in">add_edge</span>(src, <span class="number">2</span>, W), dinic.<span class="built_in">add_edge</span>(src, <span class="number">1</span>, F), dinic.<span class="built_in">add_edge</span>(<span class="number">3</span>, dst, FINF);</span><br><span class="line">	<span class="type">double</span> ff1 = dinic.<span class="built_in">maxflow</span>(src, dst);</span><br><span class="line">	<span class="built_in">assert</span>(std::<span class="built_in">abs</span>(ff1 - flow) &lt;= eps);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">4</span> * m + <span class="number">1</span>; i += <span class="number">4</span>) fe[(i + <span class="number">2</span>) / <span class="number">4</span>] = dinic.edge[i ^ <span class="number">1</span>].r - dinic.edge[(i + <span class="number">2</span>) ^ <span class="number">1</span>].r;</span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= m; i++) printf(&quot;(%d, %d) %.4f\n&quot;, e[i].u, e[i].v, fe[i]);</span></span><br><span class="line">	dinic.<span class="built_in">init</span>(n + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dinic.<span class="built_in">add_edge</span>(e[i].u, e[i].v, std::<span class="built_in">max</span>(fe[i], <span class="number">0.</span>)), dinic.<span class="built_in">add_edge</span>(e[i].v, e[i].u, std::<span class="built_in">max</span>(-fe[i], <span class="number">0.</span>));</span><br><span class="line">	dinic.<span class="built_in">add_edge</span>(src, <span class="number">1</span>, F), dinic.<span class="built_in">add_edge</span>(<span class="number">3</span>, dst, FINF);</span><br><span class="line">	<span class="type">double</span> ff2 = dinic.<span class="built_in">maxflow</span>(src, dst);</span><br><span class="line">	<span class="comment">// printf(&quot;ff = %.3f\n&quot;, ff2);</span></span><br><span class="line">	<span class="built_in">assert</span>(std::<span class="built_in">abs</span>(ff2 - F) &lt;= eps);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">4</span> * m + <span class="number">1</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="type">double</span> f = dinic.edge[i ^ <span class="number">1</span>].r - dinic.edge[(i + <span class="number">2</span>) ^ <span class="number">1</span>].r;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.11f %.11f\n&quot;</span>, f / V, fe[(i + <span class="number">2</span>) / <span class="number">4</span>] - f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.11f\n&quot;</span>, <span class="built_in">pow</span>(F / V, A) * <span class="built_in">pow</span>(flow - F, <span class="number">1</span> - A));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<details class="note no-icon info"><summary><p>参考资料</p>
</summary>
<p><a
href="https://www.csc.kth.se/~austrin/icpc/finals2017solutions.pdf"
class="uri">https://www.csc.kth.se/~austrin/icpc/finals2017solutions.pdf</a><br />
<a href="https://cekavis.github.io/icpc-world-finals-2017/"
class="uri">https://cekavis.github.io/icpc-world-finals-2017/</a></p>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>LibreOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>TopCoder 12792 BitwiseAnd 题解</title>
    <url>/post/topcoder-12792/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p><a
href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=12792">原题链接</a></p>
<p>给 <span class="math inline">\(m\)</span> 个数 <span
class="math inline">\(\{ori_i\}\)</span>，让你添加 <span
class="math inline">\(n - m\)</span> 个数（设这一共 <span
class="math inline">\(n\)</span> 个数为 <span
class="math inline">\(\{a_i\}\)</span>），使得：</p>
<ol type="1">
<li><span class="math inline">\(\forall 1 \le i, j \le n,~a_i
\operatorname{bitand} a_j \ne 0\)</span></li>
<li><span class="math inline">\(\forall 1 \le i, j, k \le n,~a_i
\operatorname{bitand} a_j \operatorname{bitand} a_k = 0\)</span></li>
</ol>
<p>求字典序最小的 <span
class="math inline">\(\{a_i\}\)</span>，或者判断无解。</p>
<h2 id="做法">做法</h2>
<p>先转成二进制，然后条件就等价于对于每一个二进制位， <strong><span
class="math inline">\(\{a_i\}\)</span> 中这一位是 <span
class="math inline">\(1\)</span> 的不超过 <span
class="math inline">\(2\)</span> 个</strong>。（不满足就无解，我们把
<strong><span class="math inline">\(a_i\)</span> 中这一位是 <span
class="math inline">\(1\)</span></strong> 记为 <strong>这一位在 <span
class="math inline">\(a_i\)</span> 中出现</strong>）</p>
<p>那么我们将 <span class="math inline">\(a\)</span> 的前 <span
class="math inline">\(m\)</span> 个设为 <span
class="math inline">\(ori\)</span>，后面先设为 <span
class="math inline">\(0\)</span>。</p>
<p>枚举 <span class="math inline">\(i, j (1 \le i &lt; j \le
n)\)</span>（都按从小到大的顺序），然后强制令 <span
class="math inline">\(a_i \operatorname{bitand} a_j \ne
0\)</span>。具体如下：</p>
<ul>
<li>如果 <span class="math inline">\(a_i \operatorname{bitand}
a_j\)</span> 已经不为 <span
class="math inline">\(0\)</span>，就不考虑下面的了。</li>
<li>如果 <span class="math inline">\(i \le m\)</span> 且 <span
class="math inline">\(j \le
m\)</span>，那么无解。（因为都修改不了）</li>
<li>如果 <span class="math inline">\(i \le m\)</span>，那么 <span
class="math inline">\(a_i\)</span> 修改不了，只有从 <span
class="math inline">\(a_j\)</span>
下手。如果有二进制位只出现过一次（且这一次是在 <span
class="math inline">\(a_i\)</span> 中出现），那么可以让这一位在 <span
class="math inline">\(a_j\)</span>
也出现一次。如果有多个这样的二进制位，取最小的。（因为要字典序最小）</li>
<li>否则（<span class="math inline">\(i &gt; m, j &gt;
m\)</span>）分两种情况：
<ul>
<li>如果有二进制位只出现过一次（且这一次是在 <span
class="math inline">\(a_i\)</span> 处出现），那么让它在 <span
class="math inline">\(a_j\)</span>
中出现。多个取最小。（因为要字典序最小）</li>
<li>否则，取以下两种情况中 <span class="math inline">\(a_i\)</span>
较小的：
<ul>
<li>如果有二进制位只在 <span class="math inline">\(a_j\)</span>
中出现，那么让它在 <span class="math inline">\(a_i\)</span>
中出现。多个取最小。</li>
<li>如果有一个二进制位没有出现过，那么让它在 <span
class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(b_i\)</span> 中都出现。</li>
</ul></li>
</ul></li>
</ul>
<details class="note no-icon info"><summary><p>看不懂？伪代码版解释。</p>
</summary>
<p>将只在 <span class="math inline">\(a_i\)</span> 处出现一次的最小的
<span class="math inline">\(k\)</span> 记为 <span
class="math inline">\(occur(a_i)\)</span>（如果没有就是 <span
class="math inline">\(-1\)</span>）。<br />
将没有出现过的最小的 <span class="math inline">\(k\)</span> 记为 <span
class="math inline">\(occur_{min}\)</span>（如果没有就是 <span
class="math inline">\(-1\)</span>）。<br />
<span class="math inline">\(\operatorname{bitand}\)</span>
是二进制下的按位与，<span class="math inline">\(\textbf{and}\)</span>
是逻辑与（就是 <strong>且</strong>）。</p>
<p><span class="math display">\[
\begin{array}{ll}
1  &amp;  \textbf{if } a_i \operatorname{bitand} b_i \ne 0&amp;\\
2  &amp;  \qquad \text{Skip.}&amp;\\
3  &amp;  \textbf{elif } i \le m \textbf{ and } j \le m&amp;\\
4  &amp;  \qquad \text{No Solution.}&amp;\\
5  &amp;  \textbf{elif } i \le m&amp;\\
6  &amp;  \qquad \textbf{if } occur(a_i) = -1&amp;\\
7  &amp;  \qquad \qquad \text{No Solution.}&amp;\\
8  &amp;  \qquad a_j \gets a_j \operatorname{bitor}
2^{occur(a_i)}&amp;\\
9  &amp;  \textbf{else}&amp;\\
10 &amp;  \qquad \textbf{if } occur(a_i) \ne -1&amp;\\
11 &amp;  \qquad \qquad a_j \gets a_j \operatorname{bitor}
2^{occur(a_i)}&amp;\\
12 &amp;  \qquad \textbf{else}&amp;\\
13 &amp;  \qquad \qquad id \gets +\infty&amp;\\
14 &amp;  \qquad \qquad \textbf{if } occur(a_j) \ne -1&amp;\\
15 &amp;  \qquad \qquad \qquad id \gets \min\left\{id,
occur(a_j)\right\}&amp;\\
16 &amp;  \qquad \qquad \textbf{if } occur_{min} \ne -1&amp;\\
17 &amp;  \qquad \qquad \qquad id \gets \min\left\{id,
occur_{min}\right\}&amp;\\
18 &amp;  \qquad \qquad \textbf{if } id = +\infty&amp;\\
19 &amp;  \qquad \qquad \qquad \text{No Solution.}&amp;\\
20 &amp;  \qquad \qquad a_i \gets a_i \operatorname{bitor} 2^{id}&amp;\\
21 &amp;  \qquad \qquad a_j \gets a_j \operatorname{bitor} 2^{id}&amp;\\
\end{array}
\]</span></p>

</details>
<p>证明不难（贪心），<del>当作业</del>。</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> edge[N][N];</span><br><span class="line"><span class="type">int</span> used[<span class="number">70</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; to[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nw_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) <span class="keyword">if</span>(!used[i]) <span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitwiseAnd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">vector&lt;LL&gt; <span class="title">lexSmallest</span><span class="params">(vector&lt;LL&gt; st, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> m = st.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans[i] = st[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">60</span>; j++) <span class="keyword">if</span>(st[i - <span class="number">1</span>] &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!used[j]) used[j] = i;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(used[j] != <span class="number">-1</span>) edge[i][used[j]] = edge[used[j]][i] = <span class="literal">true</span>, used[j] = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">59</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(used[i] &gt; <span class="number">0</span>) to[used[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(!edge[i][j]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i &lt;= m &amp;&amp; j &lt;= m) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(i &lt;= m) &#123;</span><br><span class="line">					<span class="keyword">if</span>(to[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">					<span class="type">int</span> id = to[i].<span class="built_in">back</span>();</span><br><span class="line">					to[i].<span class="built_in">pop_back</span>();</span><br><span class="line">					ans[j] |= <span class="number">1LL</span> &lt;&lt; id;</span><br><span class="line">					used[id] = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="type">int</span> id;</span><br><span class="line">					<span class="keyword">if</span>(!to[i].<span class="built_in">empty</span>()) id = to[i].<span class="built_in">back</span>(), to[i].<span class="built_in">pop_back</span>();</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						id = <span class="number">100</span>;</span><br><span class="line">						<span class="keyword">if</span>(to[i].<span class="built_in">empty</span>() &amp;&amp; to[j].<span class="built_in">empty</span>()) id = std::<span class="built_in">min</span>(id, <span class="built_in">nw_id</span>());</span><br><span class="line">						<span class="keyword">if</span>(!to[j].<span class="built_in">empty</span>()) id = std::<span class="built_in">min</span>(id, to[j].<span class="built_in">back</span>()), to[j].<span class="built_in">pop_back</span>();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(id == <span class="number">-1</span> || id == <span class="number">100</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">					ans[i] |= <span class="number">1LL</span> &lt;&lt; id, ans[j] |= <span class="number">1LL</span> &lt;&lt; id;</span><br><span class="line">					used[id] = <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">auto</span> v = <span class="built_in">vector</span>&lt;LL&gt;(ans + <span class="number">1</span>, ans + n + <span class="number">1</span>);</span><br><span class="line">		std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>TopCoder</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>TopCoder 12875 PalindromeMatrix 题解</title>
    <url>/post/topcoder-12875/</url>
    <content><![CDATA[<div class="note no-icon info"><p><a
href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=12875">本题链接</a><br />
本题与 <a
href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=12876">TopCoder
12876 PalindromeMatrixDiv2</a> 是同一道题。</p>
</div>
<h2 id="题意">题意</h2>
<p>给一个 <span class="math inline">\(n \times m\)</span> 的 <span
class="math inline">\(01\)</span>
矩阵，求至少将多少个格子取反才能使得至少有 <span
class="math inline">\(r\)</span> 行和 <span
class="math inline">\(c\)</span> 列是回文串。<br />
<span class="math inline">\(2 \le n, m \le 14\)</span>，<span
class="math inline">\(0 \le r \le n\)</span>，<span
class="math inline">\(0 \le c \le m\)</span></p>
<h2 id="做法">做法</h2>
<p>首先枚举有哪些行是回文串，然后考虑对列进行 DP。</p>
<p>容易发现一列一列地转移是不好转移的（因为你在考虑前面的时候无法知道后面填什么），所以考虑两列两列地转移。</p>
<p>设在当前枚举的条件下（有一些行是回文的情况下），</p>
<ul>
<li><span class="math inline">\(cost(i, j)\)</span> 表示 <strong>第
<span class="math inline">\(i\)</span> 列和第 <span
class="math inline">\(m - i + 1\)</span> 列中有 <span
class="math inline">\(j\)</span> 列是回文的最小代价</strong>（其中 <span
class="math inline">\(0 \le j \le 2\)</span>）</li>
<li><span class="math inline">\(f(i, j)\)</span> 表示 <strong>前 <span
class="math inline">\(i\)</span> 列和后 <span
class="math inline">\(i\)</span> 列一共有 <span
class="math inline">\(j\)</span> 列是回文的最小代价</strong>。</li>
</ul>
<p>那么 <span class="math inline">\(f(i, j) = \min_{0 \le k \le 2}
\left\{f(i - 1, j - k) + cost(i, k)\right\}\)</span>。现在的问题是怎么算
<span class="math inline">\(cost\)</span>。</p>
<p>容易发现 <span class="math inline">\(s\)</span> 是否回文只与
<strong><span class="math inline">\(s_i\)</span> 是否等于 <span
class="math inline">\(s_{n - i + 1}\)</span></strong>
有关，所以在一个串中我们只用考虑 <span class="math inline">\(\frac
n2\)</span>
组对应字符内部的相等关系，而组与组之间是相互独立的。类似的，在一个矩阵中我们也只需要考虑
<span class="math inline">\(\frac{nm}{4}\)</span> 组内部的关系。</p>
<p>所以我们枚举 <span class="math inline">\(i, j (1 \le i \le \frac n2,
1 \le j \le \frac m2)\)</span>，然后枚举 <span class="math inline">\((i,
j)\)</span> 这一组里 <span class="math inline">\(4\)</span>
个格子每一个的状态，然后维护到对应的 <span
class="math inline">\(cost\)</span> 里就好了。</p>
<h2 id="细节">细节</h2>
<p>在算 <span class="math inline">\(cost\)</span> 时，由于
<strong>左边是回文</strong> 和 <strong>右边是回文</strong> 都是 <span
class="math inline">\(cost(i, 1)\)</span>，所以 <strong>可能</strong>
会出问题（看具体写法），可以考虑将其分开，状态变成 <span
class="math inline">\(cost(i, 0/1/2/3)\)</span></p>
<p>另外，在维护到 <span class="math inline">\(cost\)</span>
时，有一些细节，不过样例能查出来，留给读者自己调试。</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">14</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N], cost[N][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chkmin</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(y &lt; x) x = y; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PalindromeMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">minChange</span><span class="params">(vector&lt;string&gt; A, <span class="type">int</span> rowCount, <span class="type">int</span> columnCount)</span> </span>&#123;</span><br><span class="line">		n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[i][j] = A[i - <span class="number">1</span>][j - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="type">int</span> U = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> ans = INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= U; s++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(__builtin_popcount(s) &lt; rowCount) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">memset</span>(cost, <span class="number">0</span>, <span class="built_in">sizeof</span>(cost));</span><br><span class="line">			<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m / <span class="number">2</span>; j++) &#123;</span><br><span class="line">					<span class="type">int</span> i_ = n - i + <span class="number">1</span>, j_ = m - j + <span class="number">1</span>;</span><br><span class="line">					<span class="type">int</span> ri = s &gt;&gt; (i - <span class="number">1</span>) &amp; <span class="number">1</span>, ri_ = s &gt;&gt; (i_ - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">					<span class="type">int</span> tmp[<span class="number">5</span>] = &#123;INF, INF, INF, INF&#125;;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">16</span>; t++) &#123;</span><br><span class="line">						<span class="type">int</span> x = t &amp; <span class="number">1</span>, y = t &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>, z = t &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>, w = t &gt;&gt; <span class="number">3</span> &amp; <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">if</span>(ri &amp;&amp; (x != y)) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="keyword">if</span>(ri_ &amp;&amp; (z != w)) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="built_in">chkmin</span>(tmp[(x == z) | ((y == w) &lt;&lt; <span class="number">1</span>)], (x != a[i][j]) + (y != a[i][j_]) + (z != a[i_][j]) + (w != a[i_][j_]));</span><br><span class="line">						<span class="built_in">chkmin</span>(tmp[((y == w) &lt;&lt; <span class="number">1</span>)], (x != a[i][j]) + (y != a[i][j_]) + (z != a[i_][j]) + (w != a[i_][j_]));</span><br><span class="line">						<span class="built_in">chkmin</span>(tmp[(x == z)], (x != a[i][j]) + (y != a[i][j_]) + (z != a[i_][j]) + (w != a[i_][j_]));</span><br><span class="line">						<span class="built_in">chkmin</span>(tmp[<span class="number">0</span>], (x != a[i][j]) + (y != a[i][j_]) + (z != a[i_][j]) + (w != a[i_][j_]));</span><br><span class="line">					&#125;</span><br><span class="line">					cost[j][<span class="number">0</span>] += tmp[<span class="number">0</span>], cost[j][<span class="number">1</span>] += tmp[<span class="number">1</span>], cost[j][<span class="number">2</span>] += tmp[<span class="number">2</span>], cost[j][<span class="number">3</span>] += tmp[<span class="number">3</span>];</span><br><span class="line">					<span class="built_in">chkmin</span>(cost[j][<span class="number">0</span>], INF), <span class="built_in">chkmin</span>(cost[j][<span class="number">1</span>], INF), <span class="built_in">chkmin</span>(cost[j][<span class="number">2</span>], INF), <span class="built_in">chkmin</span>(cost[j][<span class="number">3</span>], INF);</span><br><span class="line">				&#125;</span><br><span class="line">			f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m / <span class="number">2</span>; i++) <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = __builtin_popcount(k); j &lt;= m; j++) <span class="built_in">chkmin</span>(f[i][j], f[i - <span class="number">1</span>][j - __builtin_popcount(k)] + cost[i][k]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = columnCount; i &lt;= m; i++) <span class="built_in">chkmin</span>(ans, f[m / <span class="number">2</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>TopCoder</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>TopCoder 1684 Posters 题解</title>
    <url>/post/topcoder-1684/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p><a
href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=1684">原题链接</a></p>
<p>网上关于这道题的题解不多（我只找到了<a
href="https://www.cnblogs.com/yzxverygood/p/9360251.html">这篇</a>，而且好像都被下面这组数据卡掉了），而且目前
VJudge 上很少有小于 1000ms 的代码，这是我写这篇题解的原因。</p>
<p>我这份代码暂时还 <strong>没被任何数据卡掉</strong>，跑了 676
ms，链接在<a href="https://vjudge.net/solution/37566473">这里</a>。</p>
<details class="note no-icon info"><summary><p>数据</p>
</summary>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8,18,</span><br><span class="line">&#123;2,2,5,4,1&#125;,</span><br><span class="line">&#123;2,17,12,15,6&#125;</span><br></pre></td></tr></table></figure>
<p>答案是 <code>136</code>，给出一组构造方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AACCCCC.</span><br><span class="line">AACCCCC.</span><br><span class="line">AACCCCC.</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AACCDDDD</span><br><span class="line">AA.EDDDD</span><br><span class="line">AA.EDDDD</span><br><span class="line">AA.EDDDD</span><br><span class="line">AA.EDDDD</span><br><span class="line">ABBEDDDD</span><br><span class="line">.BBEDDDD</span><br></pre></td></tr></table></figure>

</details>
<h2 id="题意">题意</h2>
<p>给一个 <span class="math inline">\(n \times m\)</span> 的网格，和
<span class="math inline">\(K\)</span> 个矩形，每个矩形大小 <span
class="math inline">\(r_i \times c_i\)</span>，要把这 <span
class="math inline">\(K\)</span>
个矩形放到网格上，不允许出格，允许重叠，求覆盖面积最大值。</p>
<p><span class="math inline">\(n, m \le 100, K \le 5\)</span></p>
<h2 id="思路">思路</h2>
<p><span class="math inline">\(K\)</span> 只有 <span
class="math inline">\(5\)</span>，一看就是爆搜。直接搜肯定是过不去的，我们要考虑剪枝。</p>
<p>为了后面方便，我们先枚举 <span class="math inline">\(K\)</span>
的排列，表示放矩形的顺序。</p>
<p>首先发现一个贪心的思路，即第一个矩形一定是放在一个角上的。由于矩形具有对称性，所以我们不妨
<strong>钦定</strong> 它在左上角。</p>
<p>那第二个矩形呢？接着我们的贪心思路，它一定在右下角。（<del>我不会证，所以不证</del>）</p>
<p>然后第三个矩形是不是也会放在一个角上呢？答案是不一定。这个反例可以很简单地举出。</p>
<details class="note no-icon info"><summary><p>反例</p>
</summary>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2,3,</span><br><span class="line">&#123;2,2,2&#125;,</span><br><span class="line">&#123;1,1,1&#125;</span><br></pre></td></tr></table></figure>
<p>最优方法显然是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure>

</details>
<p>所以我们可以先放前两个矩形。</p>
<p>然后现在考虑
dfs。假如我们要放置一个新的矩形，显然它肯定是贴着某条边的（可能是矩形的边，也可能是边界）。所以我们可以枚举这条边，这样就可以把
<span class="math inline">\(100 \times 100\)</span> 的枚举量优化到 <span
class="math inline">\(5 \times 5\)</span>。</p>
<p>还有一个显然的优化是可行性剪枝。如果当前答案加上后面所有矩形的面积之和都小于最优答案，那么直接返回。但是问题又来了：当前答案怎么维护呢？</p>
<p>如果开一个 <span class="math inline">\(100 \times 100\)</span>
的数组，那么我们的枚举量就又上去了。</p>
<p>我们考虑容斥。用之前的答案，加上当前矩形面积，减去当前矩形和之前一个矩形的面积交，加上当前矩形和之前两个矩形面积交……就可以得到现在的答案了。</p>
<p>然后还有一个对称性剪枝。容易发现前两个矩形的顺序其实不重要，所以我们可以只处理排列中第一个数小于第二个数的情况。</p>
<p>最后，由于我们需要先填两个矩形，所以 <span class="math inline">\(K
\le 1\)</span> 的情况要特判。</p>
<p>然后就可以得到一份 <del>吊打这篇题解</del> 跑得极快的代码啦！</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TopCoder 1684 Posters</span></span><br><span class="line"><span class="comment">// 676 ms  https://vjudge.net/solution/37566473</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, K;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123; <span class="type">int</span> r, c; &#125; a[M], tmp[M]; <span class="comment">// tmp 输入矩形，a 按照排列重排后的矩形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// up bound, down bound, left bound, right bound（原谅我英语不好）</span></span><br><span class="line"><span class="comment">// 分别记录第 i 个矩形的上下左右边界（i=0 时记录网格边框）</span></span><br><span class="line"><span class="type">int</span> ub[N], db[N], lb[N], rb[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N], sum[N]; <span class="comment">// p 排列，sum 面积后缀和</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>; <span class="comment">// 答案</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> ret)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(id == K + <span class="number">1</span>) &#123; ans = std::<span class="built_in">max</span>(ans, ret); <span class="keyword">return</span>; &#125; <span class="comment">// 更新答案</span></span><br><span class="line">	<span class="keyword">if</span>(ret + sum[id] &lt;= ans) <span class="keyword">return</span>; <span class="comment">// 可行性剪枝</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; id; i++) <span class="keyword">for</span>(<span class="type">int</span> ki = <span class="number">0</span>; ki &lt;= <span class="number">1</span>; ki++) &#123; <span class="comment">// ki=0 贴着矩形 i 的下面；ki=1 贴着矩形 i 的上面</span></span><br><span class="line">		<span class="comment">// 计算 id 的上下边界</span></span><br><span class="line">		<span class="keyword">if</span>(ki == <span class="number">0</span>) ub[id] = db[i] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> ub[id] = ub[i] - a[id].r;</span><br><span class="line">		db[id] = ub[id] + a[id].r - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ub[id] &lt; <span class="number">1</span> || db[id] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; id; j++)  <span class="keyword">for</span>(<span class="type">int</span> kj = <span class="number">0</span>; kj &lt;= <span class="number">1</span>; kj++) &#123; <span class="comment">// kj=0 贴着矩形 i 的右边；kj=1 贴着矩形 i 的左边</span></span><br><span class="line">			<span class="comment">// 计算 id 的左右边界</span></span><br><span class="line">			<span class="keyword">if</span>(kj == <span class="number">0</span>) lb[id] = rb[j] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> lb[id] = lb[j] - a[id].c;</span><br><span class="line">			rb[id] = lb[id] + a[id].c - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(lb[id] &lt; <span class="number">1</span> || rb[id] &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 容斥原理计算答案</span></span><br><span class="line">			<span class="type">int</span> oldret = ret, U = (<span class="number">1</span> &lt;&lt; (id - <span class="number">1</span>)) - <span class="number">1</span>; <span class="comment">// U 全集</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= U; s++) &#123;</span><br><span class="line">				<span class="type">int</span> l = lb[id], r = rb[id], u = ub[id], d = db[id];</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> o = <span class="number">1</span>; o &lt; id; o++) <span class="keyword">if</span>(s &gt;&gt; (o - <span class="number">1</span>) &amp; <span class="number">1</span>)</span><br><span class="line">					l = std::<span class="built_in">max</span>(l, lb[o]), r = std::<span class="built_in">min</span>(r, rb[o]), u = std::<span class="built_in">max</span>(u, ub[o]), d = std::<span class="built_in">min</span>(d, db[o]); <span class="comment">// 求交集的上下左右边界</span></span><br><span class="line">				ret += (__builtin_popcount(s) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>) * std::<span class="built_in">max</span>(r - l + <span class="number">1</span>, <span class="number">0</span>) * std::<span class="built_in">max</span>(d - u + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 递归搜索</span></span><br><span class="line">			<span class="built_in">dfs</span>(id + <span class="number">1</span>, ret);</span><br><span class="line">			ret = oldret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Posters</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">maxCover</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, vector&lt;<span class="type">int</span>&gt; pWidth, vector&lt;<span class="type">int</span>&gt; pHeight)</span> </span>&#123;</span><br><span class="line">		n = height, m = width, K = pWidth.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) tmp[i].r = pHeight[i - <span class="number">1</span>], tmp[i].c = pWidth[i - <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 特判 K&lt;=1</span></span><br><span class="line">		<span class="keyword">if</span>(K == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(K == <span class="number">1</span>) <span class="keyword">return</span> tmp[<span class="number">1</span>].r * tmp[<span class="number">1</span>].c;</span><br><span class="line">		<span class="comment">// 特殊处理网格边框，这里的初值与上面「计算 id 上下/左右边界」部分对应</span></span><br><span class="line">		ub[<span class="number">0</span>] = n + <span class="number">1</span>, db[<span class="number">0</span>] = <span class="number">0</span>, lb[<span class="number">0</span>] = m + <span class="number">1</span>, rb[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 枚举排列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) p[i] = i;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(p[<span class="number">1</span>] &gt; p[<span class="number">2</span>]) <span class="keyword">continue</span>; <span class="comment">// 对称性剪枝</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) a[i] = tmp[p[i]]; <span class="comment">// 处理重排后的矩形</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = K; i &gt;= <span class="number">1</span>; i--) sum[i] = sum[i + <span class="number">1</span>] + a[i].r * a[i].c; <span class="comment">// 计算面积后缀和</span></span><br><span class="line">			ub[<span class="number">1</span>] = <span class="number">1</span>, db[<span class="number">1</span>] = a[<span class="number">1</span>].r, lb[<span class="number">1</span>] = <span class="number">1</span>, rb[<span class="number">1</span>] = a[<span class="number">1</span>].c; <span class="comment">// 放置第一个矩形</span></span><br><span class="line">			ub[<span class="number">2</span>] = n - a[<span class="number">2</span>].r + <span class="number">1</span>, db[<span class="number">2</span>] = n, lb[<span class="number">2</span>] = m - a[<span class="number">2</span>].c + <span class="number">1</span>, rb[<span class="number">2</span>] = m; <span class="comment">// 放置第二个矩形</span></span><br><span class="line">			<span class="built_in">dfs</span>(<span class="number">3</span>, a[<span class="number">1</span>].r * a[<span class="number">1</span>].c + a[<span class="number">2</span>].r * a[<span class="number">2</span>].c -  std::<span class="built_in">max</span>(db[<span class="number">1</span>] - ub[<span class="number">2</span>] + <span class="number">1</span>, <span class="number">0</span>) * std::<span class="built_in">max</span>(rb[<span class="number">1</span>] - lb[<span class="number">2</span>] + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// 计算前两个矩形覆盖的面积，并递归</span></span><br><span class="line">		&#125; <span class="keyword">while</span>(std::<span class="built_in">next_permutation</span>(p + <span class="number">1</span>, p + K + <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> ans; <span class="comment">// 完结撒花~</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>TopCoder</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>搜索</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 1490 Let the light guide us 题解</title>
    <url>/post/uva-1490/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>有一个 <span class="math inline">\(n\times m\)</span>
的网格，每个格子有两个值 <span class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>（原题中是 <span
class="math inline">\(T\)</span> 和 <span
class="math inline">\(f\)</span>）。你需要在每一行选择一个格子，使得对于任意选择的两个格子
<span class="math inline">\((i, j), (i+1, k)\)</span>，满足 <span
class="math inline">\(\lvert j - k \rvert \le b(i,j) + b(i +
1,k)\)</span>。求所选格子的 <span class="math inline">\(a\)</span>
之和的最小值。</p>
<p><span class="math inline">\(n \le 100, m \le 5000, 0 \le b(i, j) \le
10^5\)</span>。</p>
<h2 id="思路">思路</h2>
<h3 id="朴素-dp">朴素 DP</h3>
<p>首先，显然 <span class="math inline">\(b &gt; 5000\)</span>
是没有意义的（因为 <span class="math inline">\(\lvert j -
k\rvert\)</span> 是不可能大于 <span class="math inline">\(5000\)</span>
的）。</p>
<p>然后可以设计出一个状态：<span class="math inline">\(f(i, j)\)</span>
表示考虑了前 <span class="math inline">\(i\)</span> 行，第 <span
class="math inline">\(i\)</span> 行选了第 <span
class="math inline">\(j\)</span>
列的格子，最小的代价。转移方程是这样的：</p>
<p><span class="math display">\[
f(i, j) = a(i, j) + \min_{\lvert j - k \rvert \le b(i,j) + b(i-1,k)} f(i
- 1, k)
\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(nm^2)\)</span>。</p>
<h3 id="优化">优化</h3>
<p>这个状态基本上已经无法优化了<del>（反正我不会）</del>，所以我们要在转移上下手。</p>
<p>我们看这个式子：</p>
<p><span class="math display">\[
\lvert j - k\rvert \le b(i, j) + b(i - 1, k)
\]</span></p>
<p>显然右边大于 <span
class="math inline">\(0\)</span>，所以可以把它化成这样：（两个式子同时成立）</p>
<p><span class="math display">\[
\begin{cases}
    j - k \le b(i, j) + b(i - 1, k)\\
    k - j \le b(i, j) + b(i - 1, k)
\end{cases}
\]</span></p>
<p>化简得：</p>
<p><span class="math display">\[
\begin{cases}
    j - b(i, j) \le k + b(i - 1, k)\\
    j + b(i, j) \ge k - b(i - 1, k)
\end{cases}
\]</span></p>
<p>接下来就比较神奇了。（鬼知道这是怎么想到的）</p>
<p>我们记 <span class="math inline">\(S_L = j - b(i, j)\)</span>，<span
class="math inline">\(S_R = j + b(i, j)\)</span>，并记区间 <span
class="math inline">\(S = [S_L, S_R]\)</span>。<br />
类似的，记 <span class="math inline">\(T_L = k - b(i - 1,
k)\)</span>，<span class="math inline">\(T_R = k + b(i - 1,
k)\)</span>，并记区间 <span class="math inline">\(T = [T_L,
T_R]\)</span>。<br />
（显然 <span class="math inline">\(S_L \le S_R\)</span>，<span
class="math inline">\(T_L \le T_R\)</span>）</p>
<p>那么上面的式子就可以写成：</p>
<p><span class="math display">\[
\begin{cases}
    S_L \le T_R\\
    T_L \le S_R
\end{cases}
\]</span></p>
<p>那么这个式子和「<span class="math inline">\(S\)</span> 与 <span
class="math inline">\(T\)</span> 相交」是等价的。</p>
<details class="note no-icon info"><summary><p>证明</p>
</summary>
<p>区间 <span class="math inline">\(S\)</span> 与 <span
class="math inline">\(T\)</span> <strong>不相交</strong> 等价于 <span
class="math inline">\(S_R &lt; T_L\)</span> 或 <span
class="math inline">\(T_R &lt; S_L\)</span>，所以 <span
class="math inline">\(S\)</span> 与 <span
class="math inline">\(T\)</span> <strong>相交</strong> 等价于：</p>
<p><span class="math display">\[
\begin{cases}
    S_R \ge T_L\\
    T_R \ge S_L
\end{cases}
\]</span></p>
<p>这与原式相同。</p>

</details>
<p>然后就简单了。现在的问题是对于每个格子有一个区间 <span
class="math inline">\([S_L,
S_R]\)</span>，如果相邻两行的格子的区间相交，那么这两个格子就可以同时被选（即可以用上一行格子的
<span class="math inline">\(dp\)</span> 值更新这一行的 <span
class="math inline">\(dp\)</span> 值）。</p>
<p>做法显然是对于每一行开一个线段树，将上一行的 <span
class="math inline">\([T_L, T_R]\)</span> 区间取 <span
class="math inline">\(\min\)</span>，这一行的 <span
class="math inline">\([S_L, S_R]\)</span> 区间求 <span
class="math inline">\(\min\)</span>，就是区间改区间查的问题了。</p>
<p><span class="math inline">\(n\)</span>
个线段树空间会炸，但其实可以只用开一个线段树。</p>
<p>时间复杂度 <span class="math inline">\(O(nm\log m)\)</span>。</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UVA1490</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ARR_V = <span class="number">7000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> V_MAX = <span class="number">6000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][M], b[N][M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">	<span class="type">int</span> t[ARR_V &lt;&lt; <span class="number">3</span>], lazy[ARR_V &lt;&lt; <span class="number">3</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">		<span class="built_in">memset</span>(lazy, INF, <span class="built_in">sizeof</span>(lazy));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(t, INF, <span class="built_in">sizeof</span>(t));</span><br><span class="line">		<span class="built_in">memset</span>(lazy, INF, <span class="built_in">sizeof</span>(lazy));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_lazy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123; t[x] = std::<span class="built_in">min</span>(t[x], v), lazy[x] = std::<span class="built_in">min</span>(lazy[x], v); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lazy_down</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">set_lazy</span>(x &lt;&lt; <span class="number">1</span>, lazy[x]), <span class="built_in">set_lazy</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, lazy[x]);</span><br><span class="line">		lazy[x] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = V_MAX &lt;&lt; <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ql &gt; qr) <span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[x];</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ret = INF;</span><br><span class="line">		<span class="built_in">lazy_down</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= mid) ret = std::<span class="built_in">min</span>(ret, <span class="built_in">query</span>(ql, qr, x &lt;&lt; <span class="number">1</span>, l, mid));</span><br><span class="line">		<span class="keyword">if</span>(qr &gt; mid) ret = std::<span class="built_in">min</span>(ret, <span class="built_in">query</span>(ql, qr, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> qv, <span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = V_MAX &lt;&lt; <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ql &gt; qr) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) &#123; <span class="built_in">set_lazy</span>(x, qv); <span class="keyword">return</span>; &#125;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">lazy_down</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify</span>(ql, qr, qv, x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">		<span class="keyword">if</span>(qr &gt; mid) <span class="built_in">modify</span>(ql, qr, qv, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">		t[x] = std::<span class="built_in">min</span>(t[x &lt;&lt; <span class="number">1</span>], t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) == <span class="number">2</span> &amp;&amp; (n | m)) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i][j]), b[i][j] = std::<span class="built_in">min</span>(b[i][j], <span class="number">5000</span>);</span><br><span class="line">		seg.<span class="built_in">reset</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				f[i][j] = seg.<span class="built_in">query</span>(j - b[i][j] + V_MAX, j + b[i][j] + V_MAX) + a[i][j];</span><br><span class="line">			seg.<span class="built_in">build</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				seg.<span class="built_in">modify</span>(j - b[i][j] + V_MAX, j + b[i][j] + V_MAX, f[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans = INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) ans = std::<span class="built_in">min</span>(ans, f[n][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Ural 1013 K-based Numbers. Version 3 题解</title>
    <url>/post/ural-1013/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p><a
href="https://acm.timus.ru/problem.aspx?space=1&amp;num=1013">题目链接</a></p>
<p>求 <span class="math inline">\(k\)</span> 进制下，位数为 <span
class="math inline">\(n\)</span>，没有两个相邻的 <span
class="math inline">\(0\)</span> 的数的个数。不能有前导零。答案对 <span
class="math inline">\(m\)</span> 取模。</p>
<p><span class="math inline">\(2 \le n, k, m \le 10^{18}\)</span></p>
<h2 id="初步思路">初步思路</h2>
<p>考虑数位 DP。</p>
<p>设 <span class="math inline">\(f(i, j)\)</span> 表示已经考虑了前
<span class="math inline">\(i\)</span> 位，<span
class="math inline">\(j=0\)</span> 时第 <span
class="math inline">\(i\)</span> 位是 <span
class="math inline">\(0\)</span>，<span
class="math inline">\(j=1\)</span> 时第 <span
class="math inline">\(i\)</span> 位不是 <span
class="math inline">\(0\)</span>，此时满足条件的数的个数。</p>
<p>初始化，<span class="math inline">\(f(1, 0) = 0\)</span>， <span
class="math inline">\(f(1, 1) = k - 1\)</span>。 答案是 <span
class="math inline">\(f(n, 0) + f(n, 1)\)</span>。</p>
<p>转移时，当 <span class="math inline">\(j=0\)</span> 时上一位只能是
<span class="math inline">\([1, k)\)</span>，即 <span
class="math inline">\(f(i, 0) = (k - 1) \times f(i - 1,
1)\)</span>；<br />
当 <span class="math inline">\(j=1\)</span> 时，上一位可以是 <span
class="math inline">\(0\)</span> 也可以是 <span
class="math inline">\([1, k)\)</span>，即 <span
class="math inline">\(f(i, 0) = f(i - 1, 0) + (k - 1) \times f(i - 1,
1)\)</span>。<br />
转移方程： <span class="math display">\[
f(i, j) = \begin{cases}
    (k - 1) \times f(i - 1, 1) &amp;(j = 0)\\
    f(i - 1, 0) + (k - 1) \times f(i - 1, 1) &amp;(j = 1)
\end{cases}
\]</span> 复杂度 <span
class="math inline">\(O(n)\)</span>，肯定过不了。</p>
<h2 id="优化">优化</h2>
<p>DP 本身复杂度基本没法优化了，那么我们从减少计算次数方面入手。<br />
这时我们就可以用矩阵快速幂优化。</p>
<h3 id="矩阵">矩阵</h3>
<h4 id="快速幂">快速幂</h4>
<p>这个不用讲了吧。</p>
<p>但是快速幂是基于乘法的，那么矩阵的乘法是什么呢？</p>
<h4 id="矩阵乘法">矩阵乘法</h4>
<p>矩阵乘法只在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。</p>
<p>设两个矩阵分别为 <span class="math inline">\(A\)</span>（<span
class="math inline">\(P\times M\)</span> 的矩阵），<span
class="math inline">\(B\)</span>（<span class="math inline">\(M\times
Q\)</span> 的矩阵），设 <span class="math inline">\(C = A \times
B\)</span>.</p>
<p>那么 <span class="math inline">\(C\)</span> 是 <span
class="math inline">\(P \times Q\)</span> 的矩阵，且 <span
class="math inline">\(C\)</span> 第 <span
class="math inline">\(i\)</span> 行第 <span
class="math inline">\(j\)</span> 列的数为 <span
class="math inline">\(A\)</span> 第 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(M\)</span> 个数与 <span
class="math inline">\(B\)</span> 第 <span
class="math inline">\(j\)</span> 列 <span
class="math inline">\(M\)</span> 个数分别相乘的和。 <span
class="math display">\[
C_{i, j} = \sum_{k=1}^M A_{i, k}B_{k, j}
\]</span> 另外，矩阵乘法满足结合律，不满足一般的交换律。</p>
<h4 id="矩阵快速幂">矩阵快速幂</h4>
<p>那么此时矩阵快速幂就是按照普通的快速幂求法来算。</p>
<h3 id="应用矩阵优化">应用矩阵优化</h3>
<p>设 <span class="math inline">\(F(i)\)</span> 表示 <span
class="math inline">\(\begin{bmatrix}f(i, 0) &amp;f(i,
1)\end{bmatrix}\)</span>，那么我们希望通过 <span
class="math inline">\(F(i - 1) = \begin{bmatrix}f(i - 1, 0) &amp;f(i -
1, 1)\end{bmatrix}\)</span> 推出 <span
class="math inline">\(F(i)\)</span>。</p>
<p>考虑推导一个矩阵 <span class="math inline">\(g\)</span>，使得 <span
class="math inline">\(\begin{bmatrix}f(i - 1, 0) &amp;f(i - 1,
1)\end{bmatrix} \times g = \begin{bmatrix}f(i, 0) &amp;f(i,
1)\end{bmatrix}\)</span>，</p>
<p>怎么推呢？因为 <span class="math inline">\(f(i, 0) = 0 \times f(i -
1, 0) + (k - 1) \times f(i - 1, 1)\)</span>，所以 <span
class="math inline">\(g\)</span> 的第一列应该是 <span
class="math inline">\(\begin{bmatrix}0\\k -
1\end{bmatrix}\)</span>，类似的第二列是 <span
class="math inline">\(\begin{bmatrix}1\\k -
1\end{bmatrix}\)</span>，所以 <span class="math inline">\(g =
\begin{bmatrix}0 &amp; 1\\k - 1 &amp; k - 1\end{bmatrix}\)</span>。</p>
<h3 id="整理思路">整理思路</h3>
<p>初始状态是 <span class="math inline">\(F(1) = \begin{bmatrix}0 &amp;
k - 1\end{bmatrix}\)</span>，通过不断乘 <span
class="math inline">\(\begin{bmatrix}0 &amp; 1\\k - 1 &amp; k -
1\end{bmatrix}\)</span> 得到 <span class="math inline">\(F(n) =
\begin{bmatrix}f(n, 0) &amp; f(n, 1)\end{bmatrix}\)</span>，答案就是
<span class="math inline">\(f(n, 0) + f(n, 1)\)</span>。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Z 算法/拓展 KMP 详解</title>
    <url>/post/z-algorithm/</url>
    <content><![CDATA[<h2 id="引入">引入</h2>
<p>先来看几个问题：</p>
<blockquote>
<p>什么是 Z 算法呢？</p>
</blockquote>
<p>Z 算法（Z-Algorithm，又叫拓展 KMP 或
exKMP）是一种字符串匹配算法，可以在 <span
class="math inline">\(O(n)\)</span>
时间内算出一些关于字符串匹配的问题。</p>
<blockquote>
<p>为什么要用 Z 算法？</p>
</blockquote>
<p>暴力进行匹配是 <span class="math inline">\(O(n^2)\)</span> 的，但用 Z
后是 <span class="math inline">\(O(n)\)</span> 的（KMP
也可以实现类似的功能）。</p>
<p>接下来是一些约定：</p>
<blockquote>
<ol type="1">
<li><span class="math inline">\(s[l .. r]\)</span> 表示 <span
class="math inline">\(s_ls_{l + 1}s_{l + 2} ... s_r\)</span></li>
<li>z 函数用 <span class="math inline">\(z()\)</span> 表示，原字符串用
<span class="math inline">\(s\)</span> 表示</li>
<li>下标从 <span class="math inline">\(1\)</span> 开始</li>
</ol>
</blockquote>
<h2 id="算法流程">算法流程</h2>
<h3 id="定义">定义</h3>
<p><strong>定义：</strong> 对于任意 <span class="math inline">\(i(2 \le
i \le n)\)</span>，定义 <span class="math inline">\(z(i)\)</span>
表示满足 <span class="math inline">\(s[1 .. x] = s[i .. i + x -
1]\)</span> 的最大的 <span class="math inline">\(x\)</span>。</p>
<blockquote>
<p>例如：<br />
<span class="math inline">\(s = \texttt{aabbaabb}\)</span>，<span
class="math inline">\(z(5) = 4\)</span>，因为 <span
class="math inline">\(s[1 .. 4] = s[5 .. 8]\)</span><br />
<span class="math inline">\(s = \texttt{aabab}\)</span>，<span
class="math inline">\(z(3) = 0\)</span><br />
<span class="math inline">\(s = \texttt{ababa}\)</span>，<span
class="math inline">\(z(3) = 3\)</span></p>
</blockquote>
<p>并且，对于任意 <span class="math inline">\(i(2 \le i \le
n)\)</span>，我们把区间 <span class="math inline">\([i, i + z(i) -
1]\)</span> 叫做一个 Z-Box，共有 <span class="math inline">\(n\)</span>
个 Z-Box。<br />
这个概念有什么用呢？一会求 Z 函数时会用到。</p>
<h3 id="如何求解">如何求解</h3>
<p>求 <span class="math inline">\(z[1 .. n]\)</span> 的总复杂度是 <span
class="math inline">\(O(n)\)</span> 的。</p>
<p>我们知道暴力求 <span class="math inline">\(z\)</span> 是 <span
class="math inline">\(O(n^2)\)</span>的，那么为了优化复杂度，我们需要用之前算出的
<span class="math inline">\(z[2 .. i - 1]\)</span> 来算出 <span
class="math inline">\(z(i)\)</span>。</p>
<p>我们维护右端点最右的 Z-Box 的左右端点，记为 <span
class="math inline">\(zl\)</span>, <span
class="math inline">\(zr\)</span>。（初始都为 <span
class="math inline">\(0\)</span>）</p>
<p>考虑如何求 <span class="math inline">\(z(i)\)</span>。如果 <span
class="math inline">\(zr &lt; i\)</span>，那么我们并无法利用之前的 <span
class="math inline">\(z\)</span>，所以直接暴力更新 <span
class="math inline">\(z(i)\)</span>，并更新 <span
class="math inline">\(zl\)</span>, <span
class="math inline">\(zr\)</span>。下面讨论 <span
class="math inline">\(zr \ge i\)</span> 的情况。</p>
<img data-src="/post/z-algorithm/Z-%E5%87%BD%E6%95%B0%E6%9B%B4%E6%96%B0.png" class="" title="Z 函数更新">
<p>令 <span class="math inline">\(i&#39; = i - zl +
1\)</span>，图中绿色是 <span class="math inline">\(i&#39;\)</span> 的
Z-Box 和 <span class="math inline">\(s\)</span> 与之长度相等的前缀，由
<span class="math inline">\(z\)</span>
函数定义得两段绿色相等。蓝色同理。两段红色是 <span
class="math inline">\([zl, zr]\)</span> 和 <span
class="math inline">\(s\)</span>
与之长度相等的前缀，两段红色也相等。</p>
<p>由图可知，<span class="math inline">\(z(i) &gt;= \min{z(i&#39;), zr -
i + 1}\)</span>。</p>
<p>那么如果 <span class="math inline">\(z(i&#39;) &lt; zr - i +
1\)</span>，那么直接让 <span class="math inline">\(z(i) =
z(i&#39;)\)</span>。</p>
<p>但是如果 <span class="math inline">\(z(i&#39;) \ge zr - i +
1\)</span> 呢？是不是让 <span class="math inline">\(z(i) = zr - i +
1\)</span> 就好了呢？</p>
<p>其实不一定，看下面这张图：</p>
<img data-src="/post/z-algorithm/%E5%8F%8D%E4%BE%8B.png" class="" title="反例">
<p>图中 <span class="math inline">\(zr - i + 1\)</span>
应该等于蓝色，但是实际上 <span class="math inline">\(z(i)\)</span>
应该是蓝色+橙色，所以这种情况我们直接在 <span class="math inline">\(zr -
i + 1\)</span> 的基础上暴力更新 <span
class="math inline">\(z(i)\)</span>，并更新 <span
class="math inline">\(zl, zr\)</span>。</p>
<details class="note no-icon info"><summary><p>无关紧要的证明</p>
</summary>
<p>其实 <span class="math inline">\(z(i&#39;)\)</span> 不可能大于 <span
class="math inline">\(zr - i +
1\)</span>，因为如果大于，那么就会变成下面这样：</p>
<p><img data-src="/post/z-algorithm/%E8%AF%81%E6%98%8E.png" class="" title="证明"></p>
<p>那么粉色和橙色的前面部分是相等的，那么红色就可以继续往后延伸，与前面
<span class="math inline">\(z\)</span> 的定义矛盾。</p>

</details>
<h4 id="时间复杂度">时间复杂度</h4>
<p>因为 <span class="math inline">\(zl\)</span>, <span
class="math inline">\(zr\)</span> 一直往右移动，不移动 <span
class="math inline">\(zl, zr\)</span> 时的操作为常数，所以时间复杂度为
<span class="math inline">\(O(n)\)</span>。</p>
<h3 id="代码">代码</h3>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> z[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">z_algorithm</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt;= r) z[i] = std::<span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(i + z[i] &lt;= n &amp;&amp; s[i + z[i]] == s[z[i] + <span class="number">1</span>]) z[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i + z[i] &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="应用">应用</h3>
<h3 id="例题-1">例题 1</h3>
<blockquote>
<p>给出两个字符串 s, t，求出所有的位置 x，满足 <span
class="math inline">\(s[x .. x + len(t) - 1] = t\)</span>。<br />
其中 <span class="math inline">\(len(s), len(t) \le 10^5\)</span>，s, t
仅包含大小写字母。</p>
</blockquote>
<p>可以设一个字符 <span class="math inline">\(r = t + \texttt{!} +
s\)</span>，然后对 <span class="math inline">\(r\)</span> 跑一边
Z-Algorithm。<br />
然后看 <span class="math inline">\(r[len(t) + 2 .. len(r)]\)</span>
中有多少个的 Z 函数等于 <span
class="math inline">\(len(t)\)</span>。</p>
<p>也可以按照 Z 算法类似的方式直接算。（设 <span
class="math inline">\(e(i)\)</span> 表示满足 <span
class="math inline">\(s[i .. i + x - 1] = t[1 .. x]\)</span> 的最大的
<span class="math inline">\(x\)</span>）</p>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exkmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *t)</span> </span>&#123; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt;= r) e[i] = std::<span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(i + e[i] &lt;= n &amp;&amp; s[i + e[i]] == t[e[i] + <span class="number">1</span>]) e[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i + e[i] &gt; r) l = i, r = i + e[i] - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="例题-2">例题 2</h3>
<p><a href="https://www.luogu.com.cn/problem/P5410">洛谷 P5410</a></p>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e7</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">z_algorithm</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt;= r) z[i] = std::<span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(i + z[i] &lt;= n &amp;&amp; s[i + z[i]] == s[z[i] + <span class="number">1</span>]) z[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i + z[i] &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exkmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *t)</span> </span>&#123; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt;= r) e[i] = std::<span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(i + e[i] &lt;= n &amp;&amp; s[i + e[i]] == t[e[i] + <span class="number">1</span>]) e[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i + e[i] &gt; r) l = i, r = i + e[i] - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">z_algorithm</span>(b);</span><br><span class="line">	z[<span class="number">1</span>] = lb;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lb; i++) ans ^= (LL)i * (z[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="built_in">exkmp</span>(a, b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lb; i++) <span class="keyword">if</span>(a[i] == b[i]) e[<span class="number">1</span>] = i; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= la; i++) ans ^= (LL)(i) * (e[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P3953 [NOIP2017 提高组] 逛公园 题解</title>
    <url>/post/luogu-3953/</url>
    <content><![CDATA[<p><strong>目前这个做法没有被任何数据 hack
掉，如果有请跟我说哦。</strong>（左边「关于」页面有我的各种
ID，你也可以在下面评论给我留言）</p>
<p>以下都是这道题：</p>
<p><a href="https://www.luogu.com.cn/problem/P3953">洛谷 P3953</a><br />
<a href="https://loj.ac/p/2316">LOJ 2316</a><br />
<a href="https://uoj.ac/problem/331">UOJ 331</a></p>
<h2 id="题意">题意</h2>
<p>给一张 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span> 条边的带权有向图，求从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的长度不超过路 <span
class="math inline">\(dist(1, n)+K\)</span> 的路径条数，对 <span
class="math inline">\(P\)</span> 取模（如果有无数条输出 <span
class="math inline">\(-1\)</span>）。不保证 <span
class="math inline">\(P\)</span> 是质数（存疑，不过不影响）。</p>
<p><span class="math inline">\(n \le 10^5, m \le 2 \times 10^5, K \le
50, P \le 10^9, 0 \le w \le 1000\)</span>。</p>
<h2 id="思路">思路</h2>
<p>首先考虑边权大于 <span class="math inline">\(0\)</span> 怎么做。</p>
<p>容易想到设 <span class="math inline">\(f(i, j)\)</span> 表示从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(i\)</span>，路径长度比 <span
class="math inline">\(dist(1, i)\)</span> 大 <span
class="math inline">\(j\)</span> 的方案数。</p>
<p>转移就是：</p>
<p><span class="math display">\[
f(v, j) = \sum_{(u, v, w) \in E} f(u, dist(1, v) + j - w - dist(1, v))
\]</span></p>
<p>这里需要注意先枚举 <span class="math inline">\(j\)</span> 再枚举
<span class="math inline">\(v\)</span>。</p>
<p>然后考虑加上边权为 <span class="math inline">\(0\)</span>
的边（下面称作 <span class="math inline">\(0\)</span> 边）。</p>
<p>首先需要判无数解的情况，即出现边权和为 <span
class="math inline">\(0\)</span> 的环（下称 <span
class="math inline">\(0\)</span> 环）。</p>
<p>当然，并不是所有 <span class="math inline">\(0\)</span>
环都能造成无数解。怎么判断呢？</p>
<p>对于一个点 <span class="math inline">\(u\)</span>，如果 <span
class="math inline">\(dist(1, u) + dist(u, n) \le dist(1, n) +
K\)</span>，那么我们把点 <span class="math inline">\(u\)</span> 叫做
<strong>可行点</strong>。为什么呢？如果一个点不满足这个条件，那么它一定不可能出现在答案中，所以我们直接抛弃掉这种点。</p>
<p>那么我们建一张只包含所有可行点、每条边都是从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(i\)</span> 的最短路径上的边的子图，显然它是一个
DAG。</p>
<p>那么我们有一些结论：（<del>读者自证不难</del>）：</p>
<ol type="1">
<li>显然所有的 <span class="math inline">\(0\)</span> 边都在 DAG 上</li>
<li>所有在 DAG 上的环都是 <span class="math inline">\(0\)</span>
环。</li>
<li>所有 <strong>能造成无数解的 <span class="math inline">\(0\)</span>
环</strong> 都在 DAG 上</li>
<li>所有在 DAG 上的 <span class="math inline">\(0\)</span>
环都能造成无数解。</li>
</ol>
<p>所以判 <span class="math inline">\(0\)</span> 环只需要在 DAG
上跑一遍拓扑排序就好啦！</p>
<p>但是还有一个问题。刚刚我们 DP 的时候，边权是大于 <span
class="math inline">\(0\)</span>
的。这时候边是可以任意顺序枚举的。但是现在有 <span
class="math inline">\(0\)</span> 边了，我们就要保证一定的顺序。</p>
<p>由于所有 <span class="math inline">\(0\)</span> 边都的 DAG
上，所以我们可以先把在 DAG
上的边按拓扑序更新一遍，然后剩下的边边权都大于 <span
class="math inline">\(0\)</span>，就可以任意顺序枚举啦！</p>
<p>总结一下，我们需要：</p>
<ol type="1">
<li>建正图和反图</li>
<li>对于 <span class="math inline">\(1\)</span> 在正图跑最短路，对于
<span class="math inline">\(n\)</span> 在反图跑最短路</li>
<li>建 DAG，跑拓扑，判 <span class="math inline">\(0\)</span> 环</li>
<li>DP</li>
</ol>
<p>最后提一句，建议在 UOJ 交一下，上面有很多 hack
数据，可以卡掉很多假做法。（UOJ hack 4 是卡 SPFA 的，所以 <del>SPFA
已死</del> 要用 dijkstra 写最短路）</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K_MAX = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, K, mod;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> to, nxt; LL w; &#125; edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> head[N], ek;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head)); ek = <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, LL w)</span> </span>&#123; edge[ek] = (Edge)&#123;v, head[u], w&#125;, head[u] = ek++; &#125;</span><br><span class="line">&#125; G, R, DAG;</span><br><span class="line"></span><br><span class="line">LL dis1[N], disn[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(Graph Graph, LL *dis, <span class="type">int</span> st)</span> </span>&#123; <span class="comment">// 最短路</span></span><br><span class="line">	std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q; <span class="comment">// 强制转成小根堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = LLINF;</span><br><span class="line">	dis[st] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, st&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">		<span class="type">int</span> u = p.second, d = p.first;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(dis[u] != d) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = Graph.head[u]; i; i = Graph.edge[i].nxt) <span class="keyword">if</span>(dis[u] + Graph.edge[i].w &lt; dis[Graph.edge[i].to]) &#123;</span><br><span class="line">			<span class="type">int</span> v = Graph.edge[i].to;</span><br><span class="line">			dis[v] = dis[u] + Graph.edge[i].w;</span><br><span class="line">			q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> exist[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_DAG</span><span class="params">()</span> </span>&#123; <span class="comment">// 建图（最短路生成图）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) exist[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(dis1[i] + disn[i] &gt; dis1[n] + K) exist[i] = <span class="literal">false</span>; <span class="comment">// 不可能出现在答案中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) <span class="keyword">if</span>(exist[u])</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = G.head[u]; i; i = G.edge[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = G.edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!exist[v]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis1[v] == dis1[u] + G.edge[i].w) DAG.<span class="built_in">add_edge</span>(u, v, G.edge[i].w);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ind[N];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; order;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 拓扑排序</span></span><br><span class="line">	order.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ind[i] = <span class="number">0</span>; <span class="comment">// ind - 入度</span></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) <span class="keyword">for</span>(<span class="type">int</span> i = DAG.head[u]; i; i = DAG.edge[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v = DAG.edge[i].to;</span><br><span class="line">		ind[v]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!ind[i]) q.<span class="built_in">push_back</span>(i), cnt++, order.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">back</span>();</span><br><span class="line">		q.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = DAG.head[u]; i; i = DAG.edge[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = DAG.edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(ind[v]) &#123;</span><br><span class="line">				ind[v]--;</span><br><span class="line">				<span class="keyword">if</span>(ind[v] == <span class="number">0</span>) q.<span class="built_in">push_back</span>(v), cnt++, order.<span class="built_in">push_back</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][K_MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= K; j++) f[i][j] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 在 DAG 上 DP</span></span><br><span class="line">			<span class="type">int</span> u = order[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = DAG.head[u]; k; k = DAG.edge[k].nxt) &#123;</span><br><span class="line">				<span class="type">int</span> v = DAG.edge[k].to;</span><br><span class="line">				(f[v][j] += f[u][j]) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) <span class="comment">// DP 不在 DAG 上的边</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = G.head[u]; i; i = G.edge[i].nxt) &#123;</span><br><span class="line">				<span class="type">int</span> v = G.edge[i].to;</span><br><span class="line">				<span class="keyword">if</span>(dis1[v] == dis1[u] + G.edge[i].w) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="type">int</span> tmp = dis1[u] + j + G.edge[i].w - dis1[v];</span><br><span class="line">				<span class="keyword">if</span>(tmp &lt;= K) (f[v][tmp] += f[u][j]) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= K; j++) (ans += f[n][j]) %= mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		G.<span class="built_in">clear</span>(), R.<span class="built_in">clear</span>(), DAG.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K, &amp;mod);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="type">int</span> u, v; LL w;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">			G.<span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">			R.<span class="built_in">add_edge</span>(v, u, w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dijkstra</span>(G, dis1, <span class="number">1</span>), <span class="built_in">dijkstra</span>(R, disn, n);</span><br><span class="line">		<span class="built_in">build_DAG</span>();</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">check</span>()) &#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>一个生成函数的 trick</title>
    <url>/post/a-trick-for-generating-function/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>原题是 <a
href="https://local.cwoi.com.cn:8443/contest/C0462/problem/B">这个</a>。</p>
<p>前置知识需要生成函数和单位根反演。（都不需要掌握得很牢固
<del>因为我掌握的就不牢固</del>）</p>
<h2 id="做法">做法</h2>
<h3 id="简单转化">简单转化</h3>
<p>首先那个 <span class="math inline">\(F(x,a,b)\)</span> 就是 <span
class="math inline">\(x^{\gcd(a, b)}\)</span>（<span
class="math inline">\(ab=0\)</span> 除外），证明不难
<del>我不会证</del>。</p>
<p>然后设 <span class="math inline">\(F(x)\)</span>
为子集和的生成函数，那么 <span class="math inline">\(F(x) =
\prod\limits_{i=L+1}^R (x^i+1)\)</span>。所以答案就是 <span
class="math inline">\(\sum\limits_{m|j} [x^j]F(x)\)</span>。</p>
<p>然后就是单位根反演：</p>
<p><span class="math display">\[
\begin{aligned}
     &amp;\sum_{m\mid i} [x^i]F(x)\\
    &amp;=\sum_{i\ge 0} ([x^i]F(x)) \cdot [m \mid i]\\
    &amp;=\sum_{i\ge 0} ([x^i]F(x)) \sum_{j=0}^{m-1} \omega_m^{ij}\\
    &amp;=\sum_{j=0}^{m-1}\sum_{i\ge 0} \omega_m^{ij}\cdot ([x^i]F(x))\\
    &amp;=\sum_{j=0}^{m-1}\sum_{i\ge 0} [x^i]F(\omega_m^jx)\\
    &amp;=\sum_{j=0}^{m-1} F(\omega_m^j)
\end{aligned}
\]</span></p>
<p>那么现在的问题是求 <span
class="math inline">\(F(\omega_m^i)\)</span>。</p>
<h3 id="推式子">推式子</h3>
<p>首先考虑把下界去掉。<span class="math inline">\(F(x) =
\dfrac{\prod_{i=1}^R (x^i + 1)}{\prod_{i=1}^L (x^i +
1)}\)</span>，所以我们设 <span class="math inline">\(G_{T}(x) =
\prod\limits_{i=1}^{T}(x^i+1)\)</span>，那么 <span
class="math inline">\(F(x) = \dfrac{G_R(x)}{G_L(x)}\)</span>。</p>
<p>然后，由于 <span class="math inline">\(L\)</span> 和 <span
class="math inline">\(R\)</span> 都是 <span
class="math inline">\(m^k\)</span> 的形式，所以我们只需要计算 <span
class="math inline">\(G_{m^k}=\prod\limits_{i=1}^{m^k} (x^i +
1)\)</span>。</p>
<p>由于 <span class="math inline">\(x\)</span> 是 <span
class="math inline">\(\omega_m^j\)</span> 的形式，所以 <span
class="math inline">\(x^i=\omega_m^{ij}=\omega_m^{j(i\bmod
m)}\)</span>，也即 <span class="math inline">\(x^i\)</span> 只和 <span
class="math inline">\(i\bmod m\)</span> 有关。正好求和上界是 <span
class="math inline">\(m^k\)</span>，所以容易得到：</p>
<p><span class="math display">\[
\begin{aligned}
    G_{m^k}(\omega_m^j)
    &amp;=\prod_{i=1}^{m^k}(\omega_m^{ij} + 1)\\
    &amp;=\prod_{p=0}^{m^{k-1}-1}\prod_{i=1}^m(\omega_m^{(pm+i)j} + 1)\\
    &amp;=\prod_{p=0}^{m^{k-1}-1}\prod_{i=1}^m(\omega_m^{ij} + 1)\\
    &amp;=\left(\prod_{i=1}^m(\omega_m^{ij} + 1)\right)^{m^{k-1}}
\end{aligned}
\]</span></p>
<h3 id="巧妙的-trick">巧妙的 trick</h3>
<p>前面都很套路，这里就到这题最妙的地方了。</p>
<p>现在就是要算 <span
class="math inline">\(\prod_{i=1}^m(\omega_m^{ij}+1)\)</span>。</p>
<p>首先考虑 <span class="math inline">\(j=1\)</span>，也就是 <span
class="math inline">\(\prod_{i=1}^m (\omega_m^i + 1) = \prod_{i=0}^{m-1}
(\omega_m^i + 1)\)</span>。</p>
<p>我们知道 <span class="math inline">\(\{\omega_m^i\}_{0\le i &lt;
m}\)</span> 是方程 <span class="math inline">\(x^m-1=0\)</span> 的 <span
class="math inline">\(m\)</span> 个复数解，所以 <span
class="math inline">\(x^m-1\)</span> 可以因式分解为 <span
class="math inline">\(\prod\limits_{0\le i &lt; m} (x -
\omega_m^i)\)</span>，也即 <span class="math inline">\(x^m - 1 =
\prod\limits_{0\le i &lt; m} (x - \omega_m^i)\)</span>。<br />
代入 <span class="math inline">\(x=-1\)</span> 可得：</p>
<p><span class="math display">\[
\begin{aligned}
    (-1)^m - 1 &amp;= \prod_{0\le i &lt; m} (-1 - \omega_m^i)\\
    (-1)^m - 1 &amp;= (-1)^m \prod_{0\le i &lt; m} (\omega_m^i + 1)\\
    \frac{(-1)^m - 1}{(-1)^m} &amp;= \prod_{0\le i &lt; m} (\omega_m^i +
1)\\
    1 - (-1)^m &amp;= \prod_{0\le i &lt; m} (\omega_m^i + 1)
\end{aligned}
\]</span></p>
<p>于是这个问题就解决了。</p>
<p>然后考虑 <span class="math inline">\(j\)</span>
为任意值怎么做。<br />
由于 <span class="math inline">\(\omega_m^{ij} = \omega_m^{ij\bmod
m}\)</span>，所以我们考虑多重集 <span class="math inline">\(\{ij\bmod
m\}_{0\le i &lt; m} = \{0, j \bmod m, 2j \bmod m, \cdots, (m - 1)j \bmod
m\}\)</span> 是长什么样子的。简单手玩可以发现 <span
class="math inline">\(\gcd(j, m) \mid (ij \bmod m)\)</span>，并且每个
<span class="math inline">\(\gcd(j, m)\)</span> （在 <span
class="math inline">\([0, m)\)</span> 以内的）倍数刚好出现 <span
class="math inline">\(\gcd(j, m)\)</span>
次。这个跟数论相关，可以证明的，这里就不详细展开了。然后就比较简单了。考虑推一下式子：（令
<span class="math inline">\(g=\gcd(j, m)\)</span>）</p>
<p><span class="math display">\[
\begin{aligned}
     &amp;\prod_{i=0}^{m-1} (\omega_m^{ij} + 1)\\
    =&amp;\left(\prod_{\gcd(j, m)\mid i}(\omega_m^i + 1)\right)^g\\
    =&amp;\left(\prod_{0\le j &lt; m/g}(\omega_{m/g}^j + 1)\right)^g\\
    =&amp;\left(1 - (-1)^{m/g}\right)^g
\end{aligned}
\]</span></p>
<p>然后就是上面那个问题了。</p>
<p>至此，<span class="math inline">\(G_{m^k}(\omega_m^{ij})\)</span>
就求出来了，那么 <span class="math inline">\(F(\omega_m^{ij})\)</span>
也基本上求出来了。时间复杂度 <span
class="math inline">\(O(mT)\)</span>。</p>
<h3 id="优化">优化</h3>
<p>但是这样还不足以通过。最后一个 Subtask 是 <span
class="math inline">\(m\le 10^7,T\le
10^4\)</span>，我们还需要更加优秀的做法。</p>
<p>考虑把前面推的式子代入到答案里。</p>
<p>首先 <span class="math inline">\(G_{m^k}(\omega_m^j) = \left(1 -
(-1)^{m/g}\right)^{m/g\cdot m^{k-1}}\)</span>。设 <span
class="math inline">\(L=m^l\)</span>，<span
class="math inline">\(R=m^r\)</span>，那么：</p>
<p><span class="math display">\[
\begin{aligned}
    F(\omega_m^j)
    &amp;=\frac{G_R(\omega_m^j)}{G_L(\omega_m^j)}\\
    &amp;=\frac{\left(1-(-1)^{m/g}\right)^{m/g\cdot
m^{r-1}}}{\left(1-(-1)^{m/g}\right)^{g\cdot m^{l-1}}}\\
    &amp;=\left(1-(-1)^{m/g}\right)^{g\cdot (m^{r-1}-m^{l-1})}
\end{aligned}
\]</span></p>
<p>特别地，如果 <span class="math inline">\(L=0\)</span>，那么 <span
class="math inline">\(F(\omega_m^j) = \left(1-(-1)^{m/g}\right)^{g\cdot
m^{r-1}}\)</span>。于是 <span
class="math inline">\(F(\omega_m^j)\)</span> 就有一个 <span
class="math inline">\(\left(1-(-1)^{m/g}\right)^{g\cdot v}\)</span>
的形式，其中 <span class="math inline">\(v\)</span> 是只和 <span
class="math inline">\(L,R\)</span> 相关的常数。</p>
<p>从上面我们也可以看出 <span
class="math inline">\(F(\omega_m^j)\)</span> 的值只和 <span
class="math inline">\(g=\gcd(j, m)\)</span> 有关，于是可以将 <span
class="math inline">\(F\)</span> 代入最开始的式子：</p>
<p><span class="math display">\[
\begin{aligned}
     &amp;\sum_{j=0}^{m-1} F(\omega_m^j)\\
    =&amp;\sum_{j=0}^{m-1} F(\omega_m^{\gcd(j, m)})\\
    =&amp;\sum_{g\mid m} \varphi(\frac mg) F(\omega_m^g)\\
    =&amp;\sum_{g\mid m} \varphi(\frac mg) \left(1 -
(-1)^{m/g}\right)^{g\cdot v}
\end{aligned}
\]</span></p>
<p>枚举因数是 <span class="math inline">\(O(\sqrt m)\)</span>
的，由于需要线性筛 <span
class="math inline">\(\varphi\)</span>，所以复杂度是 <span
class="math inline">\(O(m+T(\sqrt m + \sigma_0(m)\log n))\)</span>。</p>
<h2 id="代码">代码</h2>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">LL k1, k2;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isprm[N];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) isprm[i] = <span class="literal">true</span>;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(isprm[i]) prime.<span class="built_in">emplace_back</span>(i), phi[i] = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p : prime) &#123;</span><br><span class="line">			<span class="keyword">if</span>((LL)p * i &gt; mx) <span class="keyword">break</span>;</span><br><span class="line">			isprm[p * i] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % p == <span class="number">0</span>) &#123;</span><br><span class="line">				phi[i * p] = phi[i] * p;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> phi[i * p] = phi[i] * (p - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL x, LL y)</span> </span>&#123; <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qpow</span><span class="params">(LL x, LL y, LL mod = MOD)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % mod; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % mod; &#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, MOD - <span class="number">2</span>, MOD); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sieve</span>(<span class="number">1e7</span>);</span><br><span class="line">	<span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		LL a1, b1, a2, b2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld%lld%lld&quot;</span>, &amp;m, &amp;a1, &amp;b1, &amp;a2, &amp;b2);</span><br><span class="line">		k1 = <span class="built_in">gcd</span>(a1, b1), k2 = <span class="built_in">gcd</span>(a2, b2);</span><br><span class="line">		LL v;</span><br><span class="line">		<span class="keyword">if</span>(a1 == <span class="number">0</span> || b1 == <span class="number">0</span>) v = <span class="built_in">qpow</span>(m, k2 - <span class="number">1</span>, MOD - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> v = (<span class="built_in">qpow</span>(m, k2 - <span class="number">1</span>, MOD - <span class="number">1</span>) - <span class="built_in">qpow</span>(m, k1 - <span class="number">1</span>, MOD - <span class="number">1</span>) + MOD - <span class="number">1</span>) % (MOD - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// printf(&quot;v = %lld\n&quot;, v);</span></span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; factors;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= m; i++) <span class="keyword">if</span>(m % i == <span class="number">0</span>) &#123;</span><br><span class="line">			factors.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">			<span class="keyword">if</span>(i * i != m) factors.<span class="built_in">emplace_back</span>(m / i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// printf(&quot;factors: &quot;); for(int d : factors) printf(&quot;%d &quot;, d); puts(&quot;&quot;);</span></span><br><span class="line">		LL ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> d : factors) (ans += phi[m / d] * <span class="built_in">qpow</span>(<span class="number">1</span> - ((m / d &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>), d * v % (MOD - <span class="number">1</span>)) % MOD) %= MOD;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans * <span class="built_in">inv</span>(m) % MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
        <category>CatOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组详解</title>
    <url>/post/suffix-array/</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<p><a href="https://oi-wiki.org/string/basic/">字符串基础</a><br />
<a href="https://oi-wiki.org/basic/binary-lifting/">倍增</a><br />
<a href="https://oi-wiki.org/basic/radix-sort/">基数排序</a><br />
<a href="https://oi-wiki.org/basic/counting-sort/">计数排序</a></p>
<h2 id="一些约定">一些约定</h2>
<ol type="1">
<li>字符串下标从 <span class="math inline">\(1\)</span> 开始</li>
<li>字符串 <span class="math inline">\(t\)</span>​ 长度为 <span
class="math inline">\(len(t)\)</span>​。特别的，字符串 <span
class="math inline">\(s\)</span>​ 长度为 <span
class="math inline">\(n\)</span>​</li>
<li>本文中假设字符串只包含 <strong>小写字母</strong></li>
<li><span class="math inline">\(s[l..r]\)</span>​ 表示 <span
class="math inline">\(s_ls_{l+1}\ldots s_r\)</span>​</li>
<li><strong>后缀 <span class="math inline">\(i\)</span>​</strong> 表示
<span class="math inline">\(s[i..n]\)</span>​</li>
<li><strong>排名 <span class="math inline">\(i\)</span>​ 后缀</strong>
表示所有后缀中字典序排名为 <span class="math inline">\(i\)</span>​
的那个的开始位置</li>
</ol>
<h2 id="后缀数组">后缀数组</h2>
<h3 id="什么是后缀数组">什么是后缀数组</h3>
<p><del>后缀数组，顾名思义，就是存了后缀的数组</del>。</p>
<p>其实后缀数组就是把所有后缀放在一起，然后按字典序排序。</p>
<p>盗一张 OI Wiki 的图。</p>
<img data-src="/post/suffix-array/sa1.png" class="" title="何为后缀数组">
<h3 id="后缀数组求法">后缀数组求法</h3>
<p>求后缀数组的方法很多，比如说 <span class="math inline">\(O(n^2 \log
n)\)</span>​ 暴力，或者 <span class="math inline">\(O(n \log^2
n)\)</span>​ 哈希，还有两种 <span class="math inline">\(O(n)\)</span>​​​​​​
做法（<a
href="https://riteme.site/blog/2016-6-19/sais.html">SA-IS</a>，<a
href="https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html">DC3</a>，链接来自
OI Wiki 推荐），以及本文要讲的 <strong>倍增算法</strong>。</p>
<h3 id="算法思想">算法思想</h3>
<p>暴力的想法是，首先我们比较每个后缀 <span
class="math inline">\(i\)</span>​​ 的第 <span
class="math inline">\(1\)</span>​​ 个字符，然后比较第 <span
class="math inline">\(2\)</span>​​ 个，然后第 <span
class="math inline">\(3\)</span> 个……一直到第 <span
class="math inline">\(n\)</span> 个。但这样是 <span
class="math inline">\(O(n^2)\)</span>​​ 的。</p>
<p>那怎么优化它呢？别忘了我们的算法叫倍增啊！当我们对一个后缀 <span
class="math inline">\(i\)</span> 的前 <span
class="math inline">\(w\)</span> 位排完序时，后缀 <span
class="math inline">\(i\)</span> 的后面 <span
class="math inline">\(w\)</span>
位的顺序我们也是知道的！这时我们只需要对于后缀 <span
class="math inline">\(i\)</span> 中前 <span
class="math inline">\(w\)</span> 位的排名和后缀 <span
class="math inline">\(i\)</span> 中 <span class="math inline">\([w + 1
.. 2w]\)</span> 位的排名进行双关键字排序，就可以得到后缀 <span
class="math inline">\(i\)</span> 中前 <span
class="math inline">\(2w\)</span> 位的排名啦！</p>
<p><del>再盗一张 OI Wiki 的图</del></p>
<img data-src="/post/suffix-array/sa2.png" class="" title="后缀数组思想">
<h3 id="具体实现">具体实现</h3>
<blockquote>
<p>如果不想看 TLE 代码，可以直接移步到 <a
href="#优化实现">优化实现</a>，前面的内容是为优化实现作铺垫的。</p>
</blockquote>
<h4 id="变量约定">变量约定</h4>
<ul>
<li><code>sa[i]</code> — 排名 <span class="math inline">\(i\)</span>
后缀的开始位置</li>
<li><code>rk[i]</code> — 后缀 <span class="math inline">\(i\)</span>
的排名</li>
<li><code>tp[i]</code> — 即 temp，辅助数组，具体意思下面会说</li>
<li><code>p</code> — 辅助变量，具体意思下面会说</li>
</ul>
<h4 id="sort-实现">sort 实现</h4>
<p>现在我们可以写出代码啦！每次暴力更新第一、二关键字，用 sort
排序就好啦！</p>
<details class="note info"><summary><p>代码</p>
</summary>
<p>代码来自 OI Wiki，变量大致是一样的（<del>其实是我懒</del>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, w, sa[N], rk[N &lt;&lt; <span class="number">1</span>], oldrk[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 为了防止访问 rk[i+w] 导致数组越界，开两倍数组。</span></span><br><span class="line"><span class="comment">// 当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, p;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">  n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) sa[i] = i, rk[i] = s[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (w = <span class="number">1</span>; w &lt; n; w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(sa + <span class="number">1</span>, sa + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">      <span class="keyword">return</span> rk[x] == rk[y] ? rk[x + w] &lt; rk[y + w] : rk[x] &lt; rk[y];</span><br><span class="line">    &#125;);  <span class="comment">// 这里用到了 lambda</span></span><br><span class="line">    <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">    <span class="comment">// 由于计算 rk 的时候原来的 rk 会被覆盖，要先复制一份</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldrk[sa[i]] == oldrk[sa[i - <span class="number">1</span>]] &amp;&amp;</span><br><span class="line">          oldrk[sa[i] + w] == oldrk[sa[i - <span class="number">1</span>] + w]) &#123;</span><br><span class="line">        rk[sa[i]] = p;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rk[sa[i]] = ++p;</span><br><span class="line">      &#125;  <span class="comment">// 若两个子串相同，它们对应的 rk 也需要相同，所以要去重</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sa[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>这样我们就可以 AC 了！</p>
<img data-src="/post/suffix-array/sort-judge.png" class="" title="sort 评测详情">
<p><del>好打脸！</del></p>
<p>算啦，常数才不是我们要管的事，加 O2 不就能过了。<br />
但是！这样算法不就成 <span class="math inline">\(O(n \log^2 n)\)</span>
的了？我们的 <del>优秀</del> 算法怎么能允许这样的事出现？</p>
<h4 id="基数排序实现">基数排序实现</h4>
<p>要让算法的复杂度为 <span class="math inline">\(O(n \log
n)\)</span>，就要在排序上下功夫。<br />
双关键字排序，我们可以用基数排序（其中稳定排序使用计数排序）！<br />
于是，排序复杂度降为 <span class="math inline">\(O(n \log
n)\)</span>​。</p>
<details class="note info"><summary><p>代码</p>
</summary>
<p><del>再次盗用 OI Wiki 的代码</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, sa[N], rk[N &lt;&lt; <span class="number">1</span>], oldrk[N &lt;&lt; <span class="number">1</span>], id[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, m, p, w;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">  n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  m = <span class="built_in">max</span>(n, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rk[i] = s[i]];</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; --i) sa[cnt[rk[i]]--] = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (w = <span class="number">1</span>; w &lt; n; w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = sa[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rk[id[i] + w]];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; --i) sa[cnt[rk[id[i] + w]]--] = id[i];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = sa[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rk[id[i]]];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; --i) sa[cnt[rk[id[i]]]--] = id[i];</span><br><span class="line">    <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldrk[sa[i]] == oldrk[sa[i - <span class="number">1</span>]] &amp;&amp;</span><br><span class="line">          oldrk[sa[i] + w] == oldrk[sa[i - <span class="number">1</span>] + w]) &#123;</span><br><span class="line">        rk[sa[i]] = p;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rk[sa[i]] = ++p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sa[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>这下终于可以 AC 了。</p>
<img data-src="/post/suffix-array/base-judge.png" class="" title="基数排序评测详情">
<p><del>打脸第二次</del></p>
<p>为什么！明明复杂度是正确的！<br />
但是，这份代码的常数确实太大了。</p>
<h4 id="优化实现">优化实现</h4>
<p>其实，基数排序中第二关键字可以不用计数排序，而是直接在存入时就排好序。</p>
<p>这里用我的代码详细讲解。（<del>终于不是 OI Wiki 了</del>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main code</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sa 和 rk 开两倍的原因是有可能访问越界，当然也可以判越界</span></span><br><span class="line"><span class="comment">// tot 用于计数排序</span></span><br><span class="line"><span class="type">int</span> sa[N &lt;&lt; <span class="number">1</span>], rk[N &lt;&lt; <span class="number">1</span>], tot[N], tp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">()</span> </span>&#123; <span class="comment">// 计数排序并处理出 sa</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) tot[j] = <span class="number">0</span>; <span class="comment">// 桶清零</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) tot[rk[j]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) tot[j] += tot[j - <span class="number">1</span>]; <span class="comment">// 计数排序套路</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--) sa[tot[rk[tp[j]]]--] = tp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) rk[j] = s[j], tp[j] = j;</span><br><span class="line">	<span class="built_in">Sort</span>(); <span class="comment">// 由于下面不会用到 rk，所以不用处理 rk，当然处理了也没错</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; i &lt;&lt;= <span class="number">1</span>, m = p) &#123; <span class="comment">// i 即上文的 w</span></span><br><span class="line">		p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) tp[++p] = n - i + j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(sa[j] &gt; i) tp[++p] = sa[j] - i;</span><br><span class="line">		<span class="built_in">Sort</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) tp[j] = rk[j]; <span class="comment">// 由于 tp 不会再用到，我们用 tp 来表示上一轮的 rk</span></span><br><span class="line">		rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">			rk[sa[j]] = ((tp[sa[j - <span class="number">1</span>]] == tp[sa[j]] &amp;&amp; tp[sa[j - <span class="number">1</span>] + i] == tp[sa[j] + i]) ? p : ++p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分比较复杂，下面是详细讲解。</p>
<h5 id="第一部分">第一部分</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code 1.1 (main code, Line 10~25)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">()</span> </span>&#123; <span class="comment">// 计数排序并处理出 sa</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) tot[j] = <span class="number">0</span>; <span class="comment">// 桶清零</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) tot[rk[j]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) tot[j] += tot[j - <span class="number">1</span>]; <span class="comment">// 计数排序套路</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--) sa[tot[rk[tp[j]]]--] = tp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看计数排序。计数排序的这里的作用是对第一关键字作稳定排序。下面分句看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) tot[rk[j]]++; <span class="comment">// Code 1.1, Line 4</span></span><br></pre></td></tr></table></figure>
<p>这里将所有的后缀 <span class="math inline">\(i\)</span>
的排名记录到桶里。注意此时 <code>rk</code>
有可能相同，但排到最后肯定是不同的（因为长度都不同）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--) sa[tot[rk[tp[j]]]--] = tp[j]; <span class="comment">// Code 1.1, Line 6</span></span><br></pre></td></tr></table></figure>
<p>这里更新 <code>sa</code>，先说一下此时每个数组的意思。</p>
<ul>
<li><code>tp[i]</code> — 第二关键字排名为 <span
class="math inline">\(i\)</span>
的后缀的开始位置（至于为什么不直接记录后缀 <span
class="math inline">\(i\)</span> 的第二关键字，到后面就懂了）</li>
<li><code>rk[i]</code> — 上一轮排完后后缀 <span
class="math inline">\(i\)</span> 的排名，此处是后缀 <span
class="math inline">\(i\)</span> 的第一关键字。</li>
</ul>
<p>那么这句话就是枚举 <strong>第二关键字的排名</strong> <span
class="math inline">\(j\)</span>，那么 <code>tp[j]</code>
就是当前枚举的（第二关键字排名为 <span class="math inline">\(j\)</span>
的）字符串的开头，又因为 <code>sa[i]</code> 表示排名 <span
class="math inline">\(i\)</span> 后缀的开头，所以这句话就是说：<br />
将当前枚举字符串的 <code>tot</code> 作为这个字符串的排名，并将
<code>tot</code> 自减（<code>tot</code> 自减是计数排序的套路）。</p>
<p>注意到需要的是稳定排序，所以枚举是倒序的。</p>
<h5 id="第二部分">第二部分</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code 1.2 (main code, Line 20)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; i &lt;&lt;= <span class="number">1</span>, m = p) <span class="comment">// i 即上文的 w</span></span><br></pre></td></tr></table></figure>
<p>这里的 <span class="math inline">\(p\)</span>
指的是已经排出的不同后缀的个数。</p>
<h5 id="第三部分">第三部分</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code 1.3 (main code, Line 21~23)</span></span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) tp[++p] = n - i + j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(sa[j] &gt; i) tp[++p] = sa[j] - i;</span><br></pre></td></tr></table></figure>
<p>这一部分是对第二关键字进行排序，也就是更新 <code>tp</code>。<br />
这里 <code>sa</code> 就是原来的意思，<code>tp</code>
还是表示第二关键字排名为 <span class="math inline">\(i\)</span>
的后缀的开始位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) tp[++p] = n - i + j; <span class="comment">// Code 1.3, Line 3</span></span><br></pre></td></tr></table></figure>
<p>这里是将后缀 <span class="math inline">\(n - i + 1 .. n\)</span>
进行排序，对于这些后缀，它们是没有第 <span class="math inline">\(i + 1
.. 2i\)</span> 位的，所以要单独处理。<br />
当然，对于这部分，长度越小排名越前。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(sa[j] &gt; i) tp[++p] = sa[j] - i; <span class="comment">// Code 1.3, Line 4</span></span><br></pre></td></tr></table></figure>
<p>这一部分是对那些剩下的后缀（即后缀 <span class="math inline">\(1 .. n
- i\)</span>）排序，这里可以理解为我们在枚举
<code>sa[j]</code>，即按第一次的排名枚举后缀。实际上，我们枚举的是剩下后缀的第
<span class="math inline">\(i+1\)</span>
位，即第二关键字开始的位。所以这里就是说：<br />
按上次的排名枚举后缀 <span class="math inline">\(j\)</span>​，并将后缀
<span class="math inline">\(j - i\)</span> 作为第 <span
class="math inline">\(p\)</span> 小的字符串，并将 <span
class="math inline">\(p\)</span>​ 自增。​</p>
<h5 id="第四部分">第四部分</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code 1.4 (main code, Line 26~28)</span></span><br><span class="line">rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">    rk[sa[j]] = ((tp[sa[j - <span class="number">1</span>]] == tp[sa[j]] &amp;&amp; tp[sa[j - <span class="number">1</span>] + i] == tp[sa[j] + i]) ? p : ++p);</span><br></pre></td></tr></table></figure>
<p>这里是对 <span class="math inline">\(rk\)</span>​
进行更新。此时各个数组的意义：</p>
<ul>
<li><code>rk[i]</code> — 这一轮后缀 <span
class="math inline">\(i\)</span> 的排名</li>
<li><code>sa[i]</code> — 这一轮排名 <span
class="math inline">\(i\)</span> 后缀开始的位置</li>
<li><code>tp[i]</code> — 上一轮后缀 <span
class="math inline">\(i\)</span> 的排名</li>
<li><span class="math inline">\(p\)</span> — 已经排出的不同排名个</li>
</ul>
<p>这一部分就一起解释吧。</p>
<p>第 2 行将排名 <span class="math inline">\(1\)</span> 后缀的排名和
<span class="math inline">\(p\)</span> 置为 <span
class="math inline">\(1\)</span>。（其实此时 <span
class="math inline">\(p\)</span>
还是计数器，不过计数完了就成了不同排名个数）<br />
然后比较相邻两个字符串（用上一轮的 <span
class="math inline">\(rk\)</span> 进行比较），不同将排名个数 <span
class="math inline">\(p\)</span> 加一。</p>
<h4 id="压行实现">压行实现</h4>
<p>不讲。</p>
<details class="note info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sa[N &lt;&lt; <span class="number">1</span>], rk[N &lt;&lt; <span class="number">1</span>], tot[N], tp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; p &lt; n; i = (i ? i &lt;&lt; <span class="number">1</span> : <span class="number">1</span>), m = p) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i) &#123;</span><br><span class="line">			p = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) tp[++p] = n - i + j;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(sa[j] &gt; i) tp[++p] = sa[j] - i;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) rk[j] = s[j], tp[j] = j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) tot[j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) tot[rk[j]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) tot[j] += tot[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--) sa[tot[rk[tp[j]]]--] = tp[j];</span><br><span class="line">		<span class="keyword">if</span>(!i) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) tp[j] = rk[j];</span><br><span class="line">		rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">			rk[sa[j]] = ((tp[sa[j - <span class="number">1</span>]] == tp[sa[j]] &amp;&amp; tp[sa[j - <span class="number">1</span>] + i] == tp[sa[j] + i]) ? p : ++p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="height-数组">height 数组</h2>
<h3 id="定义">定义</h3>
<h4 id="lcp-定义">LCP 定义</h4>
<p><span class="math inline">\(lcp(s, t)\)</span> 表示字符串 <span
class="math inline">\(s\)</span> 和 <span
class="math inline">\(t\)</span> 的最长公共前缀，也即最大的 <span
class="math inline">\(i\)</span> 满足 <span
class="math inline">\(s[1..i]=t[1..i]\)</span>​。</p>
<h3 id="height-数组定义">height 数组定义</h3>
<p><span class="math inline">\(height[i] = lcp(sa[i], sa[i -
1])\)</span>​，即 <span class="math inline">\(height[i]\)</span> 表示排名
<span class="math inline">\(i\)</span> 和 <span class="math inline">\(i
- 1\)</span> 后缀的 LCP。</p>
<h3 id="引理">引理</h3>
<p>引理：<span class="math inline">\(height[rk[i]] \ge height[rk[i - 1]]
- 1\)</span>，即<strong>后缀 <span class="math inline">\(i\)</span>​
和排名前一位的后缀的LCP</strong> 不小于 <strong>后缀 <span
class="math inline">\(i\)</span>​ 排名前一位的和前两位的LCP</strong>
<span class="math inline">\(-1\)</span>。</p>
<p>证明：（<del>我不会证</del>我懒，所以找了 OI Wiki 的证明
<del>怎么又是 OI Wiki</del>）</p>
<img data-src="/post/suffix-array/height.png" class="" title="height 引理证明">
<h3 id="代码实现">代码实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123; <span class="comment">// ht[] 就是 height</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[i] == <span class="number">1</span>) &#123; ht[rk[i]] = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(k) k--;</span><br><span class="line">        <span class="type">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k++;</span><br><span class="line">        ht[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://oi-wiki.org/string/sa/">OI Wiki</a></p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>快速傅里叶变换（FFT）及快速数论变换（NTT）详解</title>
    <url>/post/fast-fourier-transform/</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<p><a href="https://oi-wiki.org/math/complex/">复数</a><br />
单位根（下面讲）<br />
多项式（下面讲）</p>
<h3 id="单位根">单位根</h3>
<p>前置知识：<a href="https://oi-wiki.org/math/complex/">复数</a></p>
<p>在复平面上，所有与原点距离为 <span class="math inline">\(1\)</span>
的点组成单位圆。<br />
由于两个复数相乘的法则（辐角相加，模长相乘），在单位圆上的两个复数相乘还是在单位圆上（模长都是
<span class="math inline">\(1\)</span>），且辐角为这两个复数相加。<br />
所以对于 <span class="math inline">\(x^n=1\)</span>
这个方程来说，它的解在单位圆上，且辐角为 <span
class="math inline">\(\frac{360}{n}\)</span> 的倍数，显然这样的复数有
<span class="math inline">\(n\)</span> 个，我们把这样的 <span
class="math inline">\(n\)</span> 个复数叫做 <strong><span
class="math inline">\(n\)</span>
次单位根</strong>，并将其中辐角最小的（<span
class="math inline">\(1\)</span> 除外）记作 <span
class="math inline">\(\omega_n\)</span>。<br />
所有 <span class="math inline">\(\omega_n^i\)</span> 都是 <span
class="math inline">\(n\)</span> 次单位根。</p>
<img data-src="/post/fast-fourier-transform/%E5%8D%95%E4%BD%8D%E6%A0%B9.png" class="" title="单位根">
<p>上图就是 <strong><span class="math inline">\(11\)</span>
次单位根</strong> 在复平面上的表示。</p>
<p>单位根有三个引理：（<del>证明显然</del>）</p>
<ol type="1">
<li>消去引理：<span class="math inline">\(\omega_{kn}^{km} =
\omega_n^m\)</span></li>
<li>折半引理：<span
class="math inline">\(\left(\omega_{n}^{k+\frac{n}{2}}\right)^2=\omega_{n}^{2k}=\omega_{\frac{n}{2}}^k\)</span></li>
<li>求和引理：<span class="math inline">\(\sum_{i=0}^{n-1}
\left(\omega_n^k\right)^i = 0\)</span></li>
</ol>
<p>在 FFT 中，我们只需要用前两个。</p>
<h3 id="多项式">多项式</h3>
<p>这里我们讨论的多项式是只有一个变量 <span
class="math inline">\(x\)</span> 的多项式，即 <span
class="math inline">\(F(x) = \sum_{i=0}^n a_i x^i\)</span>。</p>
<p>多项式有两种表示方法：（设多项式有 <span class="math inline">\(n +
1\)</span> 项）</p>
<ol type="1">
<li>系数表示，即将多项式表示成：<span class="math inline">\([a_0, a_2,
\cdots, a_n]\)</span>，其中 <span class="math inline">\(a_i\)</span> 为
<span class="math inline">\(x^i\)</span> 项的系数</li>
<li>点值表示，即将多项式表示成：<span class="math inline">\([(v_0,
F(v_0)), (v_1, F(v_1)), \cdots, (v_n, F(v_n))]\)</span>，即将 <span
class="math inline">\(n + 1\)</span> 个不同的值 <span
class="math inline">\(v_i\)</span> 带入多项式得到 <span
class="math inline">\(F(v_i)\)</span>，然后用这 <span
class="math inline">\(n + 1\)</span>
个二元组唯一确定一个多项式。（不考虑那种无用点值之类的东西）</li>
</ol>
<p>容易发现，对于两个多项式 <span class="math inline">\(F(x)\)</span> 和
<span class="math inline">\(G(x)\)</span>，设 <span
class="math inline">\(H(x) = F(x) \times G(x)\)</span>，如果有 <span
class="math inline">\(F\)</span> 和 <span
class="math inline">\(G\)</span> 的点值表示，那么 <span
class="math inline">\(H\)</span> 的点值表示也可以很快算出来：<span
class="math inline">\(H(v_i) = F(v_i) \times G(v_i)\)</span>。</p>
<p>所以，FFT
要做的事就是将系数表示转换成点值表示（及其逆过程，这个后面再说）。</p>
<h2 id="fft">FFT</h2>
<h3 id="几个概念">几个概念</h3>
<ol type="1">
<li>离散傅里叶变换（Discrete Fourier Transform，DFT），即
<strong>将系数表示转换成点值表示</strong>，其中 <span
class="math inline">\(v_i = \omega_n^i\)</span>。</li>
<li>快速傅里叶变换（即 <strong>快速（离散）傅里叶变换</strong>，Fast
(Discrete) Fourier Transform，FFT），即快速做 DFT。</li>
</ol>
<h3 id="思路">思路</h3>
<div class="note warning"><p>从这里开始，我们将 <span class="math inline">\(n\)</span>
定为多项式的项数，而不是多项式的次数。</p>
</div>
<p>FFT 可以（且必须）直接计算 <span class="math inline">\(2^k\)</span>
个点值，所以我们将 <span class="math inline">\(n\)</span>
取到比它大（或等于它）的最小的 <span class="math inline">\(2\)</span>
的幂次。（<span class="math inline">\(n \gets 2^k\)</span>）</p>
<p>设多项式为 <span class="math inline">\(F(x) = \sum_{i=0}^{n - 1} a_i
x^i\)</span>，并且令点值表示法为 <span class="math inline">\([(v_0,
y_0), (v_1, y_1), \cdots, (v_{n-1}, y_{n-1})]\)</span>。<br />
容易发现 <span class="math inline">\(y_i = \sum_{j=0}^n a_j (v_i)^j =
\sum_{j=0}^n a_j v_i^j\)</span>。</p>
<p>我们首先将 <span class="math inline">\(F(x)\)</span> 的系数 <span
class="math inline">\(A = [a_0, a_1, \cdots, a_{n - 1}]\)</span>
按奇偶分为 <span class="math inline">\(A^{[0]}\)</span> 和 <span
class="math inline">\(A^{[1]}\)</span>，即：<br />
<span class="math inline">\(A^{[0]} = [a_0, a_2, \cdots, a_{n -
2}]\)</span>, <span class="math inline">\(A^{[1]} = [a_1, a_3, \cdots,
a_{n - 1}]\)</span>。</p>
<p>那么我们会发现 <span class="math inline">\(F(x) = F^{[0]}(x^2) +
xF^{[1]}(x^2)\)</span>，<del>读者自证不难</del>。<br />
所以我们就有了一个分治想法：用 <span
class="math inline">\(F^{[0]}\)</span> 和 <span
class="math inline">\(F^{[1]}\)</span> 的点值表示来算出 <span
class="math inline">\(F\)</span> 的点值表示。</p>
<p>但是这里会有一个问题：<span class="math inline">\(F^{[0]}\)</span> 和
<span class="math inline">\(F^{[1]}\)</span> 的点值表示都只有 <span
class="math inline">\(\frac n2\)</span> 个，所以合并后也只有 <span
class="math inline">\(\frac n2\)</span> 个。<br />
所以我们还需要用 <span class="math inline">\(F^{[0]}\)</span> 和 <span
class="math inline">\(F^{[1]}\)</span> 的 <span
class="math inline">\(\frac n2\)</span> 个点值来求出 <span
class="math inline">\(F\)</span> 的后 <span class="math inline">\(\frac
n2\)</span> 个点值。</p>
<p>这怎么办呢？随便取 <span class="math inline">\((v_i, y_i)\)</span>
的值肯定是无法做到的，我们要取一些有特殊性质的值。现在就要用到我们之前说的单位根了。</p>
<p>我们取 <span class="math inline">\(v_i =
\omega_n^i\)</span>，这有什么用呢？我们代两个值进去看看：（记 <span
class="math inline">\(k&#39; = k + \frac n2\)</span>）</p>
<p><span class="math display">\[
\begin{aligned}
   F(v_k) = F(\omega_n^k) = F^{[0]}((\omega_n^k)^2) + \omega_n^k
F^{[1]}((\omega_n^k)^2) = F^{[0]}(\omega_{\frac n2}^k) + \omega_n^k
F^{[1]}(\omega_{\frac n2}^k)\\
   F(v_{k&#39;}) = F(\omega_n^{k&#39;}) = F^{[0]}((\omega_n^{k&#39;})^2)
+ \omega_n^{k&#39;} F^{[1]}((\omega_n^{k&#39;})^2) =
F^{[0]}(\omega_{\frac n2}^k) - \omega_n^k F^{[1]}(\omega_{\frac n2}^k)
\end{aligned}
\]</span></p>
<p>所以我们只需要用 <span class="math inline">\(F^{[0]}\)</span> 和
<span class="math inline">\(F^{[1]}\)</span> 点值表示就可以直接求出
<span class="math inline">\(F\)</span> 的点值表示啦。</p>
<p>然后怎么办呢？对于 <span class="math inline">\(n = 1\)</span>
的情况，<span class="math inline">\(F(x) = A_0 x\)</span>，又由于 <span
class="math inline">\(n = 1\)</span>，所以 <span
class="math inline">\(x_0 = 1\)</span>，那么 <span
class="math inline">\(F(x)\)</span> 的点值表示就是 <span
class="math inline">\(A_0\)</span> 啦。</p>
<h3 id="非递归写法">非递归写法</h3>
<p>由于 FFT
非常的常用，常数也很大，所以我们需要一定的卡常技巧。<del>为了学习隔壁的
zkw 线段树</del>我们发明出了 FFT 的非递归写法。</p>
<p>首先我们发现，只要求出所有 <span class="math inline">\(n = 1\)</span>
时的点值表示，其它的就可以轻松地用循环求出（把递归树画出来，用循环模拟过程。因为
<span class="math inline">\(n\)</span> 是 2 的幂次，所以很好模拟）。</p>
<p>所以现在我们只需要求出 <span class="math inline">\(n = 1\)</span>
时的点值表示。考虑一个递归过程：（每次将上面一行 <span
class="math inline">\(A\)</span> 分成两个 <span
class="math inline">\(A^{[0]}\)</span> 和 <span
class="math inline">\(A^{[1]}\)</span>，将两个数组用 <code>|</code>
隔开）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(8): a[0]   a[1]   a[2]   a[3]   a[4]   a[5]   a[6]   a[7]</span><br><span class="line">F(4): a[0]   a[2]   a[4]   a[6] | a[1]   a[3]   a[5]   a[7]</span><br><span class="line">F(2): a[0]   a[4] | a[2]   a[6] | a[1]   a[5] | a[3]   a[7]</span><br><span class="line">F(1): a[0] | a[4] | a[2] | a[6] | a[1] | a[5] | a[3] | a[7]</span><br></pre></td></tr></table></figure>
<p>我们再来看最后一行的下标，这次我们用二进制表示出来：（上面是十进制，下面是二进制）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0   4   2   6   1   5   3   7</span><br><span class="line">000 100 010 110 001 101 011 111</span><br></pre></td></tr></table></figure>
<p>这个二进制有什么规律呢？我们将每个二进制倒过来并转成十进制看看：（上面是倒过来的二进制，下面是十进制）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000 001 010 011 100 101 110 111</span><br><span class="line"> 0   1   2   3   4   5   6   7</span><br></pre></td></tr></table></figure>
<p>现在规律已经很明显了。我们要求的数在二进制意义下倒过来是顺序排列的，我们把这种序列叫做
<strong>逆二进制序</strong>。</p>
<p>那么现在我们就解决了非递归版的 FFT。</p>
<p>代码在最后面。</p>
<h2 id="逆-fftifft">逆 FFT（IFFT）</h2>
<p>我们再回到之前的公式：<span class="math inline">\(y_i = \sum_{j=0}^n
a_j \omega_n^{ij}\)</span>。<br />
我们把它写成矩阵：<span class="math inline">\(\textbf{y} = \textbf{V}_n
\times \textbf{a}\)</span>，其中 <span
class="math inline">\(\left(\textbf{V}_n\right)_{i,j} =
\omega_n^{ij}\)</span>。<br />
所以 <span class="math inline">\(\textbf{a} = \textbf{V}_n^{-1}
\textbf{y}\)</span>，其中 <span
class="math inline">\(\textbf{V}_n^{-1}\)</span> 是 <span
class="math inline">\(\textbf{V}\)</span> 的逆矩阵。<br />
通过某些<del>我不会的</del>方法算出来：<span
class="math inline">\(\left(\textbf{V}_n^{-1}\right)_{i,j} =
\frac{\omega_n^{-ij}}{n}\)</span>。<br />
然后就用 FFT 的方法，改一下公式就好了。</p>
<p>代码在最后面。</p>
<h2 id="ntt">NTT</h2>
<p>FFT 的优势很多，但是缺陷也很明显：需要用
<code>double</code>，所以会有精度问题，而且不能取模。</p>
<p>那么有没有其它的东西可以支持取模且没有精度问题呢？当然是有的，这就是快速数论变换（NTT，Number
Theoretic Transform）。</p>
<p>这里的 NTT 解决的是模数为 <span
class="math inline">\(998244353\)</span>
的做法。如果是其它的模数，需要使用下面的 <a
href="#任意模数-nttmtt">任意模数 NTT</a>。</p>
<p>首先观察一下 <span class="math inline">\(998244353\)</span>
的性质：（数论不懂的可以看看我 <a
href="/post/number-theory-initial/">这篇</a> 博客）</p>
<ul>
<li>它是一个质数。</li>
<li><span class="math inline">\(\varphi(998244353) = 998244352 = 2^{23}
\times 7 \times 17\)</span></li>
<li>它有 <a
href="https://oi-wiki.org/math/number-theory/primitive-root/#_4">原根</a>，其中一个是
<span class="math inline">\(3\)</span>。</li>
</ul>
<details class="note no-icon info"><summary><p>什么是原根？</p>
</summary>
<p>对于两个数 <span class="math inline">\(a\)</span> 和 <span
class="math inline">\(m\)</span>，如果 <span
class="math inline">\(\gcd(a, m) = 1\)</span>，那么我们有 <span
class="math inline">\(a^{\varphi(m)} \equiv 1 \pmod
m\)</span>（欧拉定理）。</p>
<p>如果对于任意 <span class="math inline">\(0 \le n &lt;
\varphi(m)\)</span>，满足 <span class="math inline">\(a^n \not \equiv 1
\pmod m\)</span>，那么我们称 <span class="math inline">\(a\)</span> 是
<span class="math inline">\(m\)</span> 的原根。</p>

</details>
<p>我们回到 FFT 上来。当时我们为什么要令 <span class="math inline">\(x_i
= \omega_n^i\)</span> 呢？因为它满足一下几条性质：</p>
<ul>
<li><span class="math inline">\(\{\omega_n^i\} (0 \le i &lt; n)\)</span>
互不相同</li>
<li><span class="math inline">\(\omega_{km}^{kn} =
\omega_m^n\)</span></li>
<li><span
class="math inline">\(\left(\omega_{n}^{k+\frac{n}{2}}\right)^2=\omega_{n}^{2k}=\omega_{\frac{n}{2}}^k\)</span></li>
</ul>
<p>那么我们用原根是否也能做到这几条性质呢？答案是可以。</p>
<p>记原根为 <span class="math inline">\(g\)</span>（模数为 <span
class="math inline">\(998244353\)</span> 时 <span
class="math inline">\(g=3\)</span>），那么我们令 <span
class="math inline">\(g_n = g^{p - 1 \over n}\)</span>，并令 <span
class="math inline">\(x_i = g_n^i\)</span>。</p>
<p>那么我们可以证明这几条性质：（第一条上面 OI-Wiki 的链接里有，我
<del>不会证</del> 就不证了）</p>
<ul>
<li><span class="math inline">\(g_{km}^{kn} = g^{\frac{km(p - 1)}{kn}} =
g^{\frac{m(p - 1)}{n}} = g_m^n\)</span></li>
<li><span class="math inline">\(\left(g_n^{k + \frac n2}\right)^2 =
g_n^{2k+n} = g_n^{2k} = g_{\frac n2}^k\)</span></li>
</ul>
<p>那么我们就完美解决了所有性质，把 FFT 的板子套上去，换成 NTT
的公式就好了。</p>
<p>这时候有小可爱可能就会问了：你这个 <span
class="math inline">\(g^{\frac{p - 1}{n}}\)</span> 中指数 <span
class="math inline">\(\frac{p - 1}{n}\)</span>
有没有可能不是整数啊？</p>
<p>这就要用到上面的质因数分解了：<span class="math inline">\(p - 1 =
998244352 = 2^{23} \times 7 \times 17\)</span>，又因为前面我们把 <span
class="math inline">\(n\)</span> 调整为 <span
class="math inline">\(2\)</span> 的幂次了，所以当 <span
class="math inline">\(n \le 2^{23} = 8388608 \approx 8.3 \times
10^6\)</span> 时都是够用的啦。</p>
<p>另外，这种方法不止适用于 <span
class="math inline">\(998244353\)</span>，还有 <span
class="math inline">\(469762049\)</span> 和 <span
class="math inline">\(1004535809\)</span>。（它们的原根都是 <span
class="math inline">\(3\)</span> 哦）</p>
<p>另外一些数也可以用这种方法，参见 <a
href="https://paste.ubuntu.com/p/nFswQRkZmJ/">原根表</a>。</p>
<p>代码在最后面。</p>
<h2 id="任意模数-nttmtt">任意模数 NTT（MTT）</h2>
<p>如果模数不是上面的，或者在输入中给定，又怎么办呢？</p>
<p>这时候就需要 <strong>任意模数 NTT</strong>（any Module NTT）了。</p>
<p>对于任意模数，我们无法得到上面的性质了。怎么办呢？我们可以自己取模数！</p>
<p>具体地，我们取一些模数 <span class="math inline">\(p_1, p_2, \cdots
p_k\)</span> 使得答案多项式的系数在 <strong>取模之前</strong> 不会超过
<span class="math inline">\(\prod p_i\)</span>。一般来说取 <span
class="math inline">\(3\)</span> 个质数（<span
class="math inline">\(998244353\)</span>，<span
class="math inline">\(469762049\)</span>，<span
class="math inline">\(1004535809\)</span>）就够了。</p>
<p>然后我们先算出答案对每个 <span class="math inline">\(p_i\)</span>
取模的结果，利用 CRT 就可以求得答案对 <span class="math inline">\(\prod
p_i\)</span> 取模的结果。又因为答案小于 <span
class="math inline">\(\prod p_i\)</span>，所以这个结果就是答案。（可以在
CRT 的过程中就对原题模数取模，这样就不会爆
<code>long long</code>）然后将这个答案对题目中的模数取一次模就好了。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4245">洛谷
P4245</a></p>
<p>代码在最后面。</p>
<h2 id="代码">代码</h2>
<p>都是非递归版的。</p>
<details class="note no-icon info"><summary><p>FFT 和 IFFT</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="comment">/* ... */</span> + <span class="number">5</span>; <span class="comment">// 2 * (n + m)</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> x_ = <span class="number">0</span>, <span class="type">double</span> y_ = <span class="number">0</span>) : <span class="built_in">x</span>(x_), <span class="built_in">y</span>(y_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;a, <span class="type">const</span> Complex &amp;b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;a, <span class="type">const</span> Complex &amp;b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;a, <span class="type">const</span> Complex &amp;b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FFT</span> &#123;</span><br><span class="line">	<span class="type">int</span> rev[N];</span><br><span class="line">	<span class="type">int</span> limit;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">		limit = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(limit &lt;= mx) limit &lt;&lt;= <span class="number">1</span>, w++; <span class="comment">// w = log2(limit)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (w - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(Complex *a, <span class="type">int</span> type)</span> </span>&#123; <span class="comment">// type = 1 / -1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) <span class="keyword">if</span>(i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			Complex wn = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(PI / i), type * <span class="built_in">sin</span>(PI / i));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++, w = w * wn) &#123;</span><br><span class="line">					Complex x = a[j + k], y = w * a[j + i + k];</span><br><span class="line">					a[j + k] = x + y;</span><br><span class="line">					a[j + i + k] = x - y;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">-1</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) a[i].x /= limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">trans</span><span class="params">(Complex *a, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123; <span class="type">int</span> ret = <span class="built_in">init</span>(n); <span class="built_in">trans</span>(a, type); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 需要先 init 再调用第一个 trans，或者直接调用第二个 trans</span></span><br></pre></td></tr></table></figure>

</details>
<details class="note no-icon info"><summary><p>NTT</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="comment">/* ... */</span> + <span class="number">5</span>; <span class="comment">// 2 * (n + m)</span></span><br><span class="line"><span class="keyword">template</span>&lt;LL mod, LL g&gt; <span class="keyword">struct</span> <span class="title class_">NTT</span> &#123;</span><br><span class="line">	<span class="type">int</span> rev[N];</span><br><span class="line">	<span class="type">int</span> limit;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">		limit = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(limit &lt;= mx) limit &lt;&lt;= <span class="number">1</span>, w++; <span class="comment">// w = log2(limit)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (w - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">qpow</span><span class="params">(LL x, LL y)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % mod; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % mod; &#125; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> type)</span> </span>&#123; <span class="comment">// type = 1 / -1</span></span><br><span class="line">		LL invg = <span class="built_in">inv</span>(g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) <span class="keyword">if</span>(i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			LL wn = <span class="built_in">qpow</span>(type == <span class="number">-1</span> ? invg : g, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">				LL w = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++, w = w * wn % mod) &#123;</span><br><span class="line">					LL x = a[j + k], y = w * a[j + i + k] % mod;</span><br><span class="line">					a[j + k] = (x + y) % mod;</span><br><span class="line">					a[j + i + k] = (x - y + mod) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">-1</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) (a[i] *= <span class="built_in">inv</span>(limit)) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123; <span class="type">int</span> ret = <span class="built_in">init</span>(n); <span class="built_in">trans</span>(a, type); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 需要先 init 再调用第一个 trans，或者直接调用第二个 trans</span></span><br></pre></td></tr></table></figure>

</details>
<details class="note no-icon info"><summary><p>任意模数 NTT（MTT）例题代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL P1 = <span class="number">469762049</span>;</span><br><span class="line"><span class="type">const</span> LL P2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> LL P3 = <span class="number">1004535809</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;LL mod, LL g&gt; <span class="keyword">struct</span> <span class="title class_">NTT</span> &#123;</span><br><span class="line">	<span class="type">int</span> rev[N];</span><br><span class="line">	<span class="type">int</span> limit;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">		limit = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(limit &lt;= mx) limit &lt;&lt;= <span class="number">1</span>, w++; <span class="comment">// w = log2(limit)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (w - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> limit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">qpow</span><span class="params">(LL x, LL y)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % mod; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % mod; &#125; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> type)</span> </span>&#123; <span class="comment">// type = 1 / -1</span></span><br><span class="line">		LL invg = <span class="built_in">inv</span>(g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) <span class="keyword">if</span>(i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			LL wn = <span class="built_in">qpow</span>(type == <span class="number">-1</span> ? invg : g, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">				LL w = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++, w = w * wn % mod) &#123;</span><br><span class="line">					LL x = a[j + k], y = w * a[j + i + k] % mod;</span><br><span class="line">					a[j + k] = (x + y) % mod;</span><br><span class="line">					a[j + i + k] = (x - y + mod) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">-1</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) (a[i] *= <span class="built_in">inv</span>(limit)) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">trans</span><span class="params">(LL *a, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123; <span class="type">int</span> ret = <span class="built_in">init</span>(n); <span class="built_in">trans</span>(a, type); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LL a[N], b[N], ca[N], cb[N], ans1[N], ans2[N], ans3[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL P;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL x, LL y, LL mod)</span> </span>&#123; LL ret = <span class="number">1</span>; <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x % mod; <span class="keyword">if</span>(!(y &gt;&gt;= <span class="number">1</span>)) <span class="keyword">return</span> ret; x = x * x % mod; &#125; &#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x, LL mod)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>, mod); &#125;</span><br><span class="line"></span><br><span class="line">NTT&lt;P1, <span class="number">3</span>&gt; ntt1;</span><br><span class="line">NTT&lt;P2, <span class="number">3</span>&gt; ntt2;</span><br><span class="line">NTT&lt;P3, <span class="number">3</span>&gt; ntt3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;P);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line">	<span class="type">int</span> limit = ntt1.<span class="built_in">init</span>(n + m);</span><br><span class="line">	ntt2.<span class="built_in">init</span>(n + m), ntt3.<span class="built_in">init</span>(n + m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ca[i] = a[i], cb[i] = b[i];</span><br><span class="line">	ntt1.<span class="built_in">trans</span>(ca, <span class="number">1</span>), ntt1.<span class="built_in">trans</span>(cb, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ans1[i] = ca[i] * cb[i] % P1;</span><br><span class="line">	ntt1.<span class="built_in">trans</span>(ans1, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ca[i] = a[i], cb[i] = b[i];</span><br><span class="line">	ntt2.<span class="built_in">trans</span>(ca, <span class="number">1</span>), ntt2.<span class="built_in">trans</span>(cb, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ans2[i] = ca[i] * cb[i] % P2;</span><br><span class="line">	ntt2.<span class="built_in">trans</span>(ans2, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ca[i] = a[i], cb[i] = b[i];</span><br><span class="line">	ntt3.<span class="built_in">trans</span>(ca, <span class="number">1</span>), ntt3.<span class="built_in">trans</span>(cb, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= limit; i++) ans3[i] = ca[i] * cb[i] % P3;</span><br><span class="line">	ntt3.<span class="built_in">trans</span>(ans3, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">		<span class="comment">// 三个质数可以手推 CRT</span></span><br><span class="line">		<span class="comment">// 看着这个推也可以 https://www.cnblogs.com/Memory-of-winter/p/10223844.html</span></span><br><span class="line">		LL out = <span class="number">0</span>;</span><br><span class="line">		LL tmp = ans1[i] + (ans2[i] - ans1[i] + P2) % P2 * <span class="built_in">inv</span>(P1, P2) % P2 * P1;</span><br><span class="line">		out = (tmp + (ans3[i] - tmp % P3 + P3) % P3 * <span class="built_in">inv</span>(P1 * P2 % P3, P3) % P3 * P1 % P * P2 % P) % P;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, out);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>完结撒花~</p>
<details class="note no-icon info"><summary><p>参考资料</p>
</summary>
<p><a href="https://www.cnblogs.com/zwfymqz/p/8244902.html"
class="uri">https://www.cnblogs.com/zwfymqz/p/8244902.html</a><br />
<a href="https://www.bilibili.com/video/BV1Y7411W73U"
class="uri">https://www.bilibili.com/video/BV1Y7411W73U</a><br />
<a href="https://www.luogu.com.cn/problem/solution/P4245"
class="uri">https://www.luogu.com.cn/problem/solution/P4245</a><br />
<a href="https://www.cnblogs.com/Memory-of-winter/p/10223844.html"
class="uri">https://www.cnblogs.com/Memory-of-winter/p/10223844.html</a><br />
<a href="https://blog.csdn.net/zhouyuheng2003/article/details/85561887"
class="uri">https://blog.csdn.net/zhouyuheng2003/article/details/85561887</a><br />
<a href="https://www.cnblogs.com/Sakits/p/8416918.html"
class="uri">https://www.cnblogs.com/Sakits/p/8416918.html</a><br />
<a href="https://oi-wiki.org/math/poly/ntt/"
class="uri">https://oi-wiki.org/math/poly/ntt/</a><br />
<a href="https://www.cnblogs.com/zarth/p/7288456.html"
class="uri">https://www.cnblogs.com/zarth/p/7288456.html</a><br />
<a
href="http://www.longluo.me/blog/2022/05/01/Number-Theoretic-Transform/"
class="uri">http://www.longluo.me/blog/2022/05/01/Number-Theoretic-Transform/</a></p>

</details>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>数论初识</title>
    <url>/post/number-theory-initial/</url>
    <content><![CDATA[<p>本篇的用意在 <del>恶补</del> 认识 OI 中数论的基础部分。</p>
<p>进阶篇见 <a href="/post/number-theory-advanced">这里</a></p>
<p>一些记号：</p>
<ul>
<li><span class="math inline">\(\land\)</span> 即
<strong>且</strong>（和交集 <span class="math inline">\(\cap\)</span>
是不是很像）</li>
<li><span class="math inline">\(\lor\)</span> 即
<strong>或</strong>（和并集 <span class="math inline">\(\cup\)</span>
是不是很像）</li>
<li><span class="math inline">\(\Rightarrow\)</span> 即
<strong>能够推出</strong></li>
<li><span class="math inline">\(\Leftrightarrow\)</span> 即
<strong>等价</strong>（或者说可以正着推出也可以反着推出，这两个说法是等价的）</li>
</ul>
<h2 id="一约数倍数与质合数">一、约数、倍数与质合数</h2>
<h3 id="前置芝士">前置芝士</h3>
<ul>
<li>带余除法：<span class="math inline">\(a \div b = c \cdots\cdots
r\)</span> <span class="math inline">\(\Rightarrow\)</span> <span
class="math inline">\(a \bmod b = r\)</span></li>
<li>约数与倍数：<span class="math inline">\(a \bmod b = 0\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(b\)</span> 是 <span
class="math inline">\(a\)</span> 的约数（或者说因数） <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(a\)</span> 是 <span
class="math inline">\(b\)</span> 的倍数</li>
<li>最大公因数：最大的数使得 <span class="math inline">\(c\)</span>
同时为 <span class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span> 的约数，记为 <span
class="math inline">\(\gcd(a, b)\)</span> 或 <span
class="math inline">\((a, b)\)</span></li>
<li>最小公倍数：最小的数使得 <span class="math inline">\(c\)</span>
同时为 <span class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span> 的倍数，记为 <span
class="math inline">\(\operatorname{lcm}(a, b)\)</span> 或 <span
class="math inline">\([a, b]\)</span></li>
<li>质数：<span class="math inline">\(p\)</span> 是质数当且仅当 <span
class="math inline">\(p\)</span> 只有 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(p\)</span> 两个约数。特别地，<span
class="math inline">\(1\)</span> 不是质数。（在某些地方，<span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 互质会记为 <span
class="math inline">\(a \perp b\)</span>，本文也会用到这种记法）</li>
<li>质因数：一个数的是质数的因数叫做它的质因数。</li>
<li>整除：a 是 <span class="math inline">\(b\)</span> 的约数 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(a\)</span> 整除 <span
class="math inline">\(b\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(a\mid b\)</span></li>
<li>唯一分解定理：质因数分解方案唯一（这个不用证了吧）</li>
<li>质数无限
<ul>
<li>证明：如果只有 <span class="math inline">\(k\)</span> 个质数，记为
<span class="math inline">\(\{p_i\}\)</span>，那么考虑 <span
class="math inline">\(\left(\prod p_i\right) + 1\)</span>
这个数，显然它不是任何 <span class="math inline">\(p_i\)</span>
的约数，所以要么它是个质数，要么它有一个不等于任何 <span
class="math inline">\(p_i\)</span>
的质因数，两种情况都与假设矛盾。所以质数有无数个。</li>
</ul></li>
<li><span class="math inline">\(\pi(n)\)</span>：<span
class="math inline">\(n\)</span> 以内质数个数（希腊字母 <span
class="math inline">\(\text{Pi}\)</span>，大写 <span
class="math inline">\(\Pi\)</span>，小写 <span
class="math inline">\(\pi\)</span>）</li>
<li><span class="math inline">\(\pi(n)\)</span> 是 <span
class="math inline">\(O(\frac{n}{\log n})\)</span> 级别的</li>
<li>第 <span class="math inline">\(n\)</span> 个质数是 <span
class="math inline">\(O(n \log n)\)</span> 级别的</li>
<li><span class="math inline">\(\sum_{i=1}^n \frac{1}{i} = O(\log
n)\)</span></li>
<li><span class="math inline">\(\sum_{1 \le p \le n} \frac{1}{p} =
O(\log \log n)\)</span>（p 为质数）</li>
<li><span class="math inline">\(a\mid c \land b\mid c \land (a, b) =
1\Rightarrow ab\mid c\)</span></li>
<li><span class="math inline">\(a\mid bc \land (a, b) = 1 \Rightarrow
a\mid c\)</span></li>
<li><span class="math inline">\(p\mid ab \Rightarrow p\mid a \lor p\mid
b\)</span>（p 为质数）</li>
<li><span class="math inline">\(ab = (a, b) \cdot [a, b]\)</span></li>
</ul>
<p>附上一个黑科技：</p>
<p>这份代码可以计算 <span class="math inline">\(a \times b \bmod
mod\)</span>，但是 <span class="math inline">\(a \times b\)</span>
可以爆 <code>long long</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a, LL b, LL mod)</span> </span>&#123; <span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)a * b - (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)a / mod * b + <span class="number">0.5</span>) * mod + mod) % mod; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算-gcd">计算 gcd</h3>
<h4 id="欧几里得算法辗转相除法">欧几里得算法（辗转相除法）</h4>
<p><span class="math inline">\(\gcd(a, b) = \gcd(a - b, b) = gcd(a - 2b,
b) = \cdots = \gcd(a \bmod b, b)\)</span></p>
<p>另外，对于 <span class="math inline">\(\gcd_{i=1}^n
a_i\)</span> （<span class="math inline">\(a_i \le
w\)</span>）用欧几里得算法，复杂度 <span class="math inline">\(O(n +
\log w)\)</span>（不是 <span class="math inline">\(O(n \cdot \log
w)\)</span>）</p>
<h4 id="其他算法">其他算法</h4>
<p><span class="math display">\[
\gcd(a, b) = \begin{cases}
    \gcd(\frac a2, \frac b2)&amp;(2\mid a \land 2\mid b)\\
    \gcd(\frac a2, b)&amp;((2\mid a \land 2 \not\mid \ b) \lor (2
\not\mid \ a \land 2\mid b))\\
    \gcd(a - b, b)&amp;(2 \not\mid \ a \land 2 \not\mid \ b)
\end{cases}
\]</span></p>
<p>复杂度 <span class="math inline">\(O(\log a + \log b)\)</span>。</p>
<h3 id="裴蜀定理">裴蜀定理</h3>
<p>关于 <span class="math inline">\(x\)</span>, <span
class="math inline">\(y\)</span> 的方程 <span class="math inline">\(ax +
by = d (a, b, x, y \in \mathbb Z)\)</span> 有解 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\((a, b)\mid d\)</span></p>
<h4 id="证明">证明</h4>
<p><del>我不会证</del> 看 <a
href="https://oi-wiki.org/math/number-theory/bezouts/#_1">OI Wiki</a>
的证明吧。</p>
<h3 id="拓展欧几里得exgcd">拓展欧几里得（exgcd）</h3>
<h4 id="思路">思路</h4>
<p>解 <span class="math inline">\(ax + by = 1\)</span>，其中 <span
class="math inline">\((a, b) = 1 \land a, b, x, y \in \mathbb
Z\)</span><br />
（可以将 <span class="math inline">\(ax + by = c\)</span> 转换成 <span
class="math inline">\(ax&#39; + by&#39; = 1\)</span> 的形式）<br />
原式可化为<span class="math inline">\(ax + by = (a, b) =
1\)</span><br />
上式有解则表明 <span class="math inline">\(bx&#39; + (a \bmod b)y&#39; =
(b, a \bmod b) = 1\)</span>有解（裴蜀定理）<br />
即 <span class="math inline">\(bx&#39; + (a - b \lfloor \frac{a}{b}
\rfloor)y&#39; = (b, a \bmod b) = 1\)</span> 有解<br />
也即 <span class="math inline">\(b(x&#39; - \lfloor \frac{b}{a} \rfloor
y&#39;) + by&#39; = (a, b \bmod a) = 1\)</span>有解<br />
那么 <span class="math inline">\(x = y&#39;\)</span>，<span
class="math inline">\(y = x&#39; - \lfloor \frac{a}{b}\rfloor
y&#39;\)</span> 我们只需要递归下去就行了！<br />
递归时求得 <span class="math inline">\(bx&#39; + (a \bmod b)y&#39; =
1\)</span> 的解，然后用上述方法推 <span
class="math inline">\(x\)</span>, <span
class="math inline">\(y\)</span><br />
边界条件？<br />
当 <span class="math inline">\(b = 0\)</span> 时就得到 <span
class="math inline">\(ax&#39;&#39; + 0y&#39;&#39; = 1 \Rightarrow
ax&#39;&#39; = 1\)</span>， 可以证明此时 <span class="math inline">\(a =
1\)</span>（因为 <span class="math inline">\((a, b) = 1\)</span>），即
<span class="math inline">\(x&#39;&#39; = 1, y&#39;&#39; =
0\)</span></p>
<h4 id="代码">代码</h4>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 ax + by = 1 的解，并返回 gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="例题">例题</h4>
<details class="note no-icon info"><summary><p><a href="https://www.luogu.com.cn/problem/P1082">洛谷 P1082</a></p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P1082</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ax + by = 1</span></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	LL g = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">	LL tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp - a / b * y;</span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL a, b;</span><br><span class="line">	std::<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	LL x, y;</span><br><span class="line">	<span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">	<span class="keyword">while</span>(x &lt; <span class="number">0</span>) x += b;</span><br><span class="line">	x %= b;</span><br><span class="line">	std::<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="应用">应用</h4>
<p>求逆元。（逆元见<a href="#逆元">下方↓</a>）<br />
<span class="math inline">\(x \equiv a^{-1} \pmod b \Rightarrow ax
\equiv 1 \pmod b \Rightarrow ax + by = 1 (y \in \mathbb
Z)\)</span><br />
可以用拓展欧几里得来推，解出的 <span class="math inline">\(x\)</span>
即为 <span class="math inline">\(a\)</span> 的逆元。</p>
<h2 id="二同余问题">二、同余问题</h2>
<h3 id="前置芝士-1">前置芝士</h3>
<ul>
<li><span class="math inline">\(a \equiv b \pmod m \Leftrightarrow m\mid
(b - a) \Leftrightarrow a \bmod m = b \bmod m\)</span></li>
<li><span class="math inline">\(a \equiv b \pmod m \land a \equiv b
\pmod n \Rightarrow a \equiv b \pmod{[m, n]}\)</span></li>
<li><span class="math inline">\((k, m) = d \land ka \equiv kb \pmod m
\Rightarrow a \equiv b \pmod{\frac md}\)</span></li>
</ul>
<h3 id="逆元">逆元</h3>
<p>如果有一个 <span class="math inline">\(b\)</span> 满足 <span
class="math inline">\(ab \equiv 1 \pmod m\)</span>，那么我们把 <span
class="math inline">\(b\)</span> 叫做 <span
class="math inline">\(a\)</span> 的逆元。</p>
<p>容易发现逆元跟除法长得很像，所以我们一般把 <span
class="math inline">\(a\)</span> 的逆元记作 <span
class="math inline">\(a^{-1}\)</span>，有时也用分数线来表示：<span
class="math inline">\(\frac ab \bmod m = ab^{-1} \bmod m\)</span>。</p>
<p>如果有 <span class="math inline">\((b, m) = 1\)</span>，那么 <span
class="math inline">\(b\)</span> 存在 <span class="math inline">\(\bmod
m\)</span> 意义下的逆元（这个可以用上面的拓展欧几里得来构造证明）</p>
<h3 id="欧拉定理">欧拉定理</h3>
<h4 id="欧拉函数">欧拉函数</h4>
<p>所有的 <span class="math inline">\(i\)</span> 满足 <span
class="math inline">\(0 &lt; i \le n\)</span>，<span
class="math inline">\((i, n) = 1\)</span> 构成了一个 <span
class="math inline">\(\bmod n\)</span> 的简化剩余系。</p>
<p><span class="math inline">\(n\)</span> 的简化剩余系的个数记为 <span
class="math inline">\(\varphi(n)\)</span> （希腊字母 <span
class="math inline">\(\text{Phi}\)</span>，大写 <span
class="math inline">\(\Phi\)</span>，小写 <span
class="math inline">\(\phi\)</span>，也写作 <span
class="math inline">\(\varphi\)</span>）</p>
<p>也即，<span class="math inline">\(n\)</span> 以内与 <span
class="math inline">\(n\)</span> 互质的数的个数记为 <span
class="math inline">\(\varphi(n)\)</span>。</p>
<p><span
class="math inline">\(\varphi\)</span> 是积性函数，即对于互质的两个数
<span class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>，满足 <span
class="math inline">\(\varphi(a) \varphi(b) = \varphi(ab)\)</span></p>
<p><span class="math inline">\(\varphi(n)\)</span>
还有一个求解公式：如果 <span class="math inline">\(n\)</span>
分解质因数后为 <span class="math inline">\(\prod_{i=1}^k
p_i^{a_i}\)</span>，那么 <span class="math inline">\(\varphi(n) = n
\times \prod_{i=1}^k \frac{p_i -
1}{p_i}\)</span>。应用这个公式我们还可以得到，对于质数 <span
class="math inline">\(p\)</span>，<span class="math inline">\(\varphi(p)
= p - 1\)</span>。</p>
<h3 id="欧拉定理-1">欧拉定理</h3>
<h4 id="结论">结论</h4>
<p><span class="math inline">\((a, m) = 1 \Rightarrow a^{\varphi(m)}
\equiv 1 \pmod m\)</span></p>
<h4 id="证明-1">证明</h4>
<p>令 <span class="math inline">\(S = \{x_1, x_2, \cdots,
x_{\varphi(m)}\}\)</span> 为 <span class="math inline">\(m\)</span>
的简化剩余系，<br />
则 <span class="math inline">\(S&#39; = \{ax_1, ax_2, \cdots,
ax_{\varphi(m)}\}\)</span>也是 <span class="math inline">\(m\)</span>
的简化剩余系<br />
（这个是简化剩余系的性质）<br />
所以 <span class="math inline">\(\prod_{x \in S&#39;} x \equiv \prod_{x
\in S} x \pmod m\)</span> 即 <span class="math inline">\(a^{\varphi(m)}
\equiv 1 \pmod m\)</span></p>
<h4 id="应用-1">应用</h4>
<p><span class="math inline">\(a^{\varphi(m)} \equiv 1 \pmod m
\Rightarrow a^{-1} \equiv a^{\varphi(m) - 1} \pmod m\)</span><br />
如果 <span class="math inline">\(m\)</span> 为质数，那么 <span
class="math inline">\(a^{-1} \equiv a^{m - 2} \pmod m\)</span></p>
<h3 id="线性求逆元">线性求逆元</h3>
<h4 id="思路-1">思路</h4>
<p>令 <span class="math inline">\(\lfloor \frac{p}{i}\rfloor =
k\)</span>，<span class="math inline">\(p \bmod i = r\)</span>（即 <span
class="math inline">\(ki + r = p (r &lt; i)\)</span>），<br />
则<br />
<span class="math display">\[
\begin{aligned}
    p &amp;\equiv 0 &amp;\pmod p\\
    ki + r &amp;\equiv 0 &amp;\pmod p\\
    k\cdot i\cdot (i^{-1}\cdot r^{-1}) + r \cdot (i^{-1} \cdot r^{-1})
&amp;\equiv 0 &amp;\pmod p\\
    kr^{-1} + i^{-1} &amp;\equiv 0 &amp;\pmod p\\
    i^{-1} &amp;\equiv -kr^{-1} &amp;\pmod p\\
    i^{-1} &amp;\equiv -\lfloor \frac pi \rfloor \cdot (p \bmod i)^{-1}
&amp;\pmod p
\end{aligned}
\]</span></p>
<p>即 <code>inv[i] = (-(p / i) * inv[p % i] % p + p) % p</code>，<br />
也即 <code>inv[i] = (p - p / i) * inv[p % i] % p</code> 。</p>
<h4 id="代码-1">代码</h4>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛出 n 以内的逆元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_inv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) inv[i] = (<span class="type">long</span> <span class="type">long</span>)(p - p / i) * inv[p % i] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="例题-1">例题</h4>
<details class="note no-icon info"><summary><p><a href="https://www.luogu.com.cn/problem/P3811">洛谷 P3811</a></p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3811</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20000528</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) inv[i] = (<span class="type">long</span> <span class="type">long</span>)(p - p / i) * inv[p % i] % p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, inv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="中国剩余定理crt">中国剩余定理（CRT）</h3>
<h4 id="引入">引入</h4>
<p>中国剩余定理解决的问题是，对于若干形如 <span class="math inline">\(x
\equiv r_i \pmod p_i\)</span> 的同余方程，求 <span
class="math inline">\(x\)</span> 的最小正整数解。其中 <span
class="math inline">\(p_i\)</span> 两两互质（如果不满足要用下面的<a
href="#拓展中国剩余定理excrt">拓展中国剩余定理</a>）</p>
<p>先来看一个例子：</p>
<blockquote>
<p>求最小的正整数 <span class="math inline">\(x\)</span>，满足 <span
class="math inline">\(x \equiv 2 \pmod 3\)</span>，<span
class="math inline">\(x \equiv 3 \pmod 5\)</span>，<span
class="math inline">\(x \equiv 2 \pmod 7\)</span>。</p>
</blockquote>
<p>解法：令<br />
<span class="math inline">\(a\)</span> 为除以 <span
class="math inline">\(3\)</span> 余 <span
class="math inline">\(1\)</span> 的最小的 <span
class="math inline">\(5\)</span> 和 <span
class="math inline">\(7\)</span> 的公倍数，（<span
class="math inline">\(a = 70\)</span>）<br />
<span class="math inline">\(b\)</span> 为除以 <span
class="math inline">\(5\)</span> 余 <span
class="math inline">\(1\)</span> 的最小的 <span
class="math inline">\(3\)</span> 和 <span
class="math inline">\(7\)</span> 的公倍数，（<span
class="math inline">\(b = 21\)</span>）<br />
<span class="math inline">\(c\)</span> 为除以 <span
class="math inline">\(7\)</span> 余 <span
class="math inline">\(1\)</span> 的最小的 <span
class="math inline">\(3\)</span> 和 <span
class="math inline">\(5\)</span> 的公倍数。（<span
class="math inline">\(c = 15\)</span>）<br />
然后将 <span class="math inline">\(a\)</span> 乘上 <span
class="math inline">\(2\)</span>（即 <span class="math inline">\(x \bmod
3\)</span>），<span class="math inline">\(b\)</span> 乘上 <span
class="math inline">\(3\)</span>，<span class="math inline">\(c\)</span>
乘上 <span class="math inline">\(2\)</span>。（<span
class="math inline">\(a = 140\)</span>，<span class="math inline">\(b =
63\)</span>，<span class="math inline">\(c = 30\)</span>）<br />
则 <span class="math inline">\(x = (a + b + c) \bmod 3 \times 5 \times 7
= 23\)</span></p>
<h4 id="原理">原理</h4>
<p>要想让 <span class="math inline">\([3, 5, 7]\mid a + b +
c\)</span>，最简单的方法是：</p>
<ul>
<li><span class="math inline">\(a\)</span> 除以 <span
class="math inline">\(3\)</span> 余 <span
class="math inline">\(2\)</span>，并且是 <span
class="math inline">\(5\)</span> 和 <span
class="math inline">\(7\)</span> 的公倍数</li>
<li><span class="math inline">\(b\)</span> 除以 <span
class="math inline">\(5\)</span> 余 <span
class="math inline">\(3\)</span>，并且是 <span
class="math inline">\(3\)</span> 和 <span
class="math inline">\(7\)</span> 的公倍数</li>
<li><span class="math inline">\(c\)</span> 除以 <span
class="math inline">\(7\)</span> 余 <span
class="math inline">\(2\)</span>，并且是 <span
class="math inline">\(3\)</span> 和 <span
class="math inline">\(5\)</span> 的公倍数</li>
</ul>
<p>那么如何求这样的 <span class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>
呢？<br />
以 <span class="math inline">\(a\)</span> 为例，我们先求出除以 <span
class="math inline">\(3\)</span> 余 <span
class="math inline">\(1\)</span> 而且是 <span
class="math inline">\(5\)</span> 和 <span
class="math inline">\(7\)</span> 的公倍数的数，然后再乘 <span
class="math inline">\(2\)</span>。<br />
即把 <span class="math inline">\([5, 7]\)</span> 乘上 <span
class="math inline">\([5, 7]^{-1} \pmod 3\)</span>（此时除以 <span
class="math inline">\(3\)</span> 余数必为 <span
class="math inline">\(1\)</span>，而且是 <span
class="math inline">\(5\)</span>, <span class="math inline">\(7\)</span>
的倍数），再乘余数 <span class="math inline">\(2\)</span>。<br />
最后算出 <span class="math inline">\(a + b + c\)</span>，然后模上 <span
class="math inline">\([3, 5, 7]\)</span> 就是答案。</p>
<h4 id="结论-1">结论</h4>
<p>若有方程： <span class="math display">\[
\begin{aligned}
    x \equiv&amp; r_1 \pmod {p_1}\\
    x \equiv&amp; r_2 \pmod {p_2}\\
    &amp;\vdots\\
    x \equiv&amp; r_n \pmod {p_n}
\end{aligned}
\]</span><br />
其中 <span class="math inline">\(p_1, p_2, \cdots
p_n\)</span> 两两互质。<br />
令 <span class="math inline">\(P = \prod_{i=1}^n p_i\)</span>，<span
class="math inline">\(P_i = \frac{P}{p_i}\)</span>，<span
class="math inline">\(v_i = (P_i)^{-1} \pmod {p_1}\)</span>，<br />
则方程的解为 <span class="math inline">\(x = \sum_{i=1}^n P_iv_ir_i
\bmod P\)</span></p>
<h4 id="代码-2">代码</h4>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有两个数组：r[] 和 p[]，分别表示余数和模数</span></span><br><span class="line"><span class="comment">// 一共有 n 组方程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">crt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> P = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) P *= p[i];</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        ret = ret * (P / p[i]) % P;</span><br><span class="line">        <span class="type">int</span> inv, tmp;</span><br><span class="line">        <span class="built_in">exgcd</span>(P / p[i], p[i], inv, tmp);</span><br><span class="line">        <span class="keyword">while</span>(inv &lt;= <span class="number">0</span>) inv += p[i];</span><br><span class="line">        inv %= p[i];</span><br><span class="line">        ret = ret * inv % P;</span><br><span class="line">        ret = ret * r[i] % P;</span><br><span class="line">        x = (x + ret) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="例题-2">例题</h4>
<details class="note no-icon info"><summary><p><a href="https://www.luogu.com.cn/problem/P1495">洛谷 P1495</a></p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P1495</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL r[N], p[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    LL g = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">crt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL P = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) P *= p[i];</span><br><span class="line">    LL x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LL ret = <span class="number">1</span>;</span><br><span class="line">        ret = ret * (P / p[i]) % P;</span><br><span class="line">        LL inv, tmp;</span><br><span class="line">        <span class="built_in">exgcd</span>(P / p[i], p[i], inv, tmp);</span><br><span class="line">        <span class="keyword">while</span>(inv &lt;= <span class="number">0</span>) inv += p[i];</span><br><span class="line">        inv %= p[i];</span><br><span class="line">        ret = ret * inv % P;</span><br><span class="line">        ret = ret * r[i] % P;</span><br><span class="line">        x = (x + ret) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;p[i], &amp;r[i]);</span><br><span class="line">	std::<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">crt</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="拓展中国剩余定理excrt">拓展中国剩余定理（exCRT）</h3>
<p>拓展中国剩余定理解决的问题和 CRT 差不多，但是不要求 <span
class="math inline">\(p_i\)</span> 两两互质。</p>
<p>与 CRT 不同，这次我们尝试两两合并方程。</p>
<p>考虑两个方程 <span class="math inline">\(x \equiv a_1 \pmod
{b_1}\)</span>，<span class="math inline">\(x \equiv a_2 \pmod
{b_2}\)</span>。</p>
<p>我们将它们转成不定方程：<span class="math inline">\(x = a_1 + b_1p =
a_2 + b_2q\)</span>，即 <span class="math inline">\(b_1p - b_2q = a_2 -
a_1\)</span>。</p>
<p>对于这个方程，我们用拓展欧几里得算出 <span
class="math inline">\(p\)</span> 和 <span
class="math inline">\(q\)</span> 的一组解。（如果 <span
class="math inline">\(a_2 - a_1\)</span> 不能被 <span
class="math inline">\(\gcd(b_1, b_2)\)</span> 整除则无解）</p>
<p>那么这两组方程的解为 <span class="math inline">\(x \equiv a_1 + b_1p
= a_2 + b_2q \pmod {\operatorname{lcm}(b_1, b_2)}\)</span>。</p>
<h4 id="代码-3">代码</h4>
<details class="note no-icon info"><summary><p>代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有两个数组：r[] 和 p[]，分别表示余数和模数</span></span><br><span class="line"><span class="comment">// 一共有 n 组方程</span></span><br><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL a1, b1, a2, b2, x, y;</span><br><span class="line">	a1 = r[<span class="number">1</span>], b1 = p[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		a2 = r[i], b2 = p[i];</span><br><span class="line">		<span class="keyword">if</span>(a2 &lt; a1) std::<span class="built_in">swap</span>(a1, a2), std::<span class="built_in">swap</span>(b1, b2);</span><br><span class="line">		LL a = b1, b = b2, c = a2 - a1;</span><br><span class="line">		LL g = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">		<span class="keyword">if</span>(c % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		a /= g, b /= g, c /= g;</span><br><span class="line">		b1 = <span class="built_in">lcm</span>(b1, b2);</span><br><span class="line">		y = y * (b1 - c) % b1;</span><br><span class="line">		a1 = (a2 + b2 * y % b1) % b1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="例题-3">例题</h4>
<details class="note no-icon info"><summary><p><a href="https://www.luogu.com.cn/problem/P4777">洛谷 P4777</a></p>
</summary>
<p>注意此题需要用前面的乘法技巧，因为可能会爆
<code>long long</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">LL r[N], p[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL x, LL y)</span> </span>&#123; <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y); &#125;</span><br><span class="line"><span class="function">LL <span class="title">lcm</span><span class="params">(LL x, LL y)</span> </span>&#123; <span class="keyword">return</span> x / <span class="built_in">gcd</span>(x, y) * y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">	LL x_, y_;</span><br><span class="line">    LL g = <span class="built_in">exgcd</span>(b, a % b, x_, y_);</span><br><span class="line">    x = y_;</span><br><span class="line">    y = x_ - a / b * y_;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a, LL b, LL mod)</span> </span>&#123; <span class="keyword">return</span> (a * b - (LL)((<span class="type">long</span> <span class="type">double</span>)a / mod * b + <span class="number">0.5</span>) * mod + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有两个数组：r[] 和 p[]，分别表示余数和模数</span></span><br><span class="line"><span class="comment">// 一共有 n 组方程</span></span><br><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL a1, b1, a2, b2, x, y;</span><br><span class="line">	a1 = r[<span class="number">1</span>], b1 = p[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		a2 = r[i], b2 = p[i];</span><br><span class="line">		<span class="keyword">if</span>(a2 &lt; a1) std::<span class="built_in">swap</span>(a1, a2), std::<span class="built_in">swap</span>(b1, b2);</span><br><span class="line">		LL a = b1, b = b2, c = a2 - a1;</span><br><span class="line">		LL g = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">		<span class="keyword">if</span>(c % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		a /= g, b /= g, c /= g;</span><br><span class="line">		b1 = <span class="built_in">lcm</span>(b1, b2);</span><br><span class="line">		y = <span class="built_in">mul</span>(y, b1 - c, b1);</span><br><span class="line">		a1 = (a2 + <span class="built_in">mul</span>(b2, y, b1)) % b1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;p[i], &amp;r[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">excrt</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">11 6</span></span><br><span class="line"><span class="comment">25 9</span></span><br><span class="line"><span class="comment">33 17</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</details>
<h2 id="小结">小结</h2>
<p>数论初步到这里就差不多了，看到这里说明你已经入门了。</p>
<p>后面的就等到 <a href="/post/number-theory-advanced">数论进阶</a>
来讲吧。</p>
<p>完结撒花~</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组详解</title>
    <url>/post/binary-indexed-tree/</url>
    <content><![CDATA[<h2 id="引入">引入</h2>
<p>先问几个问题。</p>
<blockquote>
<p>什么是树状数组？</p>
</blockquote>
<p>树状数组是一种数据结构，支持 <span
class="math inline">\(\log\)</span> 级别的区间修改查询操作。</p>
<blockquote>
<p>为什么要有树状数组？</p>
</blockquote>
<p>用数组实现区间查询、区间修改是 <span
class="math inline">\(O(n)\)</span> 的，但用树状数组是 <span
class="math inline">\(O(\log n)\)</span>。</p>
<blockquote>
<p>线段树和树状数组的对比？</p>
</blockquote>
<ol type="1">
<li><del>名字不一样</del></li>
<li>两个都是 <span class="math inline">\(\log\)</span> 级数据结构</li>
<li>树状数组支持区间查询，区间修改，但线段树支持基本上所有区间操作（<span
class="math inline">\(\log n\)</span> 时间）</li>
<li>树状数组空间复杂度 <span
class="math inline">\(n\)</span>，常数小；线段树空间复杂度 <span
class="math inline">\(4n\)</span>，常数较大。</li>
</ol>
<h2 id="树状数组原理介绍">树状数组原理介绍</h2>
<h3 id="前置芝士">前置芝士</h3>
<p><a
href="https://www.cnblogs.com/zengzi233/p/12117098.html">位运算</a></p>
<blockquote>
<p>大意：
按位与：在二进制中对每一位进行对应操作：<code>1&amp;1=1</code>,
<code>1&amp;0=0</code>, <code>0&amp;1=0</code>,
<code>0&amp;0=0</code></p>
</blockquote>
<p><a href="http://data.biancheng.net/view/192.html">二叉树</a></p>
<blockquote>
<p>大意： 二叉树的定义：每个节点至多有 2 个儿子的树。</p>
</blockquote>
<h3 id="树状数组原理">树状数组原理</h3>
<p>首先上一张二叉树的图：（为了方便将节点右对齐）</p>
<blockquote>
<p>图片来源：<a
href="https://www.cnblogs.com/xenny/p/9739600.html">https://www.cnblogs.com/xenny/p/9739600.html</a>，已经过博主同意，下同。</p>
</blockquote>
<img data-src="/post/binary-indexed-tree/%E7%BA%BF%E6%AE%B5%E6%A0%91.png" class="" title="线段树">
<p>是不是看着有些熟悉呢？没错，这就是<a
href="https://oi-wiki.org/ds/seg/">线段树</a>。</p>
<p>但是树状数组可不长这样，前面说过它的空间复杂度是 <span
class="math inline">\(n\)</span>。<br />
那树状数组是什么样呢？我们将每一列都只留最上面的节点，就变成了这样：</p>
<img data-src="/post/binary-indexed-tree/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" class="" title="树状数组">
<p>我们发现：（设原数组是 <code>a[]</code>，树状数组是
<code>c[]</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c[1] = a[1]</span><br><span class="line">c[2] = a[1] + a[2]</span><br><span class="line">c[3] = a[3]</span><br><span class="line">c[4] = a[1] + a[2] + a[3] + a[4]</span><br><span class="line">c[5] = a[5]</span><br><span class="line">c[6] = a[5] + a[6]</span><br><span class="line">c[7] = a[7]</span><br><span class="line">c[8] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]</span><br></pre></td></tr></table></figure>
<p><del>找规律</del>发现：<span class="math inline">\(c[i] = \sum_{j = i
- lowbit(i) + 1}^i a_j\)</span></p>
<details class="note info"><summary><p>关于 <span class="math inline">\(lowbit\)</span></p>
</summary>
<p><span class="math inline">\(lowbit(i)\)</span> 表示 <span
class="math inline">\(i\)</span> 在二进制下最后一个 <span
class="math inline">\(1\)</span>。</p>
<p>例如：（下面的数都是二进制下的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lowbit(1111) = 1</span><br><span class="line">lowbit(1100) = 100</span><br><span class="line">lowbit(1010) = 10</span><br><span class="line">lowbit(1001) = 1</span><br><span class="line">lowbit(1000) = 1000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么这个 <span class="math inline">\(lowbit\)</span> 怎么求呢？<br />
不难发现有很多求法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     x = 1001010</span><br><span class="line">    ~x = 0110101</span><br><span class="line">~x + 1 = 0110110</span><br></pre></td></tr></table></figure>
<p>容易发现 <code>x</code> 与 <code>~x + 1</code> 除了 <span
class="math inline">\(lowbit\)</span>
位相同，其它的都不同（<del>显然</del>）。 所以我们得出
<code>lowbit(i) = x &amp; ((~x) + 1)</code>，然后因为
<code>(~x) + 1</code> 就是 <code>-x</code>（参见<a
href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码补码反码详解</a>或<a
href="https://oi-wiki.org/ds/fenwick/#_3">这个</a>），所以
<code>lowbit(x) = x &amp; -x</code>。</p>
<p>于是我们成功处理了 <span class="math inline">\(lowbit\)</span>！</p>

</details>
<h2 id="应用">应用</h2>
<p>说了这么多，树状数组到底是怎么维护区间的呢？</p>
<p>维护区间有四种，分别是：</p>
<ul>
<li>单点修改，单点查询</li>
<li>单点修改，区间查询</li>
<li>区间修改，单点查询</li>
<li>区间修改，区间查询</li>
</ul>
<p>下面来分别讲解。</p>
<h3 id="单点修改单点查询">单点修改，单点查询</h3>
<p>传统数组即可。</p>
<h3 id="单点修改区间查询">单点修改，区间查询</h3>
<img data-src="/post/binary-indexed-tree/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" class="" title="树状数组">
<h4 id="查询">查询</h4>
<p>从上图中我们发现 <span class="math display">\[
\sum_{i = 1}^k a_i = c(i) + c(i - lowbit(i)) + c(i - lowbit(i) -
lowbit\left(i - lowbit(i)\right) + \cdots + c(1)
\]</span></p>
<details class="note info"><summary><p>证明</p>
</summary>
<p><span class="math display">\[\begin{aligned}
    c(i) = &amp;\sum_{k = i - lowbit(i) + 1}^i a_k\\
    c(i - lowbit(i)) = &amp;\sum_{k = i - lowbit(i) - lowbit(i -
lowbit(i)) + 1}^{i - lowbit(i)} a_k\\
    &amp;\vdots\\
    a(1) = &amp;a_1
\end{aligned}\]</span></p>

</details>
<p>上<del>初步</del>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += c[r];</span><br><span class="line">        r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时 ret 值为 a[1] + a[2] + ... + a[r]</span></span><br></pre></td></tr></table></figure>
<p>还有一个问题，如果 <span class="math inline">\(r = 0\)</span>
呢？<br />
此时我们求的是 <span class="math inline">\(a[0 .. r]\)</span>
的和，但我们的条件是 <code>r &gt; 0</code> 啊！<br />
这时我们需要特殊处理 <span class="math inline">\(0\)</span>。<br />
为什么别的模板有些没有这么做呢？因为他们没有用到 <code>a[0]</code>。</p>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123; <span class="comment">// sum(a[1 .. r])</span></span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">0</span>) <span class="keyword">return</span> c[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r) ret += c[r], r -= (r &amp; -r);</span><br><span class="line">    <span class="keyword">return</span> ret + c[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// sum(a[l .. r])</span></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">query_sum</span>(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query_sum</span>(r) - <span class="built_in">query_sum</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改">修改</h4>
<p>修改时我们需要将包含 <span class="math inline">\(a_i\)</span> 的
<span class="math inline">\(c\)</span> 都修改，即：<br />
<span class="math inline">\(c(i)\)</span>, <span
class="math inline">\(c(i + lowbit(i))\)</span>, <span
class="math inline">\(c(i + lowbit(i) + lowbit(i + lowbit(i)))\)</span>,
<span class="math inline">\(\cdots\)</span></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// a[x] += y</span></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) &#123; t[x] += y; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= tot) c[x] += y, x += (x &amp; -x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>tot</code> 为树状数组下标的最大值。</p>
<h3 id="区间修改单点查询">区间修改，单点查询</h3>
<h4 id="前置芝士-1">前置芝士</h4>
<p><a href="https://oi-wiki.org/basic/prefix-sum/#_6">差分数组</a></p>
<blockquote>
<p>大意：<br />
设 <span class="math inline">\(t(i) = a_i - a_{i - 1}\)</span><br />
那么 <span class="math inline">\(a_i = \sum_{j = 1}^i t(j)\)</span></p>
</blockquote>
<h4 id="原理">原理</h4>
<p>树状数组可以维护单点修改，区间查询，但如何实现区间修改，单点查询呢？</p>
<p>我们可以用维护 <span class="math inline">\(a\)</span>
的差分数组，而不是 <span class="math inline">\(a\)</span> 数组。<br />
此时区间修改 <span class="math inline">\([l, r]\)</span> 可以转化成
<code>a[l] += add, a[r + 1] -= add</code>，即单点修改；<br />
单点查询 <span class="math inline">\(a_x\)</span> 可以转化成询问 <span
class="math inline">\([1, x]\)</span> 的和，即区间查询。</p>
<h3 id="区间修改区间查询">区间修改，区间查询</h3>
<p>仍然利用差分：<span class="math inline">\(t(i) = a_i - a_{i -
1}\)</span></p>
<h4 id="查询-1">查询</h4>
<p><span class="math display">\[\begin{aligned}
\sum_{i = 1}^k a_i &amp;= (t(1)) + (t(1) + t(2)) + (t(1) + t(2) + t(3))
+ \cdots + \sum_{i = 1}^k t(i)\\
&amp;= \sum_{i = 1}^k \sum_{j = 1}^i t(j)\\
&amp;= \sum_{j = 1}^k \sum_{i = j}^k t(j)\\
&amp;= \sum_{j = 1}^k t(j) \times (k - j + 1)\\
&amp;= (k + 1) \sum_{j = 1}^k t(j) - \sum_{j = 1}^k t(j) \times j
\end{aligned}\]</span></p>
<p>维护两个树状数组，一个 <span
class="math inline">\(t(i)\)</span>，一个 <span
class="math inline">\(t(i) \times i\)</span>。</p>
<h4 id="修改-1">修改</h4>
<p>第一个 <span class="math inline">\(t(i)\)</span>
的树状数组可以像最开始一样维护，下面考虑如何维护第二个 <span
class="math inline">\(t(i) \times i\)</span> 的树状数组。</p>
<p>在 <code>a[l .. r] += k</code> 时，<span class="math inline">\(t(l +
1 .. r)\)</span> 是不会变的，所以 <span class="math inline">\(t(j)
\times j (l &lt; j \le r)\)</span> 也都不会变。<br />
那么对于 <span class="math inline">\(l\)</span>，<span
class="math inline">\(t(l)\)</span> 增加了 <span
class="math inline">\(k\)</span>，则 <span class="math inline">\(t(l)
\times l\)</span> 增加了 <span class="math inline">\(k \times
l\)</span>；<span class="math inline">\(t(r + 1)\)</span> 减少了 <span
class="math inline">\(k\)</span>，则 <span class="math inline">\(t(r +
1) \times (r + 1)\)</span> 减少了 <span class="math inline">\(k \times
(r + 1)\)</span>。</p>
<p>总结一下就是 <code>t[l] += l * k</code>,
<code>t[r + 1] -= (r + 1) * k</code>。</p>
<p>代码见模板。</p>
<h2 id="模板">模板</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="comment">/* tot 的最大值 */</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="comment">/* 模数 */</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123; <span class="comment">// Binary Indexed Tree</span></span><br><span class="line">    <span class="type">int</span> tot;</span><br><span class="line">    <span class="keyword">struct</span> &#123; <span class="comment">// 单点修改，区间查询</span></span><br><span class="line">        <span class="type">int</span> c[N];</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(r == <span class="number">0</span>) <span class="keyword">return</span> c[<span class="number">0</span>];</span><br><span class="line">            LL ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(r) ret = (ret + c[r]) % MOD, r -= (r &amp; -r);</span><br><span class="line">            <span class="keyword">return</span> (ret + c[<span class="number">0</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>) &#123; c[x] = (c[x] + y) % MOD; <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="keyword">while</span>(x &lt;= tot) c[x] = (c[x] + y) % MOD, x += (x &amp; -x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; tr1, tr2;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> ((LL)(r + <span class="number">1</span>) * tr1.<span class="built_in">query_sum</span>(r) % MOD - tr2.<span class="built_in">query_sum</span>(r) + MOD) % MOD; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">query_sum</span>(r);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">query_sum</span>(r) - <span class="built_in">query_sum</span>(l - <span class="number">1</span>) + MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify_add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        tr1.<span class="built_in">modify_add</span>(r + <span class="number">1</span>, -k + MOD), tr1.<span class="built_in">modify_add</span>(l, k);</span><br><span class="line">        tr2.<span class="built_in">modify_add</span>(r + <span class="number">1</span>, -((LL)k * (r + <span class="number">1</span>) % MOD) + MOD), tr2.<span class="built_in">modify_add</span>(l, (LL)k * l % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用前记得先写：xxx.tot = n /* 树状数组下标最大值 */;</span></span><br></pre></td></tr></table></figure>
<h2 id="题目推荐">题目推荐</h2>
<details class="note no-icon info"><summary><p><a href="https://www.luogu.com.cn/problem/P3374">洛谷 P3374</a></p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> a[N], dif[N], c[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">		c[x] += d;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">total</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		tot += c[x];</span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dif[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">change</span>(i, dif[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> type;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l, r, k;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">			<span class="built_in">change</span>(l, k);</span><br><span class="line">			<span class="built_in">change</span>(r + <span class="number">1</span>, -k);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> k;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">total</span>(k));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">1 5 4 2 3</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">2 2 5</span></span><br><span class="line"><span class="comment">1 3 -1</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">2 1 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</details>
<details class="note no-icon info"><summary><p><a href="https://www.luogu.com.cn/problem/P3368">洛谷 P3368</a></p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">		c[x] += d;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">total</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		tot += c[x];</span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		<span class="built_in">change</span>(i, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> type, l, r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;type, &amp;l, &amp;r);</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">1</span>) <span class="built_in">change</span>(l, r);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">total</span>(r) - <span class="built_in">total</span>(l - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">1 5 4 2 3</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">2 2 5</span></span><br><span class="line"><span class="comment">1 3 -1</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">2 1 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</details>
<div class="note no-icon warning"><p><strong>参考及图片来源：</strong> <a
href="https://www.cnblogs.com/xenny/p/9739600.html"
class="uri">https://www.cnblogs.com/xenny/p/9739600.html</a></p>
</div>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数讲稿</title>
    <url>/post/generating-function-lecture-notes/</url>
    <content><![CDATA[<h2 id="矩阵行列式与矩阵树定理">矩阵、行列式与矩阵树定理</h2>
<p><a
href="https://www.luogu.com.cn/blog/ixRic/matrix-tree-theory">参考</a></p>
<h3 id="简单线性代数前置知识">简单线性代数前置知识</h3>
<ol type="1">
<li>矩阵
<ul>
<li>矩阵的定义：数表
<ul>
<li><span class="math inline">\(n\)</span> 阶矩阵</li>
<li>全 0 矩阵：<span class="math inline">\(O\)</span></li>
<li><span class="math inline">\(n\)</span> 维行向量、<span
class="math inline">\(n\)</span> 维列向量</li>
<li>主对角线、副对角线</li>
<li>上三角矩阵、下三角矩阵、对角矩阵
<ul>
<li>数量矩阵（对角线全相同的对角矩阵）</li>
<li>单位矩阵（对角线为 <span class="math inline">\(1\)</span>
的数量矩阵，一般记作 <span class="math inline">\(E\)</span>）</li>
</ul></li>
</ul></li>
<li>矩阵加法、数乘、乘法
<ul>
<li>乘法满足结合律</li>
</ul></li>
<li>矩阵的转置
<ul>
<li><span class="math inline">\((A^T)^T=A\)</span></li>
<li><span class="math inline">\((A+B)^T=A^T+B^T\)</span></li>
<li><span class="math inline">\((AB)^T=B^TA^T\)</span></li>
<li><span class="math inline">\((kA)^T=kA^T\)</span></li>
</ul></li>
<li>分块矩阵
<ul>
<li>定义</li>
<li>加减法、数乘</li>
<li>乘法</li>
<li>转置</li>
<li>分块对角矩阵</li>
</ul></li>
<li>行/列初等变换
<ul>
<li>内容
<ul>
<li>交换两行/列</li>
<li>将一行/列 <span class="math inline">\(\times k\)</span></li>
<li>将一行/列 <span class="math inline">\(\times k\)</span>
并加到另一行/列上</li>
</ul></li>
<li>都是可逆的</li>
<li>行/列阶梯形矩阵、行/列最简形矩阵</li>
<li>标准型矩阵</li>
<li><strong>Bonus:</strong>
自行了解齐次线性方程组与行/列最简形矩阵的关系</li>
<li>初等矩阵（P25）
<ul>
<li>初等矩阵的逆</li>
<li>行初等变换相当于左乘初等矩阵，列初等变换相当于右乘初等矩阵</li>
</ul></li>
<li>行等价、列等价与等价</li>
</ul></li>
<li>逆矩阵
<ul>
<li>定义：对于 <span class="math inline">\(A\)</span>，如果存在 <span
class="math inline">\(AB=BA=E\)</span>，那么称 <span
class="math inline">\(B\)</span> 是 <span
class="math inline">\(A\)</span> 的逆矩阵，记作 <span
class="math inline">\(A^{-1}\)</span></li>
<li>性质
<ul>
<li>若 <span class="math inline">\(A\)</span> 可逆，则 <span
class="math inline">\(A^{-1}\)</span> 可逆，且 <span
class="math inline">\((A^{-1})^{-1}=A\)</span></li>
<li>若 <span class="math inline">\(A_1,A_2,\cdots A_k\)</span>
都可逆，则 <span class="math inline">\(A_1A_2\cdots A_k\)</span>
也可逆，且 <span class="math inline">\((A_1A_2\cdots A+k)^{-1} =
A_k^{-1} A_{k-1}^{-1} \cdots A_1^{-1}\)</span></li>
<li>若 <span class="math inline">\(A\)</span> 可逆，则 <span
class="math inline">\(A^T\)</span> 也可逆，且 <span
class="math inline">\((A^T)^{-1}=(A^{-1})^T\)</span></li>
<li>若 <span class="math inline">\(A\)</span> 可逆且 <span
class="math inline">\(k\ne 0\)</span>，则 <span
class="math inline">\(kA\)</span> 可逆，且 <span
class="math inline">\((kA)^{-1} = k^{-1}A^{-1}\)</span></li>
</ul></li>
<li>（逆矩阵与初等变换的关系）下面三个命题互相等价：（P27）
<ul>
<li><span class="math inline">\(n\)</span> 阶矩阵 <span
class="math inline">\(A\)</span> 可逆</li>
<li><span class="math inline">\(n\)</span> 阶矩阵 <span
class="math inline">\(A\)</span> 行（列）等价于 <span
class="math inline">\(E\)</span></li>
<li>矩阵 <span class="math inline">\(A\)</span>
可表示为若干初等矩阵的乘积</li>
</ul></li>
</ul></li>
</ul></li>
<li>行列式
<ul>
<li><span class="math inline">\(n\)</span> 阶行列式的定义
<ul>
<li><span class="math inline">\(|A|=\det A=\sum_{\{p_i\}\in
P}(-1)^{\tau(p)}a_{1p_1}a_{2p_2}\cdots a_{np_n}\)</span></li>
</ul></li>
<li>性质
<ul>
<li>上三角矩阵、下三角矩阵和对角矩阵的行列式都等于对角线元素之积</li>
<li><span class="math inline">\(|A| = |A^T|\)</span></li>
<li>互换行列式的两行/列，行列式变号</li>
<li>如果行列式的两行/列相等，则行列式为 <span
class="math inline">\(0\)</span></li>
<li>行列式的数乘（将某行/列乘上 <span
class="math inline">\(k\)</span>，行列式的值也乘上 <span
class="math inline">\(k\)</span>）</li>
<li><span class="math inline">\(|kA| = k^n|A|\)</span></li>
<li>如果行列式的某行/列全为 <span
class="math inline">\(0\)</span>，则行列式为 <span
class="math inline">\(0\)</span></li>
<li>如果行列式的某两行/列对应成比例，则行列式为 <span
class="math inline">\(0\)</span></li>
<li>行列式的拆分定理（P43）</li>
<li>把行列式的某行（列）<span class="math inline">\(\times k\)</span>
加到另外一行（列），行列式不变</li>
</ul></li>
<li>行列式可逆的充要条件是 <span class="math inline">\(|A|\ne
0\)</span></li>
<li><span class="math inline">\(|AB| = |A|\cdot |B|\)</span>（P49）</li>
</ul></li>
<li>余子式、代数余子式（选学，不想听证明可以不管）
<ul>
<li>定义
<ul>
<li>余子式：<span class="math inline">\(M_{ij}\)</span>，表示将矩阵
<span class="math inline">\(A\)</span> 的第 <span
class="math inline">\(i\)</span> 行和第 <span
class="math inline">\(j\)</span> 列去掉得到的矩阵的行列式</li>
<li>代数余子式：<span
class="math inline">\(A_{ij}=(-1)^{i+j}M_{ij}\)</span></li>
</ul></li>
<li>矩阵按行、列展开（拉普拉斯展开）（P53）
<ul>
<li><span class="math inline">\(\forall 1\le i\le n, |A|=\sum_{k=1}^n
a_{ik} A_{ik}\)</span></li>
<li><span class="math inline">\(\forall 1\le j\le n, |B|=\sum_{k=1}^n
a_{kj} A_{kj}\)</span></li>
<li>推论：<span class="math inline">\(\forall i\ne j,
a_{i1}A_{j1}+a_{i2}A_{j2}+\cdots a_{in}A_{jn}=0\)</span>（P56）</li>
<li>推论：<span class="math inline">\(\forall i\ne j,
a_{1i}A_{1j}+a_{2i}A_{2j}+\cdots a_{ni}A_{nj}=0\)</span>（P56）</li>
</ul></li>
</ul></li>
</ol>
<h3 id="矩阵树定理">矩阵树定理</h3>
<ol type="1">
<li><a
href="https://www.luogu.com.cn/blog/SalomeJLQ/binet-cauchy-gong-shi-ji-ji-ying-yong">Binet-Cauchy
定理</a></li>
<li>基尔霍夫矩阵</li>
<li>引理</li>
<li>证明</li>
</ol>
<p><strong>Bonus:</strong> Cayley 公式</p>
<h3 id="习题">习题</h3>
<p><a href="https://www.luogu.com.cn/problem/P3317">P3317 [SDOI2014]
重建</a><br />
<a href="http://codeforces.com/problemset/problem/917/D">Stranger
Trees</a><br />
<a href="https://www.luogu.com.cn/problem/P4336">P4336 [SHOI2016]
黑暗前的幻想乡</a></p>
<hr />
<h2 id="普通生成函数-ogf">普通生成函数 OGF</h2>
<p><a
href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan">参考</a></p>
<h3 id="引入">引入</h3>
<ol type="1">
<li>定义
<ul>
<li>ordinary generating function</li>
<li>数乘、卷积定义</li>
</ul></li>
<li>求 Fibonacci</li>
</ol>
<h3 id="简单运算">简单运算</h3>
<p>首先有一个经典的生成函数：</p>
<p><span class="math inline">\(\langle 1, 1, 1, \cdots \rangle
{\overset{\mathbf{OGF}}{\longrightarrow}} \dfrac{1}{1 - x}\)</span></p>
<p>然后有一些变换：</p>
<ol type="1">
<li>平移
<ul>
<li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle
\longrightarrow \langle \underbrace{0, 0, \cdots, 0}_{c\ 个}, a_0, a_1,
a_2, \cdots \rangle\)</span></li>
<li><span class="math inline">\(F(x) \to x^c F(x)\)</span></li>
</ul></li>
<li>拉伸
<ul>
<li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle
\longrightarrow \langle a_0, \underbrace{0, 0, \cdots, 0}_{c - 1\ 个},
a_1, \underbrace{0, 0, \cdots, 0}_{c - 1\ 个}, \cdots
\rangle\)</span></li>
<li><span class="math inline">\(F(x) \to F(x^c)\)</span></li>
</ul></li>
<li>扩倍（数乘）
<ul>
<li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle
\longrightarrow \langle ka_0, ka_1, ka_2, \cdots \rangle\)</span></li>
<li><span class="math inline">\(F(x) \to kF(x)\)</span></li>
</ul></li>
<li>乘等比数列
<ul>
<li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle
\longrightarrow \langle a_0c^0, a_1c^1, a_2c^2, \cdots
\rangle\)</span></li>
<li><span class="math inline">\(F(x) \to F(cx)\)</span></li>
</ul></li>
<li>求导
<ul>
<li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle
\longrightarrow \langle a_1, 2a_2, 3a_3, \cdots \rangle\)</span></li>
<li><span class="math inline">\(F(x) \to F&#39;(x)\)</span></li>
<li>更进一步的：
<ul>
<li><span class="math inline">\(\langle a_0, a_1, a_2, \cdots \rangle
\longrightarrow \langle c^{\underline{c}}\times a_c,
(c+1)^{\underline{c}}\times a_{c + 1}, (c+2)^{\underline{c}}\times a_{c
+ 2}, \cdots \rangle = \sum\limits_{i=c}i^{\underline{c}}a_i
x^{i-c}\)</span></li>
</ul></li>
</ul></li>
</ol>
<p>另外还有一些更加困难一点的东西：</p>
<p>（前置：二项式定理，广义二项式定理，经典微积分）</p>
<ul>
<li><span class="math inline">\(\sum\limits_{i=0}\dbinom{n}{i}x^i =
(x+1)^n\)</span></li>
<li><span class="math inline">\(\sum\limits_{i=0}(-1)^i\dbinom{n}{i}x^i
= (1-x)^n\)</span></li>
<li><span class="math inline">\(\sum\limits_{i=0}\dbinom{n+i}{i}x^i =
\dfrac{1}{(1-x)^{n+1}}\)</span></li>
<li><span class="math inline">\(\sum\limits_{i=1}\dfrac{x^i}{i} = -\ln
(1-x)\)</span></li>
</ul>
<h3 id="例题">例题</h3>
<ol type="1">
<li><span class="math inline">\(a_n = 8a_{n-1} + 10^{n -
1}\)</span>，<span class="math inline">\(a_1=9\)</span>，求 <span
class="math inline">\(a\)</span> 的通项公式。</li>
<li>生成函数推 Catalan 数 <span class="math inline">\(h_n (0\le n\le
n)\)</span>：</li>
</ol>
<p><span class="math display">\[
h_n = \begin{cases}
    \sum_{i=0}^{n-1} h_i h_{n-i-1} &amp;(n\ge 2)\\
    1 &amp;(n\in [0, 1])
\end{cases}
\]</span></p>
<ol start="3" type="1">
<li>请尝试用生成函数方法证明下面两个问题的答案相等：（<strong>Bonus:</strong>
其实这个可以建立双射，<del>留作思考题</del>）
<ul>
<li>把 <span class="math inline">\(n\)</span>
分为若干份，每份为正奇数的方案数</li>
<li>把 <span class="math inline">\(n\)</span>
分为若干个不同正整数之和的方案数</li>
</ul></li>
<li><a href="https://codeforces.com/problemset/problem/1821/F">CF1821F
Timber</a>
<ul>
<li>比较入门的题</li>
</ul></li>
</ol>
<h3 id="习题-1">习题</h3>
<p><a href="https://www.luogu.com.cn/problem/P3978">P3978 [TJOI2015]
概率论</a><br />
<a href="https://hydro.ac/d/bzoj/p/2173">BZOJ 2173
「国家集训队」整数的lqp拆分</a><br />
<a href="https://hydro.ac/d/bzoj/p/3027">BZOJ 3027
[CEOI2004]Sweet</a></p>
<h3 id="拓展">拓展</h3>
<p>自行了解：</p>
<ul>
<li>计算 <span class="math inline">\(\sum\limits_{k\ge
0}\dbinom{k}{n-k}\)</span> 的封闭形式。（Snake Oil Trick，<a
href="https://codeforces.com/blog/entry/77468">解法</a> 直接翻到 Snake
Oil Trick 那里）</li>
<li><a
href="https://www.luogu.com.cn/blog/456690/wu-bian-xing-shuo-ding-li">五边形数定理</a></li>
</ul>
<hr />
<h2 id="指数生成函数">指数生成函数</h2>
<p><a
href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan">参考</a></p>
<h3 id="引入-1">引入</h3>
<ol type="1">
<li>定义
<ul>
<li>exponential generating function</li>
<li>数乘、卷积定义</li>
</ul></li>
</ol>
<h3 id="简单运算-1">简单运算</h3>
<ol type="1">
<li><span class="math inline">\(\langle 1, 1, 1, \cdots \rangle
{\overset{\mathbf{EGF}}{\longrightarrow}} e^x\)</span>
<ul>
<li>泰勒展开</li>
</ul></li>
<li><span class="math inline">\(\langle 1, -1, 1, -1, 1, \cdots \rangle
{\overset{\mathbf{EGF}}{\longrightarrow}} e^{-x}\)</span></li>
<li><span class="math inline">\(\langle c^0, c^1, c^2, \cdots \rangle
{\overset{\mathbf{EGF}}{\longrightarrow}} e^{cx}\)</span></li>
<li><span class="math inline">\(\langle 1, 0, 1, 0, 1, 0, \cdots \rangle
{\overset{\mathbf{EGF}}{\longrightarrow}}
\dfrac{e^x+e^{-x}}{2}\)</span></li>
<li><span class="math inline">\(\langle 1, \alpha,
\alpha^{\underline{1}}, \alpha^{\underline{2}}, \alpha^{\underline{3}},
\cdots \rangle {\overset{\mathbf{EGF}}{\longrightarrow}} (1 +
x)^\alpha\)</span>
<ul>
<li><span class="math inline">\(\alpha\)</span> 可以为实数</li>
<li>广义二项式定理</li>
</ul></li>
</ol>
<h3 id="组合对象的拼接卷积ln-exp-与-egf">“组合对象的拼接”——卷积，ln, exp
与 EGF</h3>
<ol type="1">
<li>EGF 卷积——组合对象的“归并”
<ul>
<li><strong>OGF:</strong>
<code>&#123;AAA&#125;×&#123;BBB&#125;=&#123;AAABBB&#125;</code>（集合的合并）</li>
<li><strong>EGF:</strong>
<code>(AAA)×(BBB)=&#123;(AAABBB),(AABBAB),(ABBAAB),(BBAAAB),……&#125;</code>共
<span class="math inline">\(\binom{3+4}{3}\)</span>
种（序列的归并）</li>
</ul></li>
<li>对 EGF 进行 <span
class="math inline">\(\exp\)</span>——组合对象的“生成集合”
<ul>
<li><span class="math inline">\(\exp F(x) =
\sum\limits_{i=0}\dfrac{F^i(x)}{i!}\)</span></li>
<li>将 <span class="math inline">\(F(x)\)</span>
看成一个“元素”，对若干个“元素”的有标号集合计数
<ul>
<li>有标号集合的“元素”之间无序（因为除以了阶乘），“元素”内部的东西是
<strong>有编号</strong> 的（因为需要归并）</li>
<li>如果长度为 <span class="math inline">\(n\)</span> 的置换环个数为
<span class="math inline">\(f(n)\)</span>，设其 EGF 为 <span
class="math inline">\(F(x)\)</span>，则长度为 <span
class="math inline">\(n\)</span> 的置换环集合（即长度为 <span
class="math inline">\(n\)</span> 的排列）的个数为 <span
class="math inline">\([\frac{x^n}{n!}]\exp F(x)\)</span></li>
<li>如果 <strong>有标号</strong> 生成树的 EGF 为 <span
class="math inline">\(F(x)\)</span>，则 <strong>有标号</strong> 森林的
EGF 为 <span class="math inline">\(\exp F(x)\)</span></li>
</ul></li>
</ul></li>
</ol>
<h3 id="例题-1">例题</h3>
<ol type="1">
<li>求第一、二类斯特林数的一列。（需要多项式快速幂）</li>
<li>有标号连通无向图计数
<ul>
<li>设有标号简单无向图的 EGF 为 <span class="math inline">\(F(x) =
\sum\limits_{i=0} \dfrac{2^{i(i-1)/2}}{i!}x^i\)</span>，则答案为 <span
class="math inline">\(\ln F(x)\)</span>。</li>
</ul></li>
<li><a href="https://www.luogu.com.cn/problem/P7364">P7364
有标号二分图计数</a>
<ul>
<li>考虑一张连通二分图的黑白染色方案为 <span
class="math inline">\(2\)</span></li>
<li>我们只需要枚举黑点集合然后连边，就能得出任意二分图染色数</li>
<li>然后 <span class="math inline">\(\ln\)</span>
就是连通二分图染色数</li>
<li>然后除以 <span class="math inline">\(2\)</span>
就能算出连通二分图个数</li>
<li>最后再 <span class="math inline">\(\exp\)</span>
回去就是任意二分图个数了</li>
<li>发现设任意二分图染色方案的 EGF 为 <span
class="math inline">\(F(x)\)</span>，那么答案是 <span
class="math inline">\(\exp(\frac 12 \ln F(x))\)</span>，容易发现这就等于
<span
class="math inline">\(\sqrt{F(x)}\)</span>，可以减小代码长度和常数。</li>
</ul></li>
<li><a href="https://atcoder.jp/contests/abc231/tasks/abc231_g">ABC231G
Balls in Boxes</a></li>
</ol>
<h3 id="习题-2">习题</h3>
<ol type="1">
<li><a href="http://poj.org/problem?id=3734">POJ3734 Blocks</a>（无需
FFT/NTT）</li>
<li><a href="http://poj.org/problem?id=1322">POJ1322 Chocolate</a>（无需
FFT/NTT）</li>
<li><a href="https://www.luogu.com.cn/problem/P4389">P4389
付公主的背包</a>（需要 FFT/NTT）</li>
</ol>
<hr />
<h2 id="多项式全家桶">多项式全家桶</h2>
<p><a
href="https://www.luogu.com.cn/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong">参考</a></p>
<p>题外话：我有一份封装模板，需要的可以找我要，<del>我感觉跑得还是挺快的</del>。</p>
<h3 id="fft-与-ntt">FFT 与 NTT</h3>
<p>移步<a href="/post/fast-fourier-transform">我的博客</a>。</p>
<p><strong>Bonus:</strong> DIF 与 DIT，可以参考<a
href="https://charleswu.site/archives/3065">这个</a>。</p>
<p><strong>例题：</strong> 求第二类斯特林数的一行。</p>
<h3 id="牛顿迭代法">牛顿迭代法</h3>
<p>对于函数 <span class="math inline">\(F(x)\)</span>，如果有 <span
class="math inline">\(G(F(x)) = 0\)</span>，并且我们已经求出 <span
class="math inline">\(G(F_*(x)) \equiv 0 \pmod{x^{\frac
n2}}\)</span>，那么我们就可以通过牛顿迭代求出 <span
class="math inline">\(F \bmod x^n\)</span>：</p>
<p><span class="math display">\[
F(x) \equiv F_*(x) - \frac{G(F_*(x))}{G&#39;(F_*(x))} \pmod{x^{n}}
\]</span></p>
<p>注意这里的 <span class="math inline">\(G&#39;(F_*(x))\)</span> 是以
<span class="math inline">\(F(x)\)</span> 为主元的，即 <span
class="math inline">\(\dfrac{\operatorname{d}
G(F_*(x))}{\operatorname{d} F_*(x)}\)</span>。</p>
<p>一个需要注意的地方是 <span
class="math inline">\(\dfrac{1}{G&#39;(F_*(x))}\)</span>
的精度只需要达到 <span class="math inline">\(x^{\frac n2}\)</span>，因为
<span class="math inline">\(G(F_*(x))\)</span> 的前 <span
class="math inline">\(\frac n2\)</span> 项必然为 <span
class="math inline">\(0\)</span>（定义）。</p>
<p>证明：</p>
<p>首先显然有 <span class="math inline">\(F(x) \equiv F_*(x)
\pmod{x^{\frac n2}}\)</span>。我们把 <span
class="math inline">\(G(F(x))\)</span> 在 <span
class="math inline">\(F_*(x)\)</span> 处泰勒展开：</p>
<p><span class="math display">\[
G(F(x)) = G(F_*(x)) + \frac{G&#39;(F_*(x))}{1!}(F(x) - F_*(x)) +
\frac{G&#39;&#39;(F_*(x))}{2!}(F(x) - F_*(x))^2 + \cdots
\]</span></p>
<p>看起来这个式子更加复杂了，但是我们发现 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(F_*(x)\)</span> 的前 <span
class="math inline">\(\frac n2\)</span> 项都相同，所以 <span
class="math inline">\(F(x) - F_*(x)\)</span> 的后 <span
class="math inline">\(\frac n2\)</span> 项为 <span
class="math inline">\(0\)</span>，进而我们可以得到 <span
class="math inline">\((F(x) - F_*(x))^c \bmod x^n = 0 (c\ge
2)\)</span>。所以我们可以把上面的式子写为：</p>
<p><span class="math display">\[
\begin{aligned}
   G(F(x)) &amp;\equiv G(F_*(x)) + G&#39;(F_*(x))(F(x) - F_*(x))
&amp;\pmod{x^n}\\
   G&#39;(F_*(x))F(x) &amp;\equiv G(F(x)) - G(F_*(x)) +
G&#39;(F_*(x))F_*(x) &amp;\pmod{x^n}\\
   F(x) &amp;\equiv \frac{G(F(x)) - G(F_*(x)) +
G&#39;(F_*(x))F_*(x)}{G&#39;(F_*(x))} &amp;\pmod{x^n}\\
   &amp;\equiv F_*(x) + \frac{G(F(x)) - G(F_*(x))}{G&#39;(F_*(x))}
&amp;\pmod{x^n}\\
   &amp;\equiv F_*(x) - \frac{G(F_*(x))}{G&#39;(F_*(x))} &amp;\pmod{x^n}
\end{aligned}
\]</span></p>
<h3 id="多项式求逆">多项式求逆</h3>
<p>下面讲的东西基本上都有两种推法，第一种是直接推，第二种是用牛顿迭代。下面只讲牛顿迭代的方法。</p>
<p>记 <span class="math inline">\(F(x)\)</span> 的逆为 <span
class="math inline">\(F^{-1}(x)\)</span>，我们令 <span
class="math inline">\(G(H(x)) = F(x)H(x) - 1\)</span>，那么 <span
class="math inline">\(G(F^{-1}(x))=0\)</span>。套用牛顿迭代的公式：</p>
<p><span class="math display">\[
\begin{aligned}
   F^{-1}(x)
   &amp;\equiv F^{-1}_*(x) - \frac{G(F^{-1}_*(x))}{G&#39;(F^{-1}_*(x))}
&amp;\pmod{x^n}\\
   &amp;\equiv F^{-1}_*(x) - \frac{F(x)F^{-1}_*(x) - 1}{F(x)}
&amp;\pmod{x^n}\\
\end{aligned}
\]</span></p>
<p>注意到 <span class="math inline">\(\dfrac{1}{F(x)}\)</span>
的精度只需要 <span class="math inline">\(x^{\frac
n2}\)</span>，所以可以直接用 <span
class="math inline">\(F^{-1}_*(x)\)</span>。最终的式子是</p>
<p><span class="math display">\[
\begin{aligned}
   F^{-1}(x)
   &amp;\equiv F^{-1}_*(x) - F^{-1}_*(x)(F(x)F^{-1}_*(x) - 1)
&amp;\pmod{x^n}\\
   &amp;\equiv F^{-1}_*(x)(2 - F(x)F^{-1}_*(x)) &amp;\pmod{x^n}\\
\end{aligned}
\]</span></p>
<p>直接倍增+NTT 计算即可。复杂度 <span
class="math inline">\(T(n)=T(\frac n2) + O(n\log n) = O(n\log
n)\)</span>。</p>
<h3 id="多项式开根">多项式开根</h3>
<p>令 <span class="math inline">\(G(H(x)) = H^2(x) - F(x)\)</span>，记
<span class="math inline">\(H(x) = \sqrt{F(x)}\)</span>，则 <span
class="math inline">\(G(H(x)) = 0\)</span>。</p>
<p><span class="math display">\[
\begin{aligned}
   H(x)
   &amp;\equiv H_*(x) - \frac{G(H_*(x))}{G&#39;(H_*(x))}
&amp;\pmod{x^n}\\
   &amp;\equiv H_*(x) - \frac{H_*^2(x) - F(x)}{2H_*(x)}
&amp;\pmod{x^n}\\
   &amp;\equiv \frac{H_*^2(x)+F(x)}{2H_*(x)} &amp;\pmod{x^n}
\end{aligned}
\]</span></p>
<p>直接做即可。</p>
<p>需要注意的是，<span class="math inline">\(\sqrt{F_0}\)</span>
需要求二次剩余。不过一般来说，由于生成函数是有实际意义的，所以基本上都有
<span
class="math inline">\(F_0=1\)</span>，此时不需要二次剩余。（我的板子没写二次剩余，需要保证
<span class="math inline">\(F_0=1\)</span>）</p>
<h3 id="多项式取模">多项式取模</h3>
<p>这个比较简单。</p>
<p>对于 <span class="math inline">\(n\)</span> 次多项式 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(m\)</span> 次多项式 <span
class="math inline">\(G(x)\)</span>，求商（<span class="math inline">\(n
- m\)</span> 次）多项式 <span class="math inline">\(Q(x)\)</span>
和余数（至多 <span class="math inline">\(m - 1\)</span> 次）多项式 <span
class="math inline">\(R(x)\)</span>。注意这里不是模 <span
class="math inline">\(x^n\)</span>
意义下的，所以才会出现余数，和上面的多项式求逆不同。</p>
<p>不难得到 <span class="math inline">\(F(x) = Q(x)\times G(x) +
R(x)\)</span>。</p>
<p>考虑用取模把余数去掉。但是由于余数必然是较低项不好去除，所以我们把所有多项式“翻转”。</p>
<p>具体地，对于 <span class="math inline">\(n\)</span> 次多项式 <span
class="math inline">\(F\)</span>，定义 <span
class="math inline">\(F^T(x)=x^nF(x^{-1})\)</span>，手玩发现 <span
class="math inline">\(F^T(x)\)</span> 就是将 <span
class="math inline">\(F(x)\)</span> 所有系数翻转得到的多项式。</p>
<p><span class="math display">\[
\begin{aligned}
   F(x) &amp;= Q(x)G(x) + R(x)&amp;\\
   F(x^{-1}) &amp;= Q(x^{-1})G(x^{-1}) + R(x^{-1})&amp;\\
   x^nF(x^{-1}) &amp;= x^n Q(x^{-1})G(x^{-1}) + x^n R(x^{-1})&amp;\\
   F^T(x) &amp;= Q^T(x) G^T(x) + x^{n - m + 1}R^T(x)&amp;\\
   F^T(x) &amp;\equiv Q^T(x) G^T(x) &amp;\pmod{x^{n - m + 1}}\\
   Q^T(x) &amp;\equiv \frac{F^T(x)}{G^T(x)} &amp;\pmod{x^{n - m + 1}}\\
\end{aligned}
\]</span></p>
<p>这样就可以用多项式求逆算出 <span
class="math inline">\(Q(x)\)</span>，然后容易算出 <span
class="math inline">\(R(x)\)</span>。</p>
<p><strong>Bonus:</strong> 常系数齐次线性递推（可以参考 <a
href="https://www.luogu.com/article/1s01et5m">这个</a>）</p>
<h3 id="多项式-ln">多项式 ln</h3>
<p>应该保证 <span class="math inline">\([x^0]F(x) = 1\)</span>。</p>
<p>这个很简单：<span class="math inline">\((\ln F(x))&#39; =
\frac{F&#39;(x)}{F(x)}\)</span>，所以 <span class="math inline">\(\ln
F(x) = \int \frac{F&#39;(x)}{F(x)}\)</span></p>
<p>这里说一下 <span class="math inline">\(\ln\)</span> 和 <span
class="math inline">\(\exp\)</span> 的定义：</p>
<p><span class="math display">\[
\ln F(x) = -\sum_{i=0}\frac{(1-F(x))^i}{i}
\]</span></p>
<p><span class="math display">\[
\exp F(x) = \sum_{i=0}\frac{F(x)^i}{i!}
\]</span></p>
<p>这个是麦克劳林级数的定义，这个定义只用到了加法和乘法，所以可以对
<span class="math inline">\(x^n\)</span> 取模而不会出错。</p>
<p>经典的性质在这个定义下仍然成立，如 <span
class="math inline">\(\exp\)</span>, <span
class="math inline">\(\ln\)</span> 互为逆运算，<span
class="math inline">\(\exp(\ln F(x)+\ln G(x))=F(x)\times G(x)\)</span>
等。</p>
<h3 id="多项式-exp">多项式 exp</h3>
<p>应该保证 <span class="math inline">\([x^0]F(x) = 0\)</span>。</p>
<p>由于 <span class="math inline">\(\exp\)</span> 与 <span
class="math inline">\(\ln\)</span> 是逆运算，所以可以牛顿迭代：</p>
<p>令 <span class="math inline">\(G(H(x)) = \ln H(x) - F(x)\)</span>，记
<span class="math inline">\(H(x) = \exp F(x)\)</span>，则 <span
class="math inline">\(G(H(x)) = 0\)</span>。</p>
<p><span class="math display">\[
\begin{aligned}
   H(x)
   &amp;\equiv H_*(x) - \frac{G(H_*(x))}{G&#39;(H_*(x))}
&amp;\pmod{x^n}\\
   &amp;\equiv H_*(x) - \frac{\ln H_*(x) - F(x)}{H^{-1}_*(x)}
&amp;\pmod{x^n}\\
   &amp;\equiv H_*(x) - (\ln H_*(x) - F(x))H_*(x) &amp;\pmod{x^n}\\
   &amp;\equiv H_*(x)(1 - \ln H_*(x) + F(x)) &amp;\pmod{x^n}\\
\end{aligned}
\]</span></p>
<p>但是这个做法既需要使用 <span
class="math inline">\(\ln\)</span>，而且常数还大，根本没有性价比。所以还有一个分治
NTT 的 <span class="math inline">\(O(n\log^2 n)\)</span> 的做法：</p>
<p>设 <span class="math inline">\(G(x) = \exp
F(x)\)</span>，两边同时求导可得 <span
class="math inline">\(G&#39;(x)=G(x)F&#39;(x)\)</span>。</p>
<p>对两边同时提取 <span class="math inline">\(x^n\)</span> 系数，则
<span class="math inline">\((n+1)G_{n+1}=\sum_{i=0}^n
(i+1)F_{i+1}G_{n-i}\)</span>，也就是 <span class="math inline">\(G_n =
\frac 1n \sum_{i=1}^n iF_i G_{n-i}\)</span>。然后就可以分治 NTT 了。</p>
<h3 id="多项式快速幂">多项式快速幂</h3>
<p>很简单。</p>
<p><span class="math inline">\(F^k(x) \equiv \exp(k\times \ln F(x))
\pmod{x^n}\)</span></p>
<p><strong>应用：</strong> 求第一、二类斯特林数的一列。</p>
<h3 id="例题-2">例题</h3>
<p><a href="https://www.luogu.com.cn/problem/P3803">模板题</a></p>
<ol type="1">
<li><a href="https://www.luogu.com.cn/problem/P3338">P3338 [ZJOI2014]
力</a>
<ul>
<li>直接做</li>
</ul></li>
<li><a
href="https://atcoder.jp/contests/JAG2013Spring/tasks/icpc2013spring_f">Point
Distance</a>
<ul>
<li>考虑计算出横纵坐标距离分别为 <span class="math inline">\((x,
y)\)</span> 的点对个数，这是一个“二维差卷积”</li>
<li>差卷积可以通过翻转下标解决</li>
<li>二维的话可以用经典做法：令 <span
class="math inline">\(g_{iT+j}=f_{i,j} (T&gt;2n)\)</span> 并对 <span
class="math inline">\(g\)</span> 做卷积，得到的序列再转回去就是二维 FFT
的答案了。</li>
</ul></li>
<li><a href="https://www.luogu.com.cn/problem/SP8372">SPOJ8372 TSUM -
Triple Sums</a>
<ul>
<li>容斥+NTT</li>
</ul></li>
<li><a href="https://www.luogu.com.cn/problem/P4841">P4841
[集训队作业2013] 城市规划</a>
<ul>
<li>之前有 <span class="math inline">\(\ln\)</span>
的做法，不过这道题可以用多项式求逆做</li>
</ul></li>
</ol>
<h3 id="习题-3">习题</h3>
<ol type="1">
<li><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4609">HDU-4609
3-idiots</a></li>
<li><a href="https://hydro.ac/d/bzoj/p/3771">BZOJ3771 Triple</a></li>
<li><a href="https://www.luogu.com.cn/problem/UVA12298">UVA12298 Super
Poker II</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3723">P3723
[AH2017/HNOI2017] 礼物</a></li>
<li><a href="http://codeforces.com/problemset/problem/623/E">CF623E
Transforming Sequence</a>（较难）</li>
</ol>
<hr />
<h2 id="更高阶的多项式算法">更高阶的多项式算法</h2>
<h3 id="分治-fft">分治 FFT</h3>
<p><a
href="https://www.luogu.com.cn/blog/command-block/ban-zai-xian-juan-ji-xiao-ji">参考</a></p>
<h4 id="分治fft">分治+FFT</h4>
<p>本质上这一部分应该叫 <strong>分治+FFT</strong> 或
<strong>分治套FFT</strong> 而不是 <strong>分治FFT</strong>。</p>
<p>经典运用是求形如 <span class="math inline">\(F(1, n) = \prod_{i=1}^n
(1+a_ix)\)</span> 的多项式。</p>
<p>如果直接计算的话，由于 <span class="math inline">\(n\)</span>
阶多项式和 <span class="math inline">\(m\)</span> 阶多项式相乘的复杂度是
<span class="math inline">\(O((n+m)\log(n+m))\)</span>（FFT）或 <span
class="math inline">\(O(nm)\)</span> 暴力，对于 <span
class="math inline">\(m=2\)</span> 来说至少也是 <span
class="math inline">\(O(n)\)</span> 的。所以直接计算是 <span
class="math inline">\(1+2+\cdots+n=O(n^2)\)</span> 的。</p>
<p>考虑 <span class="math inline">\((n+m)\log (n+m)\)</span> 在 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(m\)</span> 接近时会比较赚，所以考虑 cdq 分治。求
<span class="math inline">\(F(l, r)\)</span> 时先求 <span
class="math inline">\(F(l, mid)\)</span> 和 <span
class="math inline">\(F(mid + 1, r)\)</span> 再乘起来，这样复杂度是
<span class="math inline">\(T(n) = 2T(\frac n2) + O(n \log n) =
O(n\log^2 n)\)</span> 的。</p>
<h4 id="半在线卷积">半在线卷积</h4>
<p>考虑求解形如 <span class="math inline">\(F(x) = F(x)G(x) +
H(x)\)</span> 的多项式，其中 <span class="math inline">\(G(0) =
0\)</span>，那么可以用分治 FFT
解决。（这种情况有时也可以解方程然后多项式求逆）</p>
<p>做法是考虑 cdq。求 <span class="math inline">\(f_{l..r}\)</span>
时先求出 <span class="math inline">\(f_{l..mid}\)</span>，然后将 <span
class="math inline">\(f_{l..mid}\)</span> 到 <span
class="math inline">\(f_{mid+1,r}\)</span> 的贡献用卷积求出来，然后再求
<span class="math inline">\(f_{mid+1..r}\)</span>。</p>
<p>对于 <span class="math inline">\(F(x) = F(x)F(x) + H(x)\)</span>
之类的多项式也可以做，不过有点区别。具体来说我们将 <span
class="math inline">\(f_{l..mid}\times f_{1..mid}\)</span> 对 <span
class="math inline">\(f_{mid+1..r}\)</span> 的贡献求出后再递归 <span
class="math inline">\(f_{mid+1..r}\)</span>。</p>
<h3 id="循环卷积与-bluestein-算法">循环卷积与 bluestein 算法</h3>
<p><a
href="https://www.cnblogs.com/GreenDuck/p/14427244.html">参考</a></p>
<p>bluestein 算法又称 <a
href="https://oi-wiki.org/math/poly/czt/">Chirp-Z 变换</a>。</p>
<p>其实在 NTT 中，如果我们取恰好 <span class="math inline">\(n\)</span>
个点值而不是至少 <span class="math inline">\(2n\)</span>
个点值，那么求出来的就是循环卷积。不过 <span
class="math inline">\(n\)</span> 有可能不是 <span
class="math inline">\(2\)</span> 的幂次，所以需要 bluestein
来计算任意个数个点值。</p>
<p>首先带入点值 <span class="math inline">\(\omega_n^i\)</span>：<span
class="math inline">\(F_k = \sum_{i=0}^n a_i
\omega_n^{ik}\)</span>。</p>
<p>然后发现 <span class="math inline">\(ik = \binom{i+k}{2} -
\binom{i}{2} -
\binom{k}{2}\)</span>（考虑组合意义，即有两个盒子，每个盒子分别有 <span
class="math inline">\(i\)</span> 个球和 <span
class="math inline">\(k\)</span>
个球，求有多少种拿出两个球且分别属于两个盒子的方法），于是上式可以化为：</p>
<p><span class="math display">\[
\begin{aligned}
   F_k
   &amp;=\sum_{i=0}^n a_i
\omega_n^{\binom{i+k}{2}-\binom{i}{2}-\binom{k}{2}}\\
   &amp;=\omega_n^{\binom{k}{2}} \sum_{i=0}^n a_i
\omega_n^{-\binom{i}{2}}\cdot \omega_n^\binom{i+k}{2}\\
   &amp;=\omega_n^{\binom{k}{2}} \sum_i A_{-i}B_{i+k}\\
\end{aligned}
\]</span></p>
<p>其中 <span class="math inline">\(A_i =
a_{-i}\omega_n^{-\binom{-i}{2}}\)</span>，<span
class="math inline">\(B_i=\omega_n^\binom{i}{2}\)</span>。</p>
<p>然后就可以用卷积计算了。</p>
<p>裸题：<a href="http://poj.org/problem?id=2821">POJ2821 TN's Kingdom
III - Assassination</a></p>
<h3 id="转置原理">转置原理</h3>
<p><strong>以下仅供了解。</strong></p>
<h4 id="引入-2">引入</h4>
<p><a
href="https://www.luogu.com.cn/blog/wangrx/tellegen-s--principle">参考1</a>
<a
href="https://www.luogu.com.cn/blog/command-block/zhuai-zhi-yuan-li-xiao-ji">参考2</a></p>
<p>给定过程矩阵 <span class="math inline">\(A\)</span> 以及输入向量
<span class="math inline">\(a\)</span>，求解输出向量 <span
class="math inline">\(b=Aa\)</span>
的算法，被称为线性算法。（又称线性变换）</p>
<p>对于一个线性算法 <span
class="math inline">\(b=Aa\)</span>，一定有另外一个类似的算法 <span
class="math inline">\(b=A^Ta\)</span>，我们称这两个算法
<strong>互为转置</strong>。</p>
<h4 id="内容">内容</h4>
<p><strong>转置原理</strong>
给出了两个互为转置的算法之间互相转化的方法。</p>
<p>对于一个可逆矩阵 <span
class="math inline">\(A\)</span>，我们可以讲它分解为若干初等矩阵的乘积
<span class="math inline">\(E_1E_2\cdots E_m\)</span>，那么 <span
class="math inline">\(b=E_1E_2\cdots E_ma\)</span>。那么它的转置问题就是
<span class="math inline">\(b=A^Ta=E_m^TE_{m-1}^T\cdots
E_1^Ta\)</span>。</p>
<p>也就是说，对于一个线性算法，我们原来是不断将它左乘初等矩阵，那么它的转置问题就是不断地（倒序）左乘上初等矩阵的转置。</p>
<p>然后考虑一个初等矩阵和它转置之间的关系：</p>
<ul>
<li>对于一个交换第 <span class="math inline">\(i\)</span> 行和第 <span
class="math inline">\(j\)</span> 行的矩阵，它的转置和它是一样的</li>
<li>对于一个把第 <span class="math inline">\(i\)</span> 行乘 <span
class="math inline">\(v\)</span> 加到第 <span
class="math inline">\(j\)</span> 行的矩阵，它的转置变成了把第 <span
class="math inline">\(j\)</span> 行乘 <span
class="math inline">\(v\)</span> 加到第 <span
class="math inline">\(i\)</span> 行。</li>
</ul>
<p>所以我们只需要按照上面的规则将原做法进行转置，就可以得到转置问题的解法了。</p>
<p>当然，在实际操作中，为了方便，我们不会真的以初等矩阵为单位来拆分并转置，而是以整合后的矩阵为单位描述算法。</p>
<h4 id="应用">应用</h4>
<h5 id="离散傅里叶变换">离散傅里叶变换</h5>
<p>观察 DFT 的矩阵：</p>
<p><span class="math display">\[
A = [\omega_n^{ij}]_{0\le i,j\le n} =
\begin{bmatrix}
   1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\
   1 &amp; \omega_n &amp; \omega_n^2 &amp; \cdots &amp; \omega_n^{n -
1}\\
   1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \cdots &amp; \omega_n^{2(n
- 1)}\\
   \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
   1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \cdots &amp;
\omega_n^{(n-1)(n-1)}
\end{bmatrix}
\]</span></p>
<p>我们发现它是关于主对角线对称的，也就是说 <span
class="math inline">\(A=A^T\)</span>。所以 DFT
的转置算法就是它本身。</p>
<h5 id="加法卷积">加法卷积</h5>
<p>对于多项式 <span class="math inline">\(F,G,H\)</span> 的乘法 <span
class="math inline">\(H=F\times G\)</span>，如果我们把 <span
class="math inline">\(F\)</span> 看成输入，<span
class="math inline">\(G\)</span> 看成常量，<span
class="math inline">\(H\)</span> 看成输出，则有：</p>
<p><span class="math display">\[
H_k = \sum_{i=0}^k G_i F_{k-i}
\]</span></p>
<p>于是我们可以得到 <span class="math inline">\(b=Aa\)</span> 中 <span
class="math inline">\(a=\begin{bmatrix}F_0\\ F_1\\ \vdots\\
F_n\end{bmatrix}\)</span>，<span
class="math inline">\(b=\begin{bmatrix}H_0\\ H_1\\ \vdots\\
H_n\end{bmatrix}\)</span>，</p>
<p><span class="math display">\[
A=
\begin{bmatrix}
   G_0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0\\
   G_1 &amp; G_0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0\\
   G_2 &amp; G_1 &amp; G_0 &amp; \cdots &amp; 0 &amp; 0\\
   \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp;
\vdots\\
   G_{n-1} &amp; G_{n-2} &amp; G_{n-3} &amp; \cdots &amp; G_0 &amp; 0\\
   G_n &amp; G_{n-1} &amp; G_{n-2} &amp; \cdots &amp; G_1 &amp; G_0
\end{bmatrix}
\]</span></p>
<p>也即 <span class="math inline">\(A_{ij} = [i\ge
j]G_{i-j}\)</span>。</p>
<p>于是 <span class="math inline">\(A^T_{i,j} = [i\le
j]G_{j-i}\)</span>，<span
class="math inline">\((A^Ta)_i=\sum_{j=0}^nA_{i,j}b_j=\sum_{j=i}^nG_{j-i}F_j=\sum_{j=0}^{n-i}G_jF_{j+i}\)</span></p>
<p>于是加法卷积的转置问题是减法卷积，即差卷积。（下面用 <span
class="math inline">\(\times^T\)</span> 表示差卷积）</p>
<h5 id="多项式多点求值">多项式多点求值</h5>
<p><a
href="https://www.luogu.com.cn/blog/vocalise/multipoint-interpolation-vandermonde">参考</a></p>
<p>考虑多项式 <span class="math inline">\(F\)</span> 和序列 <span
class="math inline">\(X\)</span>，求出答案序列 <span
class="math inline">\(Y_i=F(X_i)\)</span>。那么：</p>
<p><span class="math display">\[
Y_k = F(X_k) = \sum_{i}F_iX_k^i
\]</span></p>
<p>于是 <span class="math inline">\(A_{ij} = X_i^j\)</span>，所以 <span
class="math inline">\(A^T_{ij} = X_j^i\)</span>。</p>
<p>那么转置问题就是 <span class="math inline">\(Y_k =
\sum_{i}F_iX_i^k\)</span>，也就是求：</p>
<p><span class="math display">\[
\begin{aligned}
   G(x)
   &amp;=\sum_{k=0}^nY_kx^k\\
   &amp;=\sum_{k=0}^nx^k\sum_{i=0}^nF_iX_i^k\\
   &amp;=\sum_{i=0}^nF_i\sum_{k=0}^nx^kX_i^k\\
   &amp;=\sum_{i=0}^n\frac{F_i}{1-xX_i}
\end{aligned}
\]</span></p>
<p>这是一个经典的分治 FFT
问题。为了下面讨论方便，我们把流程形式化地写出来：</p>
<p>对于区间 <span class="math inline">\([l, r)\)</span>，我们维护分母
<span class="math inline">\(Q_{[l, r)} =
\prod\limits_{i=l}^{r-1}(1-xX_i)\)</span> 和分子 <span
class="math inline">\(\sum\limits_{k=l}^{r-1} F_k
\prod\limits_{\substack{i\in [l, r)\\i\ne
k}}(1-xX_i)\)</span>，那么有：</p>
<p><span class="math display">\[
\begin{aligned}
   Q_{[l, r)} &amp;= Q_{[l, m)}\times Q_{[m, r)}\\
   P_{[l, r)} &amp;= P_{[l, m)}\times Q_{[m, r)} + P_{[m, r)}\times
Q_{[l, m)}
\end{aligned}
\]</span></p>
<p>最终答案就是 <span class="math inline">\(F = P_{[0, n)}\times
\frac{1}{Q_{[0, n)}}\)</span>。</p>
<p>于是我们可以设计出转置问题的算法：</p>
<ol type="1">
<li><span class="math inline">\(Q\)</span>
与输入无关，故视为常数，先预处理</li>
<li>求出 <span class="math inline">\(P_{[0, n)} = F\times^T
\frac{1}{Q_{[0, n)}}\)</span></li>
<li>从上到下 cdq。转置问题的贡献图是 <span class="math inline">\(P_{[l,
m)}\stackrel{\times Q_{[m, r)}}{\longrightarrow}P_{[l,
r)}\stackrel{\times Q_{[l, m)}}{\longleftarrow}P_{[m,
r)}\)</span>，所以原问题的贡献图是 <span class="math inline">\(P_{[l,
m)}\stackrel{\times^T Q_{[m, r)}}{\longleftarrow}P_{[l,
r)}\stackrel{\times^T Q_{[l, m)}}{\longrightarrow}P_{[m,
r)}\)</span>。</li>
</ol>
<p>至此就完成了多点求值。</p>
<h3 id="多项式快速插值">多项式快速插值</h3>
<p>首先考虑拉格朗日插值公式：</p>
<p><span class="math display">\[
\begin{aligned}
   F(x)
   &amp;=\sum_{i=1}^n y_i \prod_{j\ne i}\frac{x-x_j}{x_i-x_j}\\
   &amp;=\sum_{i=1}^n \frac{y_i}{\boxed{\prod_{j\ne i}
(x_i-x_j)}}\prod_{j \ne i} (x - x_j)
\end{aligned}
\]</span></p>
<p>考虑设 <span class="math inline">\(g(x) = \prod_{i=1}^n
(x-x_i)\)</span>，那么框出来的部分就是 <span
class="math inline">\(\dfrac{g(x_i)}{x-x_i}\)</span>。由于它是连续可导的，且在除
<span class="math inline">\(x=x_i\)</span> 以外的点都和 <span
class="math inline">\(\prod_{j\ne i} (x-x_j)\)</span> 值相同。所以 <span
class="math inline">\(x-x_i\)</span> 是它的可去间断点。取极限得 <span
class="math inline">\(\lim_{x\to x_i}\dfrac{F(x)}{x-x_i}=\lim_{x\to
x_i}F&#39;(x) = F&#39;(x_i)\)</span>。</p>
<p>后面就考虑分治 FFT：</p>
<p><span class="math display">\[
\begin{aligned}
   F_{[l, r)}
   &amp;=\sum_{i=l}^r \frac{y_i}{g&#39;(x_i)} \prod_{j\ne i} (x-x_j)\\
   &amp;=F_{[l, mid)}\prod_{j=mid}^{r-1}(x-x_j) + F_{[mid,
r)}\prod_{j=l}^{mid-1}(x-x_j)
\end{aligned}
\]</span></p>
<h3 id="连续整数拉格朗日插值">连续整数拉格朗日插值</h3>
<p>应该不是属于我讲的部分？</p>
<p>给个 <del>板子</del> 例题吧：<a
href="https://codeforces.com/problemset/problem/622/F">CF622F The Sum of
the k-th Powers</a></p>
<h3 id="例题-3">例题</h3>
<ol type="1">
<li><a href="https://uoj.ac/problem/182">UOJ182 a^-1 + b problem</a>
<ul>
<li>找性质</li>
<li>推柿子</li>
<li>多点求值！</li>
</ul></li>
<li><a href="https://www.luogu.com.cn/problem/P5450">P5450 [THUPC2018]
淘米神的树</a>
<ul>
<li>先考虑一个黑点？</li>
<li>建立虚点，转化成基环树</li>
<li>推柿子！</li>
<li>多点求值！</li>
</ul></li>
<li><a href="https://www.luogu.com.cn/problem/P3321">P3321 [SDOI2015]
序列统计</a>
<ul>
<li>加法怎么做？
<ul>
<li>需要循环卷积？</li>
</ul></li>
<li>模意义下的乘法转加法？
<ul>
<li>原根！</li>
</ul></li>
</ul></li>
<li><a href="https://www.luogu.com.cn/problem/P5293">P5293 [HNOI2019]
白兔之舞</a>
<ul>
<li>矩阵乘法</li>
<li>单位根反演</li>
</ul></li>
</ol>
<h3 id="习题-4">习题</h3>
<ol type="1">
<li><a href="https://www.luogu.com.cn/problem/P4191">P4191 [CTSC2010]
性能优化</a>（注意此题不是 bluestein 裸题）</li>
<li><a href="https://atcoder.jp/contests/agc060/tasks/agc060_d">AGC060D
Same Descent Set</a>（较难）</li>
</ol>
<hr />
<h2 id="上升幂下降幂与斯特林">上升幂、下降幂与斯特林</h2>
<h3
id="快速计算第一二类斯特林数的一行列">快速计算第一、二类斯特林数的一行、列</h3>
<p>参考 <a href="https://oi-wiki.org/math/combinatorics/stirling/">OI
Wiki</a></p>
<p>模板题：P5408，P5409，P5395，P5396</p>
<h3 id="下降幂多项式">下降幂多项式</h3>
<p>形如 <span class="math inline">\(F(x) = \sum_{i=0}^n f_i
x^{\underline{i}}\)</span> 的多项式叫做下降幂多项式。</p>
<p>类似的有上升幂多项式，由于和下降幂对称，而且也不常用，所以下面都不讲。</p>
<h4 id="下降幂多项式多点求值和插值">下降幂多项式多点求值和插值</h4>
<p>参考 <a
href="https://www.luogu.com.cn/blog/command-block/solution-p5394">这里</a></p>
<h4 id="下降幂多项式乘法">下降幂多项式乘法</h4>
<p>先多点求值再插值即可。</p>
<h4 id="下降幂多项式与普通多项式互转">下降幂多项式与普通多项式互转</h4>
<p>有两种方法。</p>
<p>第一种比较无脑，但是常数较大，即先将其中一个多点求值，再将另一个快速插值。</p>
<p>第二种是分治 FFT/NTT，具体可以参考题解区（<a
href="https://www.luogu.com.cn/problem/solution/P5393">下降转普通</a>，<a
href="https://www.luogu.com.cn/problem/solution/P5383">普通转下降</a>）</p>
<h3 id="例题-4">例题</h3>
<ol type="1">
<li>第一类斯特林数的一行</li>
<li><a href="https://uoj.ac/problem/269">UOJ269
【清华集训2016】如何优雅地求和</a></li>
</ol>
<h3 id="习题-5">习题</h3>
<ol type="1">
<li><a href="https://www.luogu.com.cn/problem/P6620">P6620 [省选联考
2020 A 卷] 组合数问题</a></li>
<li><a href="http://codeforces.com/problemset/problem/1278/F">CF1278F
Cards</a></li>
</ol>
<hr />
<h2 id="其它应用">其它应用</h2>
<ol type="1">
<li><a href="http://codeforces.com/problemset/problem/528/D">CF528D
Fuzzy Search</a>
<ul>
<li>多项式×字符串</li>
</ul></li>
<li><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7054">HDU7054
Yiwen with Formula</a></li>
</ol>
<p>上面的题目比较有针对性，一般都是针对章节的较为模板化的题目。</p>
<p>如果想要做多项式杂题可以看 grass8cow 的 <a
href="https://vjudge.net/contest/543361">专题</a>（<a
href="https://www.cnblogs.com/cwhfy/protected/p/17123929.html">题解</a>，密码是经典密码）</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
</search>
